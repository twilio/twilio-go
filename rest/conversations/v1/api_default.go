/*
 * Twilio - Conversations
 *
 * This is the public Twilio REST API.
 *
 * API version: 1.17.0
 * Contact: support@twilio.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"

	"strings"
	"time"

	twilio "github.com/twilio/twilio-go/client"
)

type DefaultApiService struct {
	baseURL        string
	requestHandler *twilio.RequestHandler
}

func NewDefaultApiService(requestHandler *twilio.RequestHandler) *DefaultApiService {
	return &DefaultApiService{
		requestHandler: requestHandler,
		baseURL:        "https://conversations.twilio.com",
	}
}

func NewDefaultApiServiceWithClient(client twilio.BaseClient) *DefaultApiService {
	return NewDefaultApiService(twilio.NewRequestHandler(client))
}

// Optional parameters for the method 'CreateConversation'
type CreateConversationParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// The human-readable name of this conversation, limited to 256 characters. Optional.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
	MessagingServiceSid *string `json:"MessagingServiceSid,omitempty"`
	// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
	State *string `json:"State,omitempty"`
	// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
	TimersClosed *string `json:"Timers.Closed,omitempty"`
	// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
	TimersInactive *string `json:"Timers.Inactive,omitempty"`
	// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
	UniqueName *string `json:"UniqueName,omitempty"`
}

func (params *CreateConversationParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateConversationParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateConversationParams) SetAttributes(Attributes string) *CreateConversationParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateConversationParams) SetDateCreated(DateCreated time.Time) *CreateConversationParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *CreateConversationParams) SetDateUpdated(DateUpdated time.Time) *CreateConversationParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *CreateConversationParams) SetFriendlyName(FriendlyName string) *CreateConversationParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateConversationParams) SetMessagingServiceSid(MessagingServiceSid string) *CreateConversationParams {
	params.MessagingServiceSid = &MessagingServiceSid
	return params
}
func (params *CreateConversationParams) SetState(State string) *CreateConversationParams {
	params.State = &State
	return params
}
func (params *CreateConversationParams) SetTimersClosed(TimersClosed string) *CreateConversationParams {
	params.TimersClosed = &TimersClosed
	return params
}
func (params *CreateConversationParams) SetTimersInactive(TimersInactive string) *CreateConversationParams {
	params.TimersInactive = &TimersInactive
	return params
}
func (params *CreateConversationParams) SetUniqueName(UniqueName string) *CreateConversationParams {
	params.UniqueName = &UniqueName
	return params
}

// Create a new conversation in your account&#39;s default service
func (c *DefaultApiService) CreateConversation(params *CreateConversationParams) (*ConversationsV1Conversation, error) {
	path := "/v1/Conversations"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MessagingServiceSid != nil {
		data.Set("MessagingServiceSid", *params.MessagingServiceSid)
	}
	if params != nil && params.State != nil {
		data.Set("State", *params.State)
	}
	if params != nil && params.TimersClosed != nil {
		data.Set("Timers.Closed", *params.TimersClosed)
	}
	if params != nil && params.TimersInactive != nil {
		data.Set("Timers.Inactive", *params.TimersInactive)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Conversation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateConversationMessage'
type CreateConversationMessageParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The channel specific identifier of the message's author. Defaults to `system`.
	Author *string `json:"Author,omitempty"`
	// The content of the message, can be up to 1,600 characters long.
	Body *string `json:"Body,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated. `null` if the message has not been edited.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// The Media SID to be attached to the new Message.
	MediaSid *string `json:"MediaSid,omitempty"`
}

func (params *CreateConversationMessageParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateConversationMessageParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateConversationMessageParams) SetAttributes(Attributes string) *CreateConversationMessageParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateConversationMessageParams) SetAuthor(Author string) *CreateConversationMessageParams {
	params.Author = &Author
	return params
}
func (params *CreateConversationMessageParams) SetBody(Body string) *CreateConversationMessageParams {
	params.Body = &Body
	return params
}
func (params *CreateConversationMessageParams) SetDateCreated(DateCreated time.Time) *CreateConversationMessageParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *CreateConversationMessageParams) SetDateUpdated(DateUpdated time.Time) *CreateConversationMessageParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *CreateConversationMessageParams) SetMediaSid(MediaSid string) *CreateConversationMessageParams {
	params.MediaSid = &MediaSid
	return params
}

// Add a new message to the conversation
func (c *DefaultApiService) CreateConversationMessage(ConversationSid string, params *CreateConversationMessageParams) (*ConversationsV1ConversationConversationMessage, error) {
	path := "/v1/Conversations/{ConversationSid}/Messages"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Author != nil {
		data.Set("Author", *params.Author)
	}
	if params != nil && params.Body != nil {
		data.Set("Body", *params.Body)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.MediaSid != nil {
		data.Set("MediaSid", *params.MediaSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateConversationParticipant'
type CreateConversationParticipantParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversations SDK to communicate. Limited to 256 characters.
	Identity *string `json:"Identity,omitempty"`
	// The address of the participant's device, e.g. a phone or WhatsApp number. Together with the Proxy address, this determines a participant uniquely. This field (with proxy_address) is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
	MessagingBindingAddress *string `json:"MessagingBinding.Address,omitempty"`
	// The address of the Twilio phone number that is used in Group MMS. Communication mask for the Conversation participant with Identity.
	MessagingBindingProjectedAddress *string `json:"MessagingBinding.ProjectedAddress,omitempty"`
	// The address of the Twilio phone number (or WhatsApp number) that the participant is in contact with. This field, together with participant address, is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
	MessagingBindingProxyAddress *string `json:"MessagingBinding.ProxyAddress,omitempty"`
	// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *CreateConversationParticipantParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateConversationParticipantParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateConversationParticipantParams) SetAttributes(Attributes string) *CreateConversationParticipantParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateConversationParticipantParams) SetDateCreated(DateCreated time.Time) *CreateConversationParticipantParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *CreateConversationParticipantParams) SetDateUpdated(DateUpdated time.Time) *CreateConversationParticipantParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *CreateConversationParticipantParams) SetIdentity(Identity string) *CreateConversationParticipantParams {
	params.Identity = &Identity
	return params
}
func (params *CreateConversationParticipantParams) SetMessagingBindingAddress(MessagingBindingAddress string) *CreateConversationParticipantParams {
	params.MessagingBindingAddress = &MessagingBindingAddress
	return params
}
func (params *CreateConversationParticipantParams) SetMessagingBindingProjectedAddress(MessagingBindingProjectedAddress string) *CreateConversationParticipantParams {
	params.MessagingBindingProjectedAddress = &MessagingBindingProjectedAddress
	return params
}
func (params *CreateConversationParticipantParams) SetMessagingBindingProxyAddress(MessagingBindingProxyAddress string) *CreateConversationParticipantParams {
	params.MessagingBindingProxyAddress = &MessagingBindingProxyAddress
	return params
}
func (params *CreateConversationParticipantParams) SetRoleSid(RoleSid string) *CreateConversationParticipantParams {
	params.RoleSid = &RoleSid
	return params
}

// Add a new participant to the conversation
func (c *DefaultApiService) CreateConversationParticipant(ConversationSid string, params *CreateConversationParticipantParams) (*ConversationsV1ConversationConversationParticipant, error) {
	path := "/v1/Conversations/{ConversationSid}/Participants"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.MessagingBindingAddress != nil {
		data.Set("MessagingBinding.Address", *params.MessagingBindingAddress)
	}
	if params != nil && params.MessagingBindingProjectedAddress != nil {
		data.Set("MessagingBinding.ProjectedAddress", *params.MessagingBindingProjectedAddress)
	}
	if params != nil && params.MessagingBindingProxyAddress != nil {
		data.Set("MessagingBinding.ProxyAddress", *params.MessagingBindingProxyAddress)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateConversationScopedWebhook'
type CreateConversationScopedWebhookParams struct {
	// The list of events, firing webhook event for this Conversation.
	ConfigurationFilters *[]string `json:"Configuration.Filters,omitempty"`
	// The studio flow SID, where the webhook should be sent to.
	ConfigurationFlowSid *string `json:"Configuration.FlowSid,omitempty"`
	// The HTTP method to be used when sending a webhook request.
	ConfigurationMethod *string `json:"Configuration.Method,omitempty"`
	// The message index for which and it's successors the webhook will be replayed. Not set by default
	ConfigurationReplayAfter *int `json:"Configuration.ReplayAfter,omitempty"`
	// The list of keywords, firing webhook event for this Conversation.
	ConfigurationTriggers *[]string `json:"Configuration.Triggers,omitempty"`
	// The absolute url the webhook request should be sent to.
	ConfigurationUrl *string `json:"Configuration.Url,omitempty"`
	// The target of this webhook: `webhook`, `studio`, `trigger`
	Target *string `json:"Target,omitempty"`
}

func (params *CreateConversationScopedWebhookParams) SetConfigurationFilters(ConfigurationFilters []string) *CreateConversationScopedWebhookParams {
	params.ConfigurationFilters = &ConfigurationFilters
	return params
}
func (params *CreateConversationScopedWebhookParams) SetConfigurationFlowSid(ConfigurationFlowSid string) *CreateConversationScopedWebhookParams {
	params.ConfigurationFlowSid = &ConfigurationFlowSid
	return params
}
func (params *CreateConversationScopedWebhookParams) SetConfigurationMethod(ConfigurationMethod string) *CreateConversationScopedWebhookParams {
	params.ConfigurationMethod = &ConfigurationMethod
	return params
}
func (params *CreateConversationScopedWebhookParams) SetConfigurationReplayAfter(ConfigurationReplayAfter int) *CreateConversationScopedWebhookParams {
	params.ConfigurationReplayAfter = &ConfigurationReplayAfter
	return params
}
func (params *CreateConversationScopedWebhookParams) SetConfigurationTriggers(ConfigurationTriggers []string) *CreateConversationScopedWebhookParams {
	params.ConfigurationTriggers = &ConfigurationTriggers
	return params
}
func (params *CreateConversationScopedWebhookParams) SetConfigurationUrl(ConfigurationUrl string) *CreateConversationScopedWebhookParams {
	params.ConfigurationUrl = &ConfigurationUrl
	return params
}
func (params *CreateConversationScopedWebhookParams) SetTarget(Target string) *CreateConversationScopedWebhookParams {
	params.Target = &Target
	return params
}

// Create a new webhook scoped to the conversation
func (c *DefaultApiService) CreateConversationScopedWebhook(ConversationSid string, params *CreateConversationScopedWebhookParams) (*ConversationsV1ConversationConversationScopedWebhook, error) {
	path := "/v1/Conversations/{ConversationSid}/Webhooks"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ConfigurationFilters != nil {
		for _, item := range *params.ConfigurationFilters {
			data.Add("Configuration.Filters", item)
		}
	}
	if params != nil && params.ConfigurationFlowSid != nil {
		data.Set("Configuration.FlowSid", *params.ConfigurationFlowSid)
	}
	if params != nil && params.ConfigurationMethod != nil {
		data.Set("Configuration.Method", *params.ConfigurationMethod)
	}
	if params != nil && params.ConfigurationReplayAfter != nil {
		data.Set("Configuration.ReplayAfter", fmt.Sprint(*params.ConfigurationReplayAfter))
	}
	if params != nil && params.ConfigurationTriggers != nil {
		for _, item := range *params.ConfigurationTriggers {
			data.Add("Configuration.Triggers", item)
		}
	}
	if params != nil && params.ConfigurationUrl != nil {
		data.Set("Configuration.Url", *params.ConfigurationUrl)
	}
	if params != nil && params.Target != nil {
		data.Set("Target", *params.Target)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationScopedWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateCredential'
type CreateCredentialParams struct {
	// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
	ApiKey *string `json:"ApiKey,omitempty"`
	// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEF.....A== -----END CERTIFICATE-----`.
	Certificate *string `json:"Certificate,omitempty"`
	// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fG... -----END RSA PRIVATE KEY-----`.
	PrivateKey *string `json:"PrivateKey,omitempty"`
	// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
	Sandbox *bool `json:"Sandbox,omitempty"`
	// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
	Secret *string `json:"Secret,omitempty"`
	// The type of push-notification service the credential is for. Can be: `fcm`, `gcm`, or `apn`.
	Type *string `json:"Type,omitempty"`
}

func (params *CreateCredentialParams) SetApiKey(ApiKey string) *CreateCredentialParams {
	params.ApiKey = &ApiKey
	return params
}
func (params *CreateCredentialParams) SetCertificate(Certificate string) *CreateCredentialParams {
	params.Certificate = &Certificate
	return params
}
func (params *CreateCredentialParams) SetFriendlyName(FriendlyName string) *CreateCredentialParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateCredentialParams) SetPrivateKey(PrivateKey string) *CreateCredentialParams {
	params.PrivateKey = &PrivateKey
	return params
}
func (params *CreateCredentialParams) SetSandbox(Sandbox bool) *CreateCredentialParams {
	params.Sandbox = &Sandbox
	return params
}
func (params *CreateCredentialParams) SetSecret(Secret string) *CreateCredentialParams {
	params.Secret = &Secret
	return params
}
func (params *CreateCredentialParams) SetType(Type string) *CreateCredentialParams {
	params.Type = &Type
	return params
}

// Add a new push notification credential to your account
func (c *DefaultApiService) CreateCredential(params *CreateCredentialParams) (*ConversationsV1Credential, error) {
	path := "/v1/Credentials"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ApiKey != nil {
		data.Set("ApiKey", *params.ApiKey)
	}
	if params != nil && params.Certificate != nil {
		data.Set("Certificate", *params.Certificate)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PrivateKey != nil {
		data.Set("PrivateKey", *params.PrivateKey)
	}
	if params != nil && params.Sandbox != nil {
		data.Set("Sandbox", fmt.Sprint(*params.Sandbox))
	}
	if params != nil && params.Secret != nil {
		data.Set("Secret", *params.Secret)
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Credential{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateRole'
type CreateRoleParams struct {
	// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// A permission that you grant to the new role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type`.
	Permission *[]string `json:"Permission,omitempty"`
	// The type of role. Can be: `conversation` for [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) roles or `service` for [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) roles.
	Type *string `json:"Type,omitempty"`
}

func (params *CreateRoleParams) SetFriendlyName(FriendlyName string) *CreateRoleParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateRoleParams) SetPermission(Permission []string) *CreateRoleParams {
	params.Permission = &Permission
	return params
}
func (params *CreateRoleParams) SetType(Type string) *CreateRoleParams {
	params.Type = &Type
	return params
}

// Create a new user role in your account&#39;s default service
func (c *DefaultApiService) CreateRole(params *CreateRoleParams) (*ConversationsV1Role, error) {
	path := "/v1/Roles"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Permission != nil {
		for _, item := range *params.Permission {
			data.Add("Permission", item)
		}
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Role{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateService'
type CreateServiceParams struct {
	// The human-readable name of this service, limited to 256 characters. Optional.
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *CreateServiceParams) SetFriendlyName(FriendlyName string) *CreateServiceParams {
	params.FriendlyName = &FriendlyName
	return params
}

// Create a new conversation service on your account
func (c *DefaultApiService) CreateService(params *CreateServiceParams) (*ConversationsV1Service, error) {
	path := "/v1/Services"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateServiceConversation'
type CreateServiceConversationParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// The human-readable name of this conversation, limited to 256 characters. Optional.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
	MessagingServiceSid *string `json:"MessagingServiceSid,omitempty"`
	// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
	State *string `json:"State,omitempty"`
	// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
	TimersClosed *string `json:"Timers.Closed,omitempty"`
	// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
	TimersInactive *string `json:"Timers.Inactive,omitempty"`
	// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
	UniqueName *string `json:"UniqueName,omitempty"`
}

func (params *CreateServiceConversationParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateServiceConversationParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateServiceConversationParams) SetAttributes(Attributes string) *CreateServiceConversationParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateServiceConversationParams) SetDateCreated(DateCreated time.Time) *CreateServiceConversationParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *CreateServiceConversationParams) SetDateUpdated(DateUpdated time.Time) *CreateServiceConversationParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *CreateServiceConversationParams) SetFriendlyName(FriendlyName string) *CreateServiceConversationParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateServiceConversationParams) SetMessagingServiceSid(MessagingServiceSid string) *CreateServiceConversationParams {
	params.MessagingServiceSid = &MessagingServiceSid
	return params
}
func (params *CreateServiceConversationParams) SetState(State string) *CreateServiceConversationParams {
	params.State = &State
	return params
}
func (params *CreateServiceConversationParams) SetTimersClosed(TimersClosed string) *CreateServiceConversationParams {
	params.TimersClosed = &TimersClosed
	return params
}
func (params *CreateServiceConversationParams) SetTimersInactive(TimersInactive string) *CreateServiceConversationParams {
	params.TimersInactive = &TimersInactive
	return params
}
func (params *CreateServiceConversationParams) SetUniqueName(UniqueName string) *CreateServiceConversationParams {
	params.UniqueName = &UniqueName
	return params
}

// Create a new conversation in your service
func (c *DefaultApiService) CreateServiceConversation(ChatServiceSid string, params *CreateServiceConversationParams) (*ConversationsV1ServiceServiceConversation, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MessagingServiceSid != nil {
		data.Set("MessagingServiceSid", *params.MessagingServiceSid)
	}
	if params != nil && params.State != nil {
		data.Set("State", *params.State)
	}
	if params != nil && params.TimersClosed != nil {
		data.Set("Timers.Closed", *params.TimersClosed)
	}
	if params != nil && params.TimersInactive != nil {
		data.Set("Timers.Inactive", *params.TimersInactive)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateServiceConversationMessage'
type CreateServiceConversationMessageParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The channel specific identifier of the message's author. Defaults to `system`.
	Author *string `json:"Author,omitempty"`
	// The content of the message, can be up to 1,600 characters long.
	Body *string `json:"Body,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated. `null` if the message has not been edited.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// The Media SID to be attached to the new Message.
	MediaSid *string `json:"MediaSid,omitempty"`
}

func (params *CreateServiceConversationMessageParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateServiceConversationMessageParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateServiceConversationMessageParams) SetAttributes(Attributes string) *CreateServiceConversationMessageParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateServiceConversationMessageParams) SetAuthor(Author string) *CreateServiceConversationMessageParams {
	params.Author = &Author
	return params
}
func (params *CreateServiceConversationMessageParams) SetBody(Body string) *CreateServiceConversationMessageParams {
	params.Body = &Body
	return params
}
func (params *CreateServiceConversationMessageParams) SetDateCreated(DateCreated time.Time) *CreateServiceConversationMessageParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *CreateServiceConversationMessageParams) SetDateUpdated(DateUpdated time.Time) *CreateServiceConversationMessageParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *CreateServiceConversationMessageParams) SetMediaSid(MediaSid string) *CreateServiceConversationMessageParams {
	params.MediaSid = &MediaSid
	return params
}

// Add a new message to the conversation in a specific service
func (c *DefaultApiService) CreateServiceConversationMessage(ChatServiceSid string, ConversationSid string, params *CreateServiceConversationMessageParams) (*ConversationsV1ServiceServiceConversationServiceConversationMessage, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Author != nil {
		data.Set("Author", *params.Author)
	}
	if params != nil && params.Body != nil {
		data.Set("Body", *params.Body)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.MediaSid != nil {
		data.Set("MediaSid", *params.MediaSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateServiceConversationParticipant'
type CreateServiceConversationParticipantParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversation SDK to communicate. Limited to 256 characters.
	Identity *string `json:"Identity,omitempty"`
	// The address of the participant's device, e.g. a phone or WhatsApp number. Together with the Proxy address, this determines a participant uniquely. This field (with proxy_address) is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
	MessagingBindingAddress *string `json:"MessagingBinding.Address,omitempty"`
	// The address of the Twilio phone number that is used in Group MMS. Communication mask for the Conversation participant with Identity.
	MessagingBindingProjectedAddress *string `json:"MessagingBinding.ProjectedAddress,omitempty"`
	// The address of the Twilio phone number (or WhatsApp number) that the participant is in contact with. This field, together with participant address, is only null when the participant is interacting from an SDK endpoint (see the 'identity' field).
	MessagingBindingProxyAddress *string `json:"MessagingBinding.ProxyAddress,omitempty"`
	// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *CreateServiceConversationParticipantParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateServiceConversationParticipantParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateServiceConversationParticipantParams) SetAttributes(Attributes string) *CreateServiceConversationParticipantParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateServiceConversationParticipantParams) SetDateCreated(DateCreated time.Time) *CreateServiceConversationParticipantParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *CreateServiceConversationParticipantParams) SetDateUpdated(DateUpdated time.Time) *CreateServiceConversationParticipantParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *CreateServiceConversationParticipantParams) SetIdentity(Identity string) *CreateServiceConversationParticipantParams {
	params.Identity = &Identity
	return params
}
func (params *CreateServiceConversationParticipantParams) SetMessagingBindingAddress(MessagingBindingAddress string) *CreateServiceConversationParticipantParams {
	params.MessagingBindingAddress = &MessagingBindingAddress
	return params
}
func (params *CreateServiceConversationParticipantParams) SetMessagingBindingProjectedAddress(MessagingBindingProjectedAddress string) *CreateServiceConversationParticipantParams {
	params.MessagingBindingProjectedAddress = &MessagingBindingProjectedAddress
	return params
}
func (params *CreateServiceConversationParticipantParams) SetMessagingBindingProxyAddress(MessagingBindingProxyAddress string) *CreateServiceConversationParticipantParams {
	params.MessagingBindingProxyAddress = &MessagingBindingProxyAddress
	return params
}
func (params *CreateServiceConversationParticipantParams) SetRoleSid(RoleSid string) *CreateServiceConversationParticipantParams {
	params.RoleSid = &RoleSid
	return params
}

// Add a new participant to the conversation in a specific service
func (c *DefaultApiService) CreateServiceConversationParticipant(ChatServiceSid string, ConversationSid string, params *CreateServiceConversationParticipantParams) (*ConversationsV1ServiceServiceConversationServiceConversationParticipant, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.MessagingBindingAddress != nil {
		data.Set("MessagingBinding.Address", *params.MessagingBindingAddress)
	}
	if params != nil && params.MessagingBindingProjectedAddress != nil {
		data.Set("MessagingBinding.ProjectedAddress", *params.MessagingBindingProjectedAddress)
	}
	if params != nil && params.MessagingBindingProxyAddress != nil {
		data.Set("MessagingBinding.ProxyAddress", *params.MessagingBindingProxyAddress)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateServiceConversationScopedWebhook'
type CreateServiceConversationScopedWebhookParams struct {
	// The list of events, firing webhook event for this Conversation.
	ConfigurationFilters *[]string `json:"Configuration.Filters,omitempty"`
	// The studio flow SID, where the webhook should be sent to.
	ConfigurationFlowSid *string `json:"Configuration.FlowSid,omitempty"`
	// The HTTP method to be used when sending a webhook request.
	ConfigurationMethod *string `json:"Configuration.Method,omitempty"`
	// The message index for which and it's successors the webhook will be replayed. Not set by default
	ConfigurationReplayAfter *int `json:"Configuration.ReplayAfter,omitempty"`
	// The list of keywords, firing webhook event for this Conversation.
	ConfigurationTriggers *[]string `json:"Configuration.Triggers,omitempty"`
	// The absolute url the webhook request should be sent to.
	ConfigurationUrl *string `json:"Configuration.Url,omitempty"`
	// The target of this webhook: `webhook`, `studio`, `trigger`
	Target *string `json:"Target,omitempty"`
}

func (params *CreateServiceConversationScopedWebhookParams) SetConfigurationFilters(ConfigurationFilters []string) *CreateServiceConversationScopedWebhookParams {
	params.ConfigurationFilters = &ConfigurationFilters
	return params
}
func (params *CreateServiceConversationScopedWebhookParams) SetConfigurationFlowSid(ConfigurationFlowSid string) *CreateServiceConversationScopedWebhookParams {
	params.ConfigurationFlowSid = &ConfigurationFlowSid
	return params
}
func (params *CreateServiceConversationScopedWebhookParams) SetConfigurationMethod(ConfigurationMethod string) *CreateServiceConversationScopedWebhookParams {
	params.ConfigurationMethod = &ConfigurationMethod
	return params
}
func (params *CreateServiceConversationScopedWebhookParams) SetConfigurationReplayAfter(ConfigurationReplayAfter int) *CreateServiceConversationScopedWebhookParams {
	params.ConfigurationReplayAfter = &ConfigurationReplayAfter
	return params
}
func (params *CreateServiceConversationScopedWebhookParams) SetConfigurationTriggers(ConfigurationTriggers []string) *CreateServiceConversationScopedWebhookParams {
	params.ConfigurationTriggers = &ConfigurationTriggers
	return params
}
func (params *CreateServiceConversationScopedWebhookParams) SetConfigurationUrl(ConfigurationUrl string) *CreateServiceConversationScopedWebhookParams {
	params.ConfigurationUrl = &ConfigurationUrl
	return params
}
func (params *CreateServiceConversationScopedWebhookParams) SetTarget(Target string) *CreateServiceConversationScopedWebhookParams {
	params.Target = &Target
	return params
}

// Create a new webhook scoped to the conversation in a specific service
func (c *DefaultApiService) CreateServiceConversationScopedWebhook(ChatServiceSid string, ConversationSid string, params *CreateServiceConversationScopedWebhookParams) (*ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ConfigurationFilters != nil {
		for _, item := range *params.ConfigurationFilters {
			data.Add("Configuration.Filters", item)
		}
	}
	if params != nil && params.ConfigurationFlowSid != nil {
		data.Set("Configuration.FlowSid", *params.ConfigurationFlowSid)
	}
	if params != nil && params.ConfigurationMethod != nil {
		data.Set("Configuration.Method", *params.ConfigurationMethod)
	}
	if params != nil && params.ConfigurationReplayAfter != nil {
		data.Set("Configuration.ReplayAfter", fmt.Sprint(*params.ConfigurationReplayAfter))
	}
	if params != nil && params.ConfigurationTriggers != nil {
		for _, item := range *params.ConfigurationTriggers {
			data.Add("Configuration.Triggers", item)
		}
	}
	if params != nil && params.ConfigurationUrl != nil {
		data.Set("Configuration.Url", *params.ConfigurationUrl)
	}
	if params != nil && params.Target != nil {
		data.Set("Target", *params.Target)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateServiceRole'
type CreateServiceRoleParams struct {
	// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// A permission that you grant to the new role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. The values for this parameter depend on the role's `type`.
	Permission *[]string `json:"Permission,omitempty"`
	// The type of role. Can be: `conversation` for [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) roles or `service` for [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) roles.
	Type *string `json:"Type,omitempty"`
}

func (params *CreateServiceRoleParams) SetFriendlyName(FriendlyName string) *CreateServiceRoleParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateServiceRoleParams) SetPermission(Permission []string) *CreateServiceRoleParams {
	params.Permission = &Permission
	return params
}
func (params *CreateServiceRoleParams) SetType(Type string) *CreateServiceRoleParams {
	params.Type = &Type
	return params
}

// Create a new user role in your service
func (c *DefaultApiService) CreateServiceRole(ChatServiceSid string, params *CreateServiceRoleParams) (*ConversationsV1ServiceServiceRole, error) {
	path := "/v1/Services/{ChatServiceSid}/Roles"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Permission != nil {
		for _, item := range *params.Permission {
			data.Add("Permission", item)
		}
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceRole{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateServiceUser'
type CreateServiceUserParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The string that you assigned to describe the resource.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The application-defined string that uniquely identifies the resource's User within the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource). This value is often a username or an email address, and is case-sensitive.
	Identity *string `json:"Identity,omitempty"`
	// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *CreateServiceUserParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateServiceUserParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateServiceUserParams) SetAttributes(Attributes string) *CreateServiceUserParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateServiceUserParams) SetFriendlyName(FriendlyName string) *CreateServiceUserParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateServiceUserParams) SetIdentity(Identity string) *CreateServiceUserParams {
	params.Identity = &Identity
	return params
}
func (params *CreateServiceUserParams) SetRoleSid(RoleSid string) *CreateServiceUserParams {
	params.RoleSid = &RoleSid
	return params
}

// Add a new conversation user to your service
func (c *DefaultApiService) CreateServiceUser(ChatServiceSid string, params *CreateServiceUserParams) (*ConversationsV1ServiceServiceUser, error) {
	path := "/v1/Services/{ChatServiceSid}/Users"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceUser{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateUser'
type CreateUserParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The string that you assigned to describe the resource.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The application-defined string that uniquely identifies the resource's User within the [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource). This value is often a username or an email address, and is case-sensitive.
	Identity *string `json:"Identity,omitempty"`
	// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *CreateUserParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *CreateUserParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *CreateUserParams) SetAttributes(Attributes string) *CreateUserParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateUserParams) SetFriendlyName(FriendlyName string) *CreateUserParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateUserParams) SetIdentity(Identity string) *CreateUserParams {
	params.Identity = &Identity
	return params
}
func (params *CreateUserParams) SetRoleSid(RoleSid string) *CreateUserParams {
	params.RoleSid = &RoleSid
	return params
}

// Add a new conversation user to your account&#39;s default service
func (c *DefaultApiService) CreateUser(params *CreateUserParams) (*ConversationsV1User, error) {
	path := "/v1/Users"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1User{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'DeleteConversation'
type DeleteConversationParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteConversationParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteConversationParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a conversation from your account&#39;s default service
func (c *DefaultApiService) DeleteConversation(Sid string, params *DeleteConversationParams) error {
	path := "/v1/Conversations/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteConversationMessage'
type DeleteConversationMessageParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteConversationMessageParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteConversationMessageParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a message from the conversation
func (c *DefaultApiService) DeleteConversationMessage(ConversationSid string, Sid string, params *DeleteConversationMessageParams) error {
	path := "/v1/Conversations/{ConversationSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteConversationParticipant'
type DeleteConversationParticipantParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteConversationParticipantParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteConversationParticipantParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a participant from the conversation
func (c *DefaultApiService) DeleteConversationParticipant(ConversationSid string, Sid string, params *DeleteConversationParticipantParams) error {
	path := "/v1/Conversations/{ConversationSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove an existing webhook scoped to the conversation
func (c *DefaultApiService) DeleteConversationScopedWebhook(ConversationSid string, Sid string) error {
	path := "/v1/Conversations/{ConversationSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove a push notification credential from your account
func (c *DefaultApiService) DeleteCredential(Sid string) error {
	path := "/v1/Credentials/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove a user role from your account&#39;s default service
func (c *DefaultApiService) DeleteRole(Sid string) error {
	path := "/v1/Roles/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove a conversation service with all its nested resources from your account
func (c *DefaultApiService) DeleteService(Sid string) error {
	path := "/v1/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove a push notification binding from the conversation service
func (c *DefaultApiService) DeleteServiceBinding(ChatServiceSid string, Sid string) error {
	path := "/v1/Services/{ChatServiceSid}/Bindings/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteServiceConversation'
type DeleteServiceConversationParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteServiceConversationParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteServiceConversationParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a conversation from your service
func (c *DefaultApiService) DeleteServiceConversation(ChatServiceSid string, Sid string, params *DeleteServiceConversationParams) error {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteServiceConversationMessage'
type DeleteServiceConversationMessageParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteServiceConversationMessageParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteServiceConversationMessageParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a message from the conversation
func (c *DefaultApiService) DeleteServiceConversationMessage(ChatServiceSid string, ConversationSid string, Sid string, params *DeleteServiceConversationMessageParams) error {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteServiceConversationParticipant'
type DeleteServiceConversationParticipantParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteServiceConversationParticipantParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteServiceConversationParticipantParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a participant from the conversation
func (c *DefaultApiService) DeleteServiceConversationParticipant(ChatServiceSid string, ConversationSid string, Sid string, params *DeleteServiceConversationParticipantParams) error {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove an existing webhook scoped to the conversation
func (c *DefaultApiService) DeleteServiceConversationScopedWebhook(ChatServiceSid string, ConversationSid string, Sid string) error {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Remove a user role from your service
func (c *DefaultApiService) DeleteServiceRole(ChatServiceSid string, Sid string) error {
	path := "/v1/Services/{ChatServiceSid}/Roles/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteServiceUser'
type DeleteServiceUserParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteServiceUserParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteServiceUserParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a conversation user from your service
func (c *DefaultApiService) DeleteServiceUser(ChatServiceSid string, Sid string, params *DeleteServiceUserParams) error {
	path := "/v1/Services/{ChatServiceSid}/Users/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Optional parameters for the method 'DeleteUser'
type DeleteUserParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

func (params *DeleteUserParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *DeleteUserParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}

// Remove a conversation user from your account&#39;s default service
func (c *DefaultApiService) DeleteUser(Sid string, params *DeleteUserParams) error {
	path := "/v1/Users/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Fetch the global configuration of conversations on your account
func (c *DefaultApiService) FetchConfiguration() (*ConversationsV1Configuration, error) {
	path := "/v1/Configuration"

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Configuration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

func (c *DefaultApiService) FetchConfigurationWebhook() (*ConversationsV1ConfigurationConfigurationWebhook, error) {
	path := "/v1/Configuration/Webhooks"

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConfigurationConfigurationWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a conversation from your account&#39;s default service
func (c *DefaultApiService) FetchConversation(Sid string) (*ConversationsV1Conversation, error) {
	path := "/v1/Conversations/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Conversation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a message from the conversation
func (c *DefaultApiService) FetchConversationMessage(ConversationSid string, Sid string) (*ConversationsV1ConversationConversationMessage, error) {
	path := "/v1/Conversations/{ConversationSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch the delivery and read receipts of the conversation message
func (c *DefaultApiService) FetchConversationMessageReceipt(ConversationSid string, MessageSid string, Sid string) (*ConversationsV1ConversationConversationMessageConversationMessageReceipt, error) {
	path := "/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"MessageSid"+"}", MessageSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationMessageConversationMessageReceipt{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a participant of the conversation
func (c *DefaultApiService) FetchConversationParticipant(ConversationSid string, Sid string) (*ConversationsV1ConversationConversationParticipant, error) {
	path := "/v1/Conversations/{ConversationSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch the configuration of a conversation-scoped webhook
func (c *DefaultApiService) FetchConversationScopedWebhook(ConversationSid string, Sid string) (*ConversationsV1ConversationConversationScopedWebhook, error) {
	path := "/v1/Conversations/{ConversationSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationScopedWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a push notification credential from your account
func (c *DefaultApiService) FetchCredential(Sid string) (*ConversationsV1Credential, error) {
	path := "/v1/Credentials/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Credential{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a user role from your account&#39;s default service
func (c *DefaultApiService) FetchRole(Sid string) (*ConversationsV1Role, error) {
	path := "/v1/Roles/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Role{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a conversation service from your account
func (c *DefaultApiService) FetchService(Sid string) (*ConversationsV1Service, error) {
	path := "/v1/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a push notification binding from the conversation service
func (c *DefaultApiService) FetchServiceBinding(ChatServiceSid string, Sid string) (*ConversationsV1ServiceServiceBinding, error) {
	path := "/v1/Services/{ChatServiceSid}/Bindings/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceBinding{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch the configuration of a conversation service
func (c *DefaultApiService) FetchServiceConfiguration(ChatServiceSid string) (*ConversationsV1ServiceServiceConfiguration, error) {
	path := "/v1/Services/{ChatServiceSid}/Configuration"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConfiguration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a conversation from your service
func (c *DefaultApiService) FetchServiceConversation(ChatServiceSid string, Sid string) (*ConversationsV1ServiceServiceConversation, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a message from the conversation
func (c *DefaultApiService) FetchServiceConversationMessage(ChatServiceSid string, ConversationSid string, Sid string) (*ConversationsV1ServiceServiceConversationServiceConversationMessage, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch the delivery and read receipts of the conversation message
func (c *DefaultApiService) FetchServiceConversationMessageReceipt(ChatServiceSid string, ConversationSid string, MessageSid string, Sid string) (*ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"MessageSid"+"}", MessageSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a participant of the conversation
func (c *DefaultApiService) FetchServiceConversationParticipant(ChatServiceSid string, ConversationSid string, Sid string) (*ConversationsV1ServiceServiceConversationServiceConversationParticipant, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch the configuration of a conversation-scoped webhook
func (c *DefaultApiService) FetchServiceConversationScopedWebhook(ChatServiceSid string, ConversationSid string, Sid string) (*ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch push notification service settings
func (c *DefaultApiService) FetchServiceNotification(ChatServiceSid string) (*ConversationsV1ServiceServiceConfigurationServiceNotification, error) {
	path := "/v1/Services/{ChatServiceSid}/Configuration/Notifications"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConfigurationServiceNotification{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a user role from your service
func (c *DefaultApiService) FetchServiceRole(ChatServiceSid string, Sid string) (*ConversationsV1ServiceServiceRole, error) {
	path := "/v1/Services/{ChatServiceSid}/Roles/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceRole{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a conversation user from your service
func (c *DefaultApiService) FetchServiceUser(ChatServiceSid string, Sid string) (*ConversationsV1ServiceServiceUser, error) {
	path := "/v1/Services/{ChatServiceSid}/Users/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceUser{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a conversation user from your account&#39;s default service
func (c *DefaultApiService) FetchUser(Sid string) (*ConversationsV1User, error) {
	path := "/v1/Users/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1User{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListConversation'
type ListConversationParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListConversationParams) SetPageSize(PageSize int) *ListConversationParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of conversations in your account&#39;s default service
func (c *DefaultApiService) ListConversation(params *ListConversationParams) (*ListConversationResponse, error) {
	path := "/v1/Conversations"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListConversationResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListConversationMessage'
type ListConversationMessageParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListConversationMessageParams) SetPageSize(PageSize int) *ListConversationMessageParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all messages in the conversation
func (c *DefaultApiService) ListConversationMessage(ConversationSid string, params *ListConversationMessageParams) (*ListConversationMessageResponse, error) {
	path := "/v1/Conversations/{ConversationSid}/Messages"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListConversationMessageResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListConversationMessageReceipt'
type ListConversationMessageReceiptParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListConversationMessageReceiptParams) SetPageSize(PageSize int) *ListConversationMessageReceiptParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all delivery and read receipts of the conversation message
func (c *DefaultApiService) ListConversationMessageReceipt(ConversationSid string, MessageSid string, params *ListConversationMessageReceiptParams) (*ListConversationMessageReceiptResponse, error) {
	path := "/v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"MessageSid"+"}", MessageSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListConversationMessageReceiptResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListConversationParticipant'
type ListConversationParticipantParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListConversationParticipantParams) SetPageSize(PageSize int) *ListConversationParticipantParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all participants of the conversation
func (c *DefaultApiService) ListConversationParticipant(ConversationSid string, params *ListConversationParticipantParams) (*ListConversationParticipantResponse, error) {
	path := "/v1/Conversations/{ConversationSid}/Participants"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListConversationParticipantResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListConversationScopedWebhook'
type ListConversationScopedWebhookParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListConversationScopedWebhookParams) SetPageSize(PageSize int) *ListConversationScopedWebhookParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all webhooks scoped to the conversation
func (c *DefaultApiService) ListConversationScopedWebhook(ConversationSid string, params *ListConversationScopedWebhookParams) (*ListConversationScopedWebhookResponse, error) {
	path := "/v1/Conversations/{ConversationSid}/Webhooks"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListConversationScopedWebhookResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListCredential'
type ListCredentialParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListCredentialParams) SetPageSize(PageSize int) *ListCredentialParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all push notification credentials on your account
func (c *DefaultApiService) ListCredential(params *ListCredentialParams) (*ListCredentialResponse, error) {
	path := "/v1/Credentials"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListCredentialResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRole'
type ListRoleParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListRoleParams) SetPageSize(PageSize int) *ListRoleParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all user roles in your account&#39;s default service
func (c *DefaultApiService) ListRole(params *ListRoleParams) (*ListRoleResponse, error) {
	path := "/v1/Roles"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoleResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListService'
type ListServiceParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceParams) SetPageSize(PageSize int) *ListServiceParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all conversation services on your account
func (c *DefaultApiService) ListService(params *ListServiceParams) (*ListServiceResponse, error) {
	path := "/v1/Services"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceBinding'
type ListServiceBindingParams struct {
	// The push technology used by the Binding resources to read.  Can be: `apn`, `gcm`, or `fcm`.  See [push notification configuration](https://www.twilio.com/docs/chat/push-notification-configuration) for more info.
	BindingType *[]string `json:"BindingType,omitempty"`
	// The identity of a [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource) this binding belongs to. See [access tokens](https://www.twilio.com/docs/conversations/create-tokens) for more details.
	Identity *[]string `json:"Identity,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceBindingParams) SetBindingType(BindingType []string) *ListServiceBindingParams {
	params.BindingType = &BindingType
	return params
}
func (params *ListServiceBindingParams) SetIdentity(Identity []string) *ListServiceBindingParams {
	params.Identity = &Identity
	return params
}
func (params *ListServiceBindingParams) SetPageSize(PageSize int) *ListServiceBindingParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all push notification bindings in the conversation service
func (c *DefaultApiService) ListServiceBinding(ChatServiceSid string, params *ListServiceBindingParams) (*ListServiceBindingResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Bindings"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.BindingType != nil {
		for _, item := range *params.BindingType {
			data.Add("BindingType", item)
		}
	}
	if params != nil && params.Identity != nil {
		for _, item := range *params.Identity {
			data.Add("Identity", item)
		}
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceBindingResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceConversation'
type ListServiceConversationParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceConversationParams) SetPageSize(PageSize int) *ListServiceConversationParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of conversations in your service
func (c *DefaultApiService) ListServiceConversation(ChatServiceSid string, params *ListServiceConversationParams) (*ListServiceConversationResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceConversationResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceConversationMessage'
type ListServiceConversationMessageParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceConversationMessageParams) SetPageSize(PageSize int) *ListServiceConversationMessageParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all messages in the conversation
func (c *DefaultApiService) ListServiceConversationMessage(ChatServiceSid string, ConversationSid string, params *ListServiceConversationMessageParams) (*ListServiceConversationMessageResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceConversationMessageResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceConversationMessageReceipt'
type ListServiceConversationMessageReceiptParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceConversationMessageReceiptParams) SetPageSize(PageSize int) *ListServiceConversationMessageReceiptParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all delivery and read receipts of the conversation message
func (c *DefaultApiService) ListServiceConversationMessageReceipt(ChatServiceSid string, ConversationSid string, MessageSid string, params *ListServiceConversationMessageReceiptParams) (*ListServiceConversationMessageReceiptResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"MessageSid"+"}", MessageSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceConversationMessageReceiptResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceConversationParticipant'
type ListServiceConversationParticipantParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceConversationParticipantParams) SetPageSize(PageSize int) *ListServiceConversationParticipantParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all participants of the conversation
func (c *DefaultApiService) ListServiceConversationParticipant(ChatServiceSid string, ConversationSid string, params *ListServiceConversationParticipantParams) (*ListServiceConversationParticipantResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceConversationParticipantResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceConversationScopedWebhook'
type ListServiceConversationScopedWebhookParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceConversationScopedWebhookParams) SetPageSize(PageSize int) *ListServiceConversationScopedWebhookParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all webhooks scoped to the conversation
func (c *DefaultApiService) ListServiceConversationScopedWebhook(ChatServiceSid string, ConversationSid string, params *ListServiceConversationScopedWebhookParams) (*ListServiceConversationScopedWebhookResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceConversationScopedWebhookResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceRole'
type ListServiceRoleParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceRoleParams) SetPageSize(PageSize int) *ListServiceRoleParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all user roles in your service
func (c *DefaultApiService) ListServiceRole(ChatServiceSid string, params *ListServiceRoleParams) (*ListServiceRoleResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Roles"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceRoleResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListServiceUser'
type ListServiceUserParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListServiceUserParams) SetPageSize(PageSize int) *ListServiceUserParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all conversation users in your service
func (c *DefaultApiService) ListServiceUser(ChatServiceSid string, params *ListServiceUserParams) (*ListServiceUserResponse, error) {
	path := "/v1/Services/{ChatServiceSid}/Users"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceUserResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListUser'
type ListUserParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int `json:"PageSize,omitempty"`
}

func (params *ListUserParams) SetPageSize(PageSize int) *ListUserParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all conversation users in your account&#39;s default service
func (c *DefaultApiService) ListUser(params *ListUserParams) (*ListUserResponse, error) {
	path := "/v1/Users"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListUserResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateConfiguration'
type UpdateConfigurationParams struct {
	// The SID of the default [Conversation Service](https://www.twilio.com/docs/conversations/api/service-resource) to use when creating a conversation.
	DefaultChatServiceSid *string `json:"DefaultChatServiceSid,omitempty"`
	// Default ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
	DefaultClosedTimer *string `json:"DefaultClosedTimer,omitempty"`
	// Default ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
	DefaultInactiveTimer *string `json:"DefaultInactiveTimer,omitempty"`
	// The SID of the default [Messaging Service](https://www.twilio.com/docs/sms/services/api) to use when creating a conversation.
	DefaultMessagingServiceSid *string `json:"DefaultMessagingServiceSid,omitempty"`
}

func (params *UpdateConfigurationParams) SetDefaultChatServiceSid(DefaultChatServiceSid string) *UpdateConfigurationParams {
	params.DefaultChatServiceSid = &DefaultChatServiceSid
	return params
}
func (params *UpdateConfigurationParams) SetDefaultClosedTimer(DefaultClosedTimer string) *UpdateConfigurationParams {
	params.DefaultClosedTimer = &DefaultClosedTimer
	return params
}
func (params *UpdateConfigurationParams) SetDefaultInactiveTimer(DefaultInactiveTimer string) *UpdateConfigurationParams {
	params.DefaultInactiveTimer = &DefaultInactiveTimer
	return params
}
func (params *UpdateConfigurationParams) SetDefaultMessagingServiceSid(DefaultMessagingServiceSid string) *UpdateConfigurationParams {
	params.DefaultMessagingServiceSid = &DefaultMessagingServiceSid
	return params
}

// Update the global configuration of conversations on your account
func (c *DefaultApiService) UpdateConfiguration(params *UpdateConfigurationParams) (*ConversationsV1Configuration, error) {
	path := "/v1/Configuration"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.DefaultChatServiceSid != nil {
		data.Set("DefaultChatServiceSid", *params.DefaultChatServiceSid)
	}
	if params != nil && params.DefaultClosedTimer != nil {
		data.Set("DefaultClosedTimer", *params.DefaultClosedTimer)
	}
	if params != nil && params.DefaultInactiveTimer != nil {
		data.Set("DefaultInactiveTimer", *params.DefaultInactiveTimer)
	}
	if params != nil && params.DefaultMessagingServiceSid != nil {
		data.Set("DefaultMessagingServiceSid", *params.DefaultMessagingServiceSid)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Configuration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateConfigurationWebhook'
type UpdateConfigurationWebhookParams struct {
	// The list of webhook event triggers that are enabled for this Service: `onMessageAdded`, `onMessageUpdated`, `onMessageRemoved`, `onConversationUpdated`, `onConversationRemoved`, `onParticipantAdded`, `onParticipantUpdated`, `onParticipantRemoved`
	Filters *[]string `json:"Filters,omitempty"`
	// The HTTP method to be used when sending a webhook request.
	Method *string `json:"Method,omitempty"`
	// The absolute url the post-event webhook request should be sent to.
	PostWebhookUrl *string `json:"PostWebhookUrl,omitempty"`
	// The absolute url the pre-event webhook request should be sent to.
	PreWebhookUrl *string `json:"PreWebhookUrl,omitempty"`
	// The routing target of the webhook.
	Target *string `json:"Target,omitempty"`
}

func (params *UpdateConfigurationWebhookParams) SetFilters(Filters []string) *UpdateConfigurationWebhookParams {
	params.Filters = &Filters
	return params
}
func (params *UpdateConfigurationWebhookParams) SetMethod(Method string) *UpdateConfigurationWebhookParams {
	params.Method = &Method
	return params
}
func (params *UpdateConfigurationWebhookParams) SetPostWebhookUrl(PostWebhookUrl string) *UpdateConfigurationWebhookParams {
	params.PostWebhookUrl = &PostWebhookUrl
	return params
}
func (params *UpdateConfigurationWebhookParams) SetPreWebhookUrl(PreWebhookUrl string) *UpdateConfigurationWebhookParams {
	params.PreWebhookUrl = &PreWebhookUrl
	return params
}
func (params *UpdateConfigurationWebhookParams) SetTarget(Target string) *UpdateConfigurationWebhookParams {
	params.Target = &Target
	return params
}

func (c *DefaultApiService) UpdateConfigurationWebhook(params *UpdateConfigurationWebhookParams) (*ConversationsV1ConfigurationConfigurationWebhook, error) {
	path := "/v1/Configuration/Webhooks"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Filters != nil {
		for _, item := range *params.Filters {
			data.Add("Filters", item)
		}
	}
	if params != nil && params.Method != nil {
		data.Set("Method", *params.Method)
	}
	if params != nil && params.PostWebhookUrl != nil {
		data.Set("PostWebhookUrl", *params.PostWebhookUrl)
	}
	if params != nil && params.PreWebhookUrl != nil {
		data.Set("PreWebhookUrl", *params.PreWebhookUrl)
	}
	if params != nil && params.Target != nil {
		data.Set("Target", *params.Target)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConfigurationConfigurationWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateConversation'
type UpdateConversationParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// The human-readable name of this conversation, limited to 256 characters. Optional.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
	MessagingServiceSid *string `json:"MessagingServiceSid,omitempty"`
	// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
	State *string `json:"State,omitempty"`
	// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
	TimersClosed *string `json:"Timers.Closed,omitempty"`
	// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
	TimersInactive *string `json:"Timers.Inactive,omitempty"`
	// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
	UniqueName *string `json:"UniqueName,omitempty"`
}

func (params *UpdateConversationParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateConversationParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateConversationParams) SetAttributes(Attributes string) *UpdateConversationParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateConversationParams) SetDateCreated(DateCreated time.Time) *UpdateConversationParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *UpdateConversationParams) SetDateUpdated(DateUpdated time.Time) *UpdateConversationParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *UpdateConversationParams) SetFriendlyName(FriendlyName string) *UpdateConversationParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateConversationParams) SetMessagingServiceSid(MessagingServiceSid string) *UpdateConversationParams {
	params.MessagingServiceSid = &MessagingServiceSid
	return params
}
func (params *UpdateConversationParams) SetState(State string) *UpdateConversationParams {
	params.State = &State
	return params
}
func (params *UpdateConversationParams) SetTimersClosed(TimersClosed string) *UpdateConversationParams {
	params.TimersClosed = &TimersClosed
	return params
}
func (params *UpdateConversationParams) SetTimersInactive(TimersInactive string) *UpdateConversationParams {
	params.TimersInactive = &TimersInactive
	return params
}
func (params *UpdateConversationParams) SetUniqueName(UniqueName string) *UpdateConversationParams {
	params.UniqueName = &UniqueName
	return params
}

// Update an existing conversation in your account&#39;s default service
func (c *DefaultApiService) UpdateConversation(Sid string, params *UpdateConversationParams) (*ConversationsV1Conversation, error) {
	path := "/v1/Conversations/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MessagingServiceSid != nil {
		data.Set("MessagingServiceSid", *params.MessagingServiceSid)
	}
	if params != nil && params.State != nil {
		data.Set("State", *params.State)
	}
	if params != nil && params.TimersClosed != nil {
		data.Set("Timers.Closed", *params.TimersClosed)
	}
	if params != nil && params.TimersInactive != nil {
		data.Set("Timers.Inactive", *params.TimersInactive)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Conversation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateConversationMessage'
type UpdateConversationMessageParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The channel specific identifier of the message's author. Defaults to `system`.
	Author *string `json:"Author,omitempty"`
	// The content of the message, can be up to 1,600 characters long.
	Body *string `json:"Body,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated. `null` if the message has not been edited.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
}

func (params *UpdateConversationMessageParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateConversationMessageParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateConversationMessageParams) SetAttributes(Attributes string) *UpdateConversationMessageParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateConversationMessageParams) SetAuthor(Author string) *UpdateConversationMessageParams {
	params.Author = &Author
	return params
}
func (params *UpdateConversationMessageParams) SetBody(Body string) *UpdateConversationMessageParams {
	params.Body = &Body
	return params
}
func (params *UpdateConversationMessageParams) SetDateCreated(DateCreated time.Time) *UpdateConversationMessageParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *UpdateConversationMessageParams) SetDateUpdated(DateUpdated time.Time) *UpdateConversationMessageParams {
	params.DateUpdated = &DateUpdated
	return params
}

// Update an existing message in the conversation
func (c *DefaultApiService) UpdateConversationMessage(ConversationSid string, Sid string, params *UpdateConversationMessageParams) (*ConversationsV1ConversationConversationMessage, error) {
	path := "/v1/Conversations/{ConversationSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Author != nil {
		data.Set("Author", *params.Author)
	}
	if params != nil && params.Body != nil {
		data.Set("Body", *params.Body)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateConversationParticipant'
type UpdateConversationParticipantParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversations SDK to communicate. Limited to 256 characters.
	Identity *string `json:"Identity,omitempty"`
	// Index of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
	LastReadMessageIndex *int `json:"LastReadMessageIndex,omitempty"`
	// Timestamp of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
	LastReadTimestamp *string `json:"LastReadTimestamp,omitempty"`
	// The address of the Twilio phone number that is used in Group MMS. 'null' value will remove it.
	MessagingBindingProjectedAddress *string `json:"MessagingBinding.ProjectedAddress,omitempty"`
	// The address of the Twilio phone number that the participant is in contact with. 'null' value will remove it.
	MessagingBindingProxyAddress *string `json:"MessagingBinding.ProxyAddress,omitempty"`
	// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *UpdateConversationParticipantParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateConversationParticipantParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateConversationParticipantParams) SetAttributes(Attributes string) *UpdateConversationParticipantParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateConversationParticipantParams) SetDateCreated(DateCreated time.Time) *UpdateConversationParticipantParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *UpdateConversationParticipantParams) SetDateUpdated(DateUpdated time.Time) *UpdateConversationParticipantParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *UpdateConversationParticipantParams) SetIdentity(Identity string) *UpdateConversationParticipantParams {
	params.Identity = &Identity
	return params
}
func (params *UpdateConversationParticipantParams) SetLastReadMessageIndex(LastReadMessageIndex int) *UpdateConversationParticipantParams {
	params.LastReadMessageIndex = &LastReadMessageIndex
	return params
}
func (params *UpdateConversationParticipantParams) SetLastReadTimestamp(LastReadTimestamp string) *UpdateConversationParticipantParams {
	params.LastReadTimestamp = &LastReadTimestamp
	return params
}
func (params *UpdateConversationParticipantParams) SetMessagingBindingProjectedAddress(MessagingBindingProjectedAddress string) *UpdateConversationParticipantParams {
	params.MessagingBindingProjectedAddress = &MessagingBindingProjectedAddress
	return params
}
func (params *UpdateConversationParticipantParams) SetMessagingBindingProxyAddress(MessagingBindingProxyAddress string) *UpdateConversationParticipantParams {
	params.MessagingBindingProxyAddress = &MessagingBindingProxyAddress
	return params
}
func (params *UpdateConversationParticipantParams) SetRoleSid(RoleSid string) *UpdateConversationParticipantParams {
	params.RoleSid = &RoleSid
	return params
}

// Update an existing participant in the conversation
func (c *DefaultApiService) UpdateConversationParticipant(ConversationSid string, Sid string, params *UpdateConversationParticipantParams) (*ConversationsV1ConversationConversationParticipant, error) {
	path := "/v1/Conversations/{ConversationSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.LastReadMessageIndex != nil {
		data.Set("LastReadMessageIndex", fmt.Sprint(*params.LastReadMessageIndex))
	}
	if params != nil && params.LastReadTimestamp != nil {
		data.Set("LastReadTimestamp", *params.LastReadTimestamp)
	}
	if params != nil && params.MessagingBindingProjectedAddress != nil {
		data.Set("MessagingBinding.ProjectedAddress", *params.MessagingBindingProjectedAddress)
	}
	if params != nil && params.MessagingBindingProxyAddress != nil {
		data.Set("MessagingBinding.ProxyAddress", *params.MessagingBindingProxyAddress)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateConversationScopedWebhook'
type UpdateConversationScopedWebhookParams struct {
	// The list of events, firing webhook event for this Conversation.
	ConfigurationFilters *[]string `json:"Configuration.Filters,omitempty"`
	// The studio flow SID, where the webhook should be sent to.
	ConfigurationFlowSid *string `json:"Configuration.FlowSid,omitempty"`
	// The HTTP method to be used when sending a webhook request.
	ConfigurationMethod *string `json:"Configuration.Method,omitempty"`
	// The list of keywords, firing webhook event for this Conversation.
	ConfigurationTriggers *[]string `json:"Configuration.Triggers,omitempty"`
	// The absolute url the webhook request should be sent to.
	ConfigurationUrl *string `json:"Configuration.Url,omitempty"`
}

func (params *UpdateConversationScopedWebhookParams) SetConfigurationFilters(ConfigurationFilters []string) *UpdateConversationScopedWebhookParams {
	params.ConfigurationFilters = &ConfigurationFilters
	return params
}
func (params *UpdateConversationScopedWebhookParams) SetConfigurationFlowSid(ConfigurationFlowSid string) *UpdateConversationScopedWebhookParams {
	params.ConfigurationFlowSid = &ConfigurationFlowSid
	return params
}
func (params *UpdateConversationScopedWebhookParams) SetConfigurationMethod(ConfigurationMethod string) *UpdateConversationScopedWebhookParams {
	params.ConfigurationMethod = &ConfigurationMethod
	return params
}
func (params *UpdateConversationScopedWebhookParams) SetConfigurationTriggers(ConfigurationTriggers []string) *UpdateConversationScopedWebhookParams {
	params.ConfigurationTriggers = &ConfigurationTriggers
	return params
}
func (params *UpdateConversationScopedWebhookParams) SetConfigurationUrl(ConfigurationUrl string) *UpdateConversationScopedWebhookParams {
	params.ConfigurationUrl = &ConfigurationUrl
	return params
}

// Update an existing conversation-scoped webhook
func (c *DefaultApiService) UpdateConversationScopedWebhook(ConversationSid string, Sid string, params *UpdateConversationScopedWebhookParams) (*ConversationsV1ConversationConversationScopedWebhook, error) {
	path := "/v1/Conversations/{ConversationSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ConfigurationFilters != nil {
		for _, item := range *params.ConfigurationFilters {
			data.Add("Configuration.Filters", item)
		}
	}
	if params != nil && params.ConfigurationFlowSid != nil {
		data.Set("Configuration.FlowSid", *params.ConfigurationFlowSid)
	}
	if params != nil && params.ConfigurationMethod != nil {
		data.Set("Configuration.Method", *params.ConfigurationMethod)
	}
	if params != nil && params.ConfigurationTriggers != nil {
		for _, item := range *params.ConfigurationTriggers {
			data.Add("Configuration.Triggers", item)
		}
	}
	if params != nil && params.ConfigurationUrl != nil {
		data.Set("Configuration.Url", *params.ConfigurationUrl)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ConversationConversationScopedWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateCredential'
type UpdateCredentialParams struct {
	// [GCM only] The API key for the project that was obtained from the Google Developer console for your GCM Service application credential.
	ApiKey *string `json:"ApiKey,omitempty"`
	// [APN only] The URL encoded representation of the certificate. For example,  `-----BEGIN CERTIFICATE----- MIIFnTCCBIWgAwIBAgIIAjy9H849+E8wDQYJKoZIhvcNAQEF.....A== -----END CERTIFICATE-----`.
	Certificate *string `json:"Certificate,omitempty"`
	// A descriptive string that you create to describe the new resource. It can be up to 64 characters long.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// [APN only] The URL encoded representation of the private key. For example, `-----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAuyf/lNrH9ck8DmNyo3fG... -----END RSA PRIVATE KEY-----`.
	PrivateKey *string `json:"PrivateKey,omitempty"`
	// [APN only] Whether to send the credential to sandbox APNs. Can be `true` to send to sandbox APNs or `false` to send to production.
	Sandbox *bool `json:"Sandbox,omitempty"`
	// [FCM only] The **Server key** of your project from the Firebase console, found under Settings / Cloud messaging.
	Secret *string `json:"Secret,omitempty"`
	// The type of push-notification service the credential is for. Can be: `fcm`, `gcm`, or `apn`.
	Type *string `json:"Type,omitempty"`
}

func (params *UpdateCredentialParams) SetApiKey(ApiKey string) *UpdateCredentialParams {
	params.ApiKey = &ApiKey
	return params
}
func (params *UpdateCredentialParams) SetCertificate(Certificate string) *UpdateCredentialParams {
	params.Certificate = &Certificate
	return params
}
func (params *UpdateCredentialParams) SetFriendlyName(FriendlyName string) *UpdateCredentialParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateCredentialParams) SetPrivateKey(PrivateKey string) *UpdateCredentialParams {
	params.PrivateKey = &PrivateKey
	return params
}
func (params *UpdateCredentialParams) SetSandbox(Sandbox bool) *UpdateCredentialParams {
	params.Sandbox = &Sandbox
	return params
}
func (params *UpdateCredentialParams) SetSecret(Secret string) *UpdateCredentialParams {
	params.Secret = &Secret
	return params
}
func (params *UpdateCredentialParams) SetType(Type string) *UpdateCredentialParams {
	params.Type = &Type
	return params
}

// Update an existing push notification credential on your account
func (c *DefaultApiService) UpdateCredential(Sid string, params *UpdateCredentialParams) (*ConversationsV1Credential, error) {
	path := "/v1/Credentials/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ApiKey != nil {
		data.Set("ApiKey", *params.ApiKey)
	}
	if params != nil && params.Certificate != nil {
		data.Set("Certificate", *params.Certificate)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PrivateKey != nil {
		data.Set("PrivateKey", *params.PrivateKey)
	}
	if params != nil && params.Sandbox != nil {
		data.Set("Sandbox", fmt.Sprint(*params.Sandbox))
	}
	if params != nil && params.Secret != nil {
		data.Set("Secret", *params.Secret)
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Credential{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateRole'
type UpdateRoleParams struct {
	// A permission that you grant to the role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. Note that the update action replaces all previously assigned permissions with those defined in the update action. To remove a permission, do not include it in the subsequent update action. The values for this parameter depend on the role's `type`.
	Permission *[]string `json:"Permission,omitempty"`
}

func (params *UpdateRoleParams) SetPermission(Permission []string) *UpdateRoleParams {
	params.Permission = &Permission
	return params
}

// Update an existing user role in your account&#39;s default service
func (c *DefaultApiService) UpdateRole(Sid string, params *UpdateRoleParams) (*ConversationsV1Role, error) {
	path := "/v1/Roles/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Permission != nil {
		for _, item := range *params.Permission {
			data.Add("Permission", item)
		}
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1Role{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceConfiguration'
type UpdateServiceConfigurationParams struct {
	// The service-level role assigned to users when they are added to the service. See the [Conversation Role](https://www.twilio.com/docs/conversations/api/role-resource) for more info about roles.
	DefaultChatServiceRoleSid *string `json:"DefaultChatServiceRoleSid,omitempty"`
	// The conversation-level role assigned to a conversation creator when they join a new conversation. See the [Conversation Role](https://www.twilio.com/docs/conversations/api/role-resource) for more info about roles.
	DefaultConversationCreatorRoleSid *string `json:"DefaultConversationCreatorRoleSid,omitempty"`
	// The conversation-level role assigned to users when they are added to a conversation. See the [Conversation Role](https://www.twilio.com/docs/conversations/api/role-resource) for more info about roles.
	DefaultConversationRoleSid *string `json:"DefaultConversationRoleSid,omitempty"`
	// Whether the [Reachability Indicator](https://www.twilio.com/docs/chat/reachability-indicator) is enabled for this Conversations Service. The default is `false`.
	ReachabilityEnabled *bool `json:"ReachabilityEnabled,omitempty"`
}

func (params *UpdateServiceConfigurationParams) SetDefaultChatServiceRoleSid(DefaultChatServiceRoleSid string) *UpdateServiceConfigurationParams {
	params.DefaultChatServiceRoleSid = &DefaultChatServiceRoleSid
	return params
}
func (params *UpdateServiceConfigurationParams) SetDefaultConversationCreatorRoleSid(DefaultConversationCreatorRoleSid string) *UpdateServiceConfigurationParams {
	params.DefaultConversationCreatorRoleSid = &DefaultConversationCreatorRoleSid
	return params
}
func (params *UpdateServiceConfigurationParams) SetDefaultConversationRoleSid(DefaultConversationRoleSid string) *UpdateServiceConfigurationParams {
	params.DefaultConversationRoleSid = &DefaultConversationRoleSid
	return params
}
func (params *UpdateServiceConfigurationParams) SetReachabilityEnabled(ReachabilityEnabled bool) *UpdateServiceConfigurationParams {
	params.ReachabilityEnabled = &ReachabilityEnabled
	return params
}

// Update configuration settings of a conversation service
func (c *DefaultApiService) UpdateServiceConfiguration(ChatServiceSid string, params *UpdateServiceConfigurationParams) (*ConversationsV1ServiceServiceConfiguration, error) {
	path := "/v1/Services/{ChatServiceSid}/Configuration"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.DefaultChatServiceRoleSid != nil {
		data.Set("DefaultChatServiceRoleSid", *params.DefaultChatServiceRoleSid)
	}
	if params != nil && params.DefaultConversationCreatorRoleSid != nil {
		data.Set("DefaultConversationCreatorRoleSid", *params.DefaultConversationCreatorRoleSid)
	}
	if params != nil && params.DefaultConversationRoleSid != nil {
		data.Set("DefaultConversationRoleSid", *params.DefaultConversationRoleSid)
	}
	if params != nil && params.ReachabilityEnabled != nil {
		data.Set("ReachabilityEnabled", fmt.Sprint(*params.ReachabilityEnabled))
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConfiguration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceConversation'
type UpdateServiceConversationParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// The human-readable name of this conversation, limited to 256 characters. Optional.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The unique ID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) this conversation belongs to.
	MessagingServiceSid *string `json:"MessagingServiceSid,omitempty"`
	// Current state of this conversation. Can be either `active`, `inactive` or `closed` and defaults to `active`
	State *string `json:"State,omitempty"`
	// ISO8601 duration when conversation will be switched to `closed` state. Minimum value for this timer is 10 minutes.
	TimersClosed *string `json:"Timers.Closed,omitempty"`
	// ISO8601 duration when conversation will be switched to `inactive` state. Minimum value for this timer is 1 minute.
	TimersInactive *string `json:"Timers.Inactive,omitempty"`
	// An application-defined string that uniquely identifies the resource. It can be used to address the resource in place of the resource's `sid` in the URL.
	UniqueName *string `json:"UniqueName,omitempty"`
}

func (params *UpdateServiceConversationParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateServiceConversationParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateServiceConversationParams) SetAttributes(Attributes string) *UpdateServiceConversationParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateServiceConversationParams) SetDateCreated(DateCreated time.Time) *UpdateServiceConversationParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *UpdateServiceConversationParams) SetDateUpdated(DateUpdated time.Time) *UpdateServiceConversationParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *UpdateServiceConversationParams) SetFriendlyName(FriendlyName string) *UpdateServiceConversationParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateServiceConversationParams) SetMessagingServiceSid(MessagingServiceSid string) *UpdateServiceConversationParams {
	params.MessagingServiceSid = &MessagingServiceSid
	return params
}
func (params *UpdateServiceConversationParams) SetState(State string) *UpdateServiceConversationParams {
	params.State = &State
	return params
}
func (params *UpdateServiceConversationParams) SetTimersClosed(TimersClosed string) *UpdateServiceConversationParams {
	params.TimersClosed = &TimersClosed
	return params
}
func (params *UpdateServiceConversationParams) SetTimersInactive(TimersInactive string) *UpdateServiceConversationParams {
	params.TimersInactive = &TimersInactive
	return params
}
func (params *UpdateServiceConversationParams) SetUniqueName(UniqueName string) *UpdateServiceConversationParams {
	params.UniqueName = &UniqueName
	return params
}

// Update an existing conversation in your service
func (c *DefaultApiService) UpdateServiceConversation(ChatServiceSid string, Sid string, params *UpdateServiceConversationParams) (*ConversationsV1ServiceServiceConversation, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MessagingServiceSid != nil {
		data.Set("MessagingServiceSid", *params.MessagingServiceSid)
	}
	if params != nil && params.State != nil {
		data.Set("State", *params.State)
	}
	if params != nil && params.TimersClosed != nil {
		data.Set("Timers.Closed", *params.TimersClosed)
	}
	if params != nil && params.TimersInactive != nil {
		data.Set("Timers.Inactive", *params.TimersInactive)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceConversationMessage'
type UpdateServiceConversationMessageParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// A string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The channel specific identifier of the message's author. Defaults to `system`.
	Author *string `json:"Author,omitempty"`
	// The content of the message, can be up to 1,600 characters long.
	Body *string `json:"Body,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated. `null` if the message has not been edited.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
}

func (params *UpdateServiceConversationMessageParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateServiceConversationMessageParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateServiceConversationMessageParams) SetAttributes(Attributes string) *UpdateServiceConversationMessageParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateServiceConversationMessageParams) SetAuthor(Author string) *UpdateServiceConversationMessageParams {
	params.Author = &Author
	return params
}
func (params *UpdateServiceConversationMessageParams) SetBody(Body string) *UpdateServiceConversationMessageParams {
	params.Body = &Body
	return params
}
func (params *UpdateServiceConversationMessageParams) SetDateCreated(DateCreated time.Time) *UpdateServiceConversationMessageParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *UpdateServiceConversationMessageParams) SetDateUpdated(DateUpdated time.Time) *UpdateServiceConversationMessageParams {
	params.DateUpdated = &DateUpdated
	return params
}

// Update an existing message in the conversation
func (c *DefaultApiService) UpdateServiceConversationMessage(ChatServiceSid string, ConversationSid string, Sid string, params *UpdateServiceConversationMessageParams) (*ConversationsV1ServiceServiceConversationServiceConversationMessage, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Author != nil {
		data.Set("Author", *params.Author)
	}
	if params != nil && params.Body != nil {
		data.Set("Body", *params.Body)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceConversationParticipant'
type UpdateServiceConversationParticipantParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// An optional string metadata field you can use to store any data you wish. The string value must contain structurally valid JSON if specified.  **Note** that if the attributes are not set \\\"{}\\\" will be returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The date that this resource was created.
	DateCreated *time.Time `json:"DateCreated,omitempty"`
	// The date that this resource was last updated.
	DateUpdated *time.Time `json:"DateUpdated,omitempty"`
	// A unique string identifier for the conversation participant as [Conversation User](https://www.twilio.com/docs/conversations/api/user-resource). This parameter is non-null if (and only if) the participant is using the Conversation SDK to communicate. Limited to 256 characters.
	Identity *string `json:"Identity,omitempty"`
	// Index of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
	LastReadMessageIndex *int `json:"LastReadMessageIndex,omitempty"`
	// Timestamp of last “read” message in the [Conversation](https://www.twilio.com/docs/conversations/api/conversation-resource) for the Participant.
	LastReadTimestamp *string `json:"LastReadTimestamp,omitempty"`
	// The address of the Twilio phone number that is used in Group MMS. 'null' value will remove it.
	MessagingBindingProjectedAddress *string `json:"MessagingBinding.ProjectedAddress,omitempty"`
	// The address of the Twilio phone number that the participant is in contact with. 'null' value will remove it.
	MessagingBindingProxyAddress *string `json:"MessagingBinding.ProxyAddress,omitempty"`
	// The SID of a conversation-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the participant.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *UpdateServiceConversationParticipantParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateServiceConversationParticipantParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetAttributes(Attributes string) *UpdateServiceConversationParticipantParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetDateCreated(DateCreated time.Time) *UpdateServiceConversationParticipantParams {
	params.DateCreated = &DateCreated
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetDateUpdated(DateUpdated time.Time) *UpdateServiceConversationParticipantParams {
	params.DateUpdated = &DateUpdated
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetIdentity(Identity string) *UpdateServiceConversationParticipantParams {
	params.Identity = &Identity
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetLastReadMessageIndex(LastReadMessageIndex int) *UpdateServiceConversationParticipantParams {
	params.LastReadMessageIndex = &LastReadMessageIndex
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetLastReadTimestamp(LastReadTimestamp string) *UpdateServiceConversationParticipantParams {
	params.LastReadTimestamp = &LastReadTimestamp
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetMessagingBindingProjectedAddress(MessagingBindingProjectedAddress string) *UpdateServiceConversationParticipantParams {
	params.MessagingBindingProjectedAddress = &MessagingBindingProjectedAddress
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetMessagingBindingProxyAddress(MessagingBindingProxyAddress string) *UpdateServiceConversationParticipantParams {
	params.MessagingBindingProxyAddress = &MessagingBindingProxyAddress
	return params
}
func (params *UpdateServiceConversationParticipantParams) SetRoleSid(RoleSid string) *UpdateServiceConversationParticipantParams {
	params.RoleSid = &RoleSid
	return params
}

// Update an existing participant in the conversation
func (c *DefaultApiService) UpdateServiceConversationParticipant(ChatServiceSid string, ConversationSid string, Sid string, params *UpdateServiceConversationParticipantParams) (*ConversationsV1ServiceServiceConversationServiceConversationParticipant, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint((*params.DateCreated).Format(time.RFC3339)))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint((*params.DateUpdated).Format(time.RFC3339)))
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.LastReadMessageIndex != nil {
		data.Set("LastReadMessageIndex", fmt.Sprint(*params.LastReadMessageIndex))
	}
	if params != nil && params.LastReadTimestamp != nil {
		data.Set("LastReadTimestamp", *params.LastReadTimestamp)
	}
	if params != nil && params.MessagingBindingProjectedAddress != nil {
		data.Set("MessagingBinding.ProjectedAddress", *params.MessagingBindingProjectedAddress)
	}
	if params != nil && params.MessagingBindingProxyAddress != nil {
		data.Set("MessagingBinding.ProxyAddress", *params.MessagingBindingProxyAddress)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceConversationScopedWebhook'
type UpdateServiceConversationScopedWebhookParams struct {
	// The list of events, firing webhook event for this Conversation.
	ConfigurationFilters *[]string `json:"Configuration.Filters,omitempty"`
	// The studio flow SID, where the webhook should be sent to.
	ConfigurationFlowSid *string `json:"Configuration.FlowSid,omitempty"`
	// The HTTP method to be used when sending a webhook request.
	ConfigurationMethod *string `json:"Configuration.Method,omitempty"`
	// The list of keywords, firing webhook event for this Conversation.
	ConfigurationTriggers *[]string `json:"Configuration.Triggers,omitempty"`
	// The absolute url the webhook request should be sent to.
	ConfigurationUrl *string `json:"Configuration.Url,omitempty"`
}

func (params *UpdateServiceConversationScopedWebhookParams) SetConfigurationFilters(ConfigurationFilters []string) *UpdateServiceConversationScopedWebhookParams {
	params.ConfigurationFilters = &ConfigurationFilters
	return params
}
func (params *UpdateServiceConversationScopedWebhookParams) SetConfigurationFlowSid(ConfigurationFlowSid string) *UpdateServiceConversationScopedWebhookParams {
	params.ConfigurationFlowSid = &ConfigurationFlowSid
	return params
}
func (params *UpdateServiceConversationScopedWebhookParams) SetConfigurationMethod(ConfigurationMethod string) *UpdateServiceConversationScopedWebhookParams {
	params.ConfigurationMethod = &ConfigurationMethod
	return params
}
func (params *UpdateServiceConversationScopedWebhookParams) SetConfigurationTriggers(ConfigurationTriggers []string) *UpdateServiceConversationScopedWebhookParams {
	params.ConfigurationTriggers = &ConfigurationTriggers
	return params
}
func (params *UpdateServiceConversationScopedWebhookParams) SetConfigurationUrl(ConfigurationUrl string) *UpdateServiceConversationScopedWebhookParams {
	params.ConfigurationUrl = &ConfigurationUrl
	return params
}

// Update an existing conversation-scoped webhook
func (c *DefaultApiService) UpdateServiceConversationScopedWebhook(ChatServiceSid string, ConversationSid string, Sid string, params *UpdateServiceConversationScopedWebhookParams) (*ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook, error) {
	path := "/v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"ConversationSid"+"}", ConversationSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ConfigurationFilters != nil {
		for _, item := range *params.ConfigurationFilters {
			data.Add("Configuration.Filters", item)
		}
	}
	if params != nil && params.ConfigurationFlowSid != nil {
		data.Set("Configuration.FlowSid", *params.ConfigurationFlowSid)
	}
	if params != nil && params.ConfigurationMethod != nil {
		data.Set("Configuration.Method", *params.ConfigurationMethod)
	}
	if params != nil && params.ConfigurationTriggers != nil {
		for _, item := range *params.ConfigurationTriggers {
			data.Add("Configuration.Triggers", item)
		}
	}
	if params != nil && params.ConfigurationUrl != nil {
		data.Set("Configuration.Url", *params.ConfigurationUrl)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceNotification'
type UpdateServiceNotificationParams struct {
	// Whether to send a notification when a participant is added to a conversation. The default is `false`.
	AddedToConversationEnabled *bool `json:"AddedToConversation.Enabled,omitempty"`
	// The name of the sound to play when a participant is added to a conversation and `added_to_conversation.enabled` is `true`.
	AddedToConversationSound *string `json:"AddedToConversation.Sound,omitempty"`
	// The template to use to create the notification text displayed when a participant is added to a conversation and `added_to_conversation.enabled` is `true`.
	AddedToConversationTemplate *string `json:"AddedToConversation.Template,omitempty"`
	// Weather the notification logging is enabled.
	LogEnabled *bool `json:"LogEnabled,omitempty"`
	// Whether the new message badge is enabled. The default is `false`.
	NewMessageBadgeCountEnabled *bool `json:"NewMessage.BadgeCountEnabled,omitempty"`
	// Whether to send a notification when a new message is added to a conversation. The default is `false`.
	NewMessageEnabled *bool `json:"NewMessage.Enabled,omitempty"`
	// The name of the sound to play when a new message is added to a conversation and `new_message.enabled` is `true`.
	NewMessageSound *string `json:"NewMessage.Sound,omitempty"`
	// The template to use to create the notification text displayed when a new message is added to a conversation and `new_message.enabled` is `true`.
	NewMessageTemplate *string `json:"NewMessage.Template,omitempty"`
	// Whether to send a notification to a user when they are removed from a conversation. The default is `false`.
	RemovedFromConversationEnabled *bool `json:"RemovedFromConversation.Enabled,omitempty"`
	// The name of the sound to play to a user when they are removed from a conversation and `removed_from_conversation.enabled` is `true`.
	RemovedFromConversationSound *string `json:"RemovedFromConversation.Sound,omitempty"`
	// The template to use to create the notification text displayed to a user when they are removed from a conversation and `removed_from_conversation.enabled` is `true`.
	RemovedFromConversationTemplate *string `json:"RemovedFromConversation.Template,omitempty"`
}

func (params *UpdateServiceNotificationParams) SetAddedToConversationEnabled(AddedToConversationEnabled bool) *UpdateServiceNotificationParams {
	params.AddedToConversationEnabled = &AddedToConversationEnabled
	return params
}
func (params *UpdateServiceNotificationParams) SetAddedToConversationSound(AddedToConversationSound string) *UpdateServiceNotificationParams {
	params.AddedToConversationSound = &AddedToConversationSound
	return params
}
func (params *UpdateServiceNotificationParams) SetAddedToConversationTemplate(AddedToConversationTemplate string) *UpdateServiceNotificationParams {
	params.AddedToConversationTemplate = &AddedToConversationTemplate
	return params
}
func (params *UpdateServiceNotificationParams) SetLogEnabled(LogEnabled bool) *UpdateServiceNotificationParams {
	params.LogEnabled = &LogEnabled
	return params
}
func (params *UpdateServiceNotificationParams) SetNewMessageBadgeCountEnabled(NewMessageBadgeCountEnabled bool) *UpdateServiceNotificationParams {
	params.NewMessageBadgeCountEnabled = &NewMessageBadgeCountEnabled
	return params
}
func (params *UpdateServiceNotificationParams) SetNewMessageEnabled(NewMessageEnabled bool) *UpdateServiceNotificationParams {
	params.NewMessageEnabled = &NewMessageEnabled
	return params
}
func (params *UpdateServiceNotificationParams) SetNewMessageSound(NewMessageSound string) *UpdateServiceNotificationParams {
	params.NewMessageSound = &NewMessageSound
	return params
}
func (params *UpdateServiceNotificationParams) SetNewMessageTemplate(NewMessageTemplate string) *UpdateServiceNotificationParams {
	params.NewMessageTemplate = &NewMessageTemplate
	return params
}
func (params *UpdateServiceNotificationParams) SetRemovedFromConversationEnabled(RemovedFromConversationEnabled bool) *UpdateServiceNotificationParams {
	params.RemovedFromConversationEnabled = &RemovedFromConversationEnabled
	return params
}
func (params *UpdateServiceNotificationParams) SetRemovedFromConversationSound(RemovedFromConversationSound string) *UpdateServiceNotificationParams {
	params.RemovedFromConversationSound = &RemovedFromConversationSound
	return params
}
func (params *UpdateServiceNotificationParams) SetRemovedFromConversationTemplate(RemovedFromConversationTemplate string) *UpdateServiceNotificationParams {
	params.RemovedFromConversationTemplate = &RemovedFromConversationTemplate
	return params
}

// Update push notification service settings
func (c *DefaultApiService) UpdateServiceNotification(ChatServiceSid string, params *UpdateServiceNotificationParams) (*ConversationsV1ServiceServiceConfigurationServiceNotification, error) {
	path := "/v1/Services/{ChatServiceSid}/Configuration/Notifications"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AddedToConversationEnabled != nil {
		data.Set("AddedToConversation.Enabled", fmt.Sprint(*params.AddedToConversationEnabled))
	}
	if params != nil && params.AddedToConversationSound != nil {
		data.Set("AddedToConversation.Sound", *params.AddedToConversationSound)
	}
	if params != nil && params.AddedToConversationTemplate != nil {
		data.Set("AddedToConversation.Template", *params.AddedToConversationTemplate)
	}
	if params != nil && params.LogEnabled != nil {
		data.Set("LogEnabled", fmt.Sprint(*params.LogEnabled))
	}
	if params != nil && params.NewMessageBadgeCountEnabled != nil {
		data.Set("NewMessage.BadgeCountEnabled", fmt.Sprint(*params.NewMessageBadgeCountEnabled))
	}
	if params != nil && params.NewMessageEnabled != nil {
		data.Set("NewMessage.Enabled", fmt.Sprint(*params.NewMessageEnabled))
	}
	if params != nil && params.NewMessageSound != nil {
		data.Set("NewMessage.Sound", *params.NewMessageSound)
	}
	if params != nil && params.NewMessageTemplate != nil {
		data.Set("NewMessage.Template", *params.NewMessageTemplate)
	}
	if params != nil && params.RemovedFromConversationEnabled != nil {
		data.Set("RemovedFromConversation.Enabled", fmt.Sprint(*params.RemovedFromConversationEnabled))
	}
	if params != nil && params.RemovedFromConversationSound != nil {
		data.Set("RemovedFromConversation.Sound", *params.RemovedFromConversationSound)
	}
	if params != nil && params.RemovedFromConversationTemplate != nil {
		data.Set("RemovedFromConversation.Template", *params.RemovedFromConversationTemplate)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceConfigurationServiceNotification{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceRole'
type UpdateServiceRoleParams struct {
	// A permission that you grant to the role. Only one permission can be granted per parameter. To assign more than one permission, repeat this parameter for each permission value. Note that the update action replaces all previously assigned permissions with those defined in the update action. To remove a permission, do not include it in the subsequent update action. The values for this parameter depend on the role's `type`.
	Permission *[]string `json:"Permission,omitempty"`
}

func (params *UpdateServiceRoleParams) SetPermission(Permission []string) *UpdateServiceRoleParams {
	params.Permission = &Permission
	return params
}

// Update an existing user role in your service
func (c *DefaultApiService) UpdateServiceRole(ChatServiceSid string, Sid string, params *UpdateServiceRoleParams) (*ConversationsV1ServiceServiceRole, error) {
	path := "/v1/Services/{ChatServiceSid}/Roles/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Permission != nil {
		for _, item := range *params.Permission {
			data.Add("Permission", item)
		}
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceRole{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateServiceUser'
type UpdateServiceUserParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The string that you assigned to describe the resource.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *UpdateServiceUserParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateServiceUserParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateServiceUserParams) SetAttributes(Attributes string) *UpdateServiceUserParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateServiceUserParams) SetFriendlyName(FriendlyName string) *UpdateServiceUserParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateServiceUserParams) SetRoleSid(RoleSid string) *UpdateServiceUserParams {
	params.RoleSid = &RoleSid
	return params
}

// Update an existing conversation user in your service
func (c *DefaultApiService) UpdateServiceUser(ChatServiceSid string, Sid string, params *UpdateServiceUserParams) (*ConversationsV1ServiceServiceUser, error) {
	path := "/v1/Services/{ChatServiceSid}/Users/{Sid}"
	path = strings.Replace(path, "{"+"ChatServiceSid"+"}", ChatServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1ServiceServiceUser{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateUser'
type UpdateUserParams struct {
	// The X-Twilio-Webhook-Enabled HTTP request header
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	// The JSON Object string that stores application-specific data. If attributes have not been set, `{}` is returned.
	Attributes *string `json:"Attributes,omitempty"`
	// The string that you assigned to describe the resource.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The SID of a service-level [Role](https://www.twilio.com/docs/conversations/api/role-resource) to assign to the user.
	RoleSid *string `json:"RoleSid,omitempty"`
}

func (params *UpdateUserParams) SetXTwilioWebhookEnabled(XTwilioWebhookEnabled string) *UpdateUserParams {
	params.XTwilioWebhookEnabled = &XTwilioWebhookEnabled
	return params
}
func (params *UpdateUserParams) SetAttributes(Attributes string) *UpdateUserParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateUserParams) SetFriendlyName(FriendlyName string) *UpdateUserParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateUserParams) SetRoleSid(RoleSid string) *UpdateUserParams {
	params.RoleSid = &RoleSid
	return params
}

// Update an existing conversation user in your account&#39;s default service
func (c *DefaultApiService) UpdateUser(Sid string, params *UpdateUserParams) (*ConversationsV1User, error) {
	path := "/v1/Users/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["X-Twilio-Webhook-Enabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ConversationsV1User{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}
