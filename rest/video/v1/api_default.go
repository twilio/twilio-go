/*
 * Twilio - Video
 *
 * This is the public Twilio REST API.
 *
 * API version: 1.0.0
 * Contact: support@twilio.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"time"

	twilio "github.com/twilio/twilio-go/client"
)

type DefaultApiService struct {
	baseURL string
	client  twilio.BaseClient
}

func NewDefaultApiService(client twilio.BaseClient) *DefaultApiService {
	return &DefaultApiService{
		client:  client,
		baseURL: "https://video.twilio.com",
	}
}

// Optional parameters for the method 'CreateComposition'
type CreateCompositionParams struct {
	// An array of track names from the same group room to merge into the new composition. Can include zero or more track names. The new composition includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which will match zero or more characters in a track name. For example, `student*` includes `student` as well as `studentTeam`. Please, be aware that either video_layout or audio_sources have to be provided to get a valid creation request
	AudioSources *[]string `json:"AudioSources,omitempty"`
	// An array of track names to exclude. The new composition includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which will match zero or more characters in a track name. For example, `student*` excludes `student` as well as `studentTeam`. This parameter can also be empty.
	AudioSourcesExcluded *[]string `json:"AudioSourcesExcluded,omitempty"`
	// The container format of the composition's media files. Can be: `mp4` or `webm` and the default is `webm`. If you specify `mp4` or `webm`, you must also specify one or more `audio_sources` and/or a `video_layout` element that contains a valid `video_sources` list, otherwise an error occurs.
	Format *string `json:"Format,omitempty"`
	// A string that describes the columns (width) and rows (height) of the generated composed video in pixels. Defaults to `640x480`.  The string's format is `{width}x{height}` where:   * 16 <= `{width}` <= 1280 * 16 <= `{height}` <= 1280 * `{width}` * `{height}` <= 921,600  Typical values are:   * HD = `1280x720` * PAL = `1024x576` * VGA = `640x480` * CIF = `320x240`  Note that the `resolution` imposes an aspect ratio to the resulting composition. When the original video tracks are constrained by the aspect ratio, they are scaled to fit. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	Resolution *string `json:"Resolution,omitempty"`
	// The SID of the Group Room with the media tracks to be used as composition sources.
	RoomSid *string `json:"RoomSid,omitempty"`
	// The URL we should call using the `status_callback_method` to send status information to your application on every composition event. If not provided, status callback events will not be dispatched.
	StatusCallback *string `json:"StatusCallback,omitempty"`
	// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
	StatusCallbackMethod *string `json:"StatusCallbackMethod,omitempty"`
	// Whether to clip the intervals where there is no active media in the composition. The default is `true`. Compositions with `trim` enabled are shorter when the Room is created and no Participant joins for a while as well as if all the Participants leave the room and join later, because those gaps will be removed. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	Trim *bool `json:"Trim,omitempty"`
	// An object that describes the video layout of the composition in terms of regions. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info. Please, be aware that either video_layout or audio_sources have to be provided to get a valid creation request
	VideoLayout *map[string]interface{} `json:"VideoLayout,omitempty"`
}

func (params *CreateCompositionParams) SetAudioSources(AudioSources []string) *CreateCompositionParams {
	params.AudioSources = &AudioSources
	return params
}
func (params *CreateCompositionParams) SetAudioSourcesExcluded(AudioSourcesExcluded []string) *CreateCompositionParams {
	params.AudioSourcesExcluded = &AudioSourcesExcluded
	return params
}
func (params *CreateCompositionParams) SetFormat(Format string) *CreateCompositionParams {
	params.Format = &Format
	return params
}
func (params *CreateCompositionParams) SetResolution(Resolution string) *CreateCompositionParams {
	params.Resolution = &Resolution
	return params
}
func (params *CreateCompositionParams) SetRoomSid(RoomSid string) *CreateCompositionParams {
	params.RoomSid = &RoomSid
	return params
}
func (params *CreateCompositionParams) SetStatusCallback(StatusCallback string) *CreateCompositionParams {
	params.StatusCallback = &StatusCallback
	return params
}
func (params *CreateCompositionParams) SetStatusCallbackMethod(StatusCallbackMethod string) *CreateCompositionParams {
	params.StatusCallbackMethod = &StatusCallbackMethod
	return params
}
func (params *CreateCompositionParams) SetTrim(Trim bool) *CreateCompositionParams {
	params.Trim = &Trim
	return params
}
func (params *CreateCompositionParams) SetVideoLayout(VideoLayout map[string]interface{}) *CreateCompositionParams {
	params.VideoLayout = &VideoLayout
	return params
}

func (c *DefaultApiService) CreateComposition(params *CreateCompositionParams) (*VideoV1Composition, error) {
	path := "/v1/Compositions"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AudioSources != nil {
		data.Set("AudioSources", strings.Join(*params.AudioSources, ","))
	}
	if params != nil && params.AudioSourcesExcluded != nil {
		data.Set("AudioSourcesExcluded", strings.Join(*params.AudioSourcesExcluded, ","))
	}
	if params != nil && params.Format != nil {
		data.Set("Format", *params.Format)
	}
	if params != nil && params.Resolution != nil {
		data.Set("Resolution", *params.Resolution)
	}
	if params != nil && params.RoomSid != nil {
		data.Set("RoomSid", *params.RoomSid)
	}
	if params != nil && params.StatusCallback != nil {
		data.Set("StatusCallback", *params.StatusCallback)
	}
	if params != nil && params.StatusCallbackMethod != nil {
		data.Set("StatusCallbackMethod", *params.StatusCallbackMethod)
	}
	if params != nil && params.Trim != nil {
		data.Set("Trim", fmt.Sprint(*params.Trim))
	}
	if params != nil && params.VideoLayout != nil {
		v, err := json.Marshal(params.VideoLayout)

		if err != nil {
			return nil, err
		}

		data.Set("VideoLayout", string(v))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1Composition{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateCompositionHook'
type CreateCompositionHookParams struct {
	// An array of track names from the same group room to merge into the compositions created by the composition hook. Can include zero or more track names. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` includes tracks named `student` as well as `studentTeam`.
	AudioSources *[]string `json:"AudioSources,omitempty"`
	// An array of track names to exclude. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` excludes `student` as well as `studentTeam`. This parameter can also be empty.
	AudioSourcesExcluded *[]string `json:"AudioSourcesExcluded,omitempty"`
	// Whether the composition hook is active. When `true`, the composition hook will be triggered for every completed Group Room in the account. When `false`, the composition hook will never be triggered.
	Enabled *bool `json:"Enabled,omitempty"`
	// The container format of the media files used by the compositions created by the composition hook. Can be: `mp4` or `webm` and the default is `webm`. If `mp4` or `webm`, `audio_sources` must have one or more tracks and/or a `video_layout` element must contain a valid `video_sources` list, otherwise an error occurs.
	Format *string `json:"Format,omitempty"`
	// A descriptive string that you create to describe the resource. It can be up to  100 characters long and it must be unique within the account.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// A string that describes the columns (width) and rows (height) of the generated composed video in pixels. Defaults to `640x480`.  The string's format is `{width}x{height}` where:   * 16 <= `{width}` <= 1280 * 16 <= `{height}` <= 1280 * `{width}` * `{height}` <= 921,600  Typical values are:   * HD = `1280x720` * PAL = `1024x576` * VGA = `640x480` * CIF = `320x240`  Note that the `resolution` imposes an aspect ratio to the resulting composition. When the original video tracks are constrained by the aspect ratio, they are scaled to fit. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	Resolution *string `json:"Resolution,omitempty"`
	// The URL we should call using the `status_callback_method` to send status information to your application on every composition event. If not provided, status callback events will not be dispatched.
	StatusCallback *string `json:"StatusCallback,omitempty"`
	// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
	StatusCallbackMethod *string `json:"StatusCallbackMethod,omitempty"`
	// Whether to clip the intervals where there is no active media in the Compositions triggered by the composition hook. The default is `true`. Compositions with `trim` enabled are shorter when the Room is created and no Participant joins for a while as well as if all the Participants leave the room and join later, because those gaps will be removed. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	Trim *bool `json:"Trim,omitempty"`
	// An object that describes the video layout of the composition hook in terms of regions. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	VideoLayout *map[string]interface{} `json:"VideoLayout,omitempty"`
}

func (params *CreateCompositionHookParams) SetAudioSources(AudioSources []string) *CreateCompositionHookParams {
	params.AudioSources = &AudioSources
	return params
}
func (params *CreateCompositionHookParams) SetAudioSourcesExcluded(AudioSourcesExcluded []string) *CreateCompositionHookParams {
	params.AudioSourcesExcluded = &AudioSourcesExcluded
	return params
}
func (params *CreateCompositionHookParams) SetEnabled(Enabled bool) *CreateCompositionHookParams {
	params.Enabled = &Enabled
	return params
}
func (params *CreateCompositionHookParams) SetFormat(Format string) *CreateCompositionHookParams {
	params.Format = &Format
	return params
}
func (params *CreateCompositionHookParams) SetFriendlyName(FriendlyName string) *CreateCompositionHookParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateCompositionHookParams) SetResolution(Resolution string) *CreateCompositionHookParams {
	params.Resolution = &Resolution
	return params
}
func (params *CreateCompositionHookParams) SetStatusCallback(StatusCallback string) *CreateCompositionHookParams {
	params.StatusCallback = &StatusCallback
	return params
}
func (params *CreateCompositionHookParams) SetStatusCallbackMethod(StatusCallbackMethod string) *CreateCompositionHookParams {
	params.StatusCallbackMethod = &StatusCallbackMethod
	return params
}
func (params *CreateCompositionHookParams) SetTrim(Trim bool) *CreateCompositionHookParams {
	params.Trim = &Trim
	return params
}
func (params *CreateCompositionHookParams) SetVideoLayout(VideoLayout map[string]interface{}) *CreateCompositionHookParams {
	params.VideoLayout = &VideoLayout
	return params
}

func (c *DefaultApiService) CreateCompositionHook(params *CreateCompositionHookParams) (*VideoV1CompositionHook, error) {
	path := "/v1/CompositionHooks"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AudioSources != nil {
		data.Set("AudioSources", strings.Join(*params.AudioSources, ","))
	}
	if params != nil && params.AudioSourcesExcluded != nil {
		data.Set("AudioSourcesExcluded", strings.Join(*params.AudioSourcesExcluded, ","))
	}
	if params != nil && params.Enabled != nil {
		data.Set("Enabled", fmt.Sprint(*params.Enabled))
	}
	if params != nil && params.Format != nil {
		data.Set("Format", *params.Format)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Resolution != nil {
		data.Set("Resolution", *params.Resolution)
	}
	if params != nil && params.StatusCallback != nil {
		data.Set("StatusCallback", *params.StatusCallback)
	}
	if params != nil && params.StatusCallbackMethod != nil {
		data.Set("StatusCallbackMethod", *params.StatusCallbackMethod)
	}
	if params != nil && params.Trim != nil {
		data.Set("Trim", fmt.Sprint(*params.Trim))
	}
	if params != nil && params.VideoLayout != nil {
		v, err := json.Marshal(params.VideoLayout)

		if err != nil {
			return nil, err
		}

		data.Set("VideoLayout", string(v))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1CompositionHook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateCompositionSettings'
type CreateCompositionSettingsParams struct {
	// The SID of the stored Credential resource.
	AwsCredentialsSid *string `json:"AwsCredentialsSid,omitempty"`
	// The URL of the AWS S3 bucket where the compositions should be stored. We only support DNS-compliant URLs like `https://documentation-example-twilio-bucket/compositions`, where `compositions` is the path in which you want the compositions to be stored. This URL accepts only URI-valid characters, as described in the <a href='https://tools.ietf.org/html/rfc3986#section-2'>RFC 3986</a>.
	AwsS3Url *string `json:"AwsS3Url,omitempty"`
	// Whether all compositions should be written to the `aws_s3_url`. When `false`, all compositions are stored in our cloud.
	AwsStorageEnabled *bool `json:"AwsStorageEnabled,omitempty"`
	// Whether all compositions should be stored in an encrypted form. The default is `false`.
	EncryptionEnabled *bool `json:"EncryptionEnabled,omitempty"`
	// The SID of the Public Key resource to use for encryption.
	EncryptionKeySid *string `json:"EncryptionKeySid,omitempty"`
	// A descriptive string that you create to describe the resource and show to the user in the console
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *CreateCompositionSettingsParams) SetAwsCredentialsSid(AwsCredentialsSid string) *CreateCompositionSettingsParams {
	params.AwsCredentialsSid = &AwsCredentialsSid
	return params
}
func (params *CreateCompositionSettingsParams) SetAwsS3Url(AwsS3Url string) *CreateCompositionSettingsParams {
	params.AwsS3Url = &AwsS3Url
	return params
}
func (params *CreateCompositionSettingsParams) SetAwsStorageEnabled(AwsStorageEnabled bool) *CreateCompositionSettingsParams {
	params.AwsStorageEnabled = &AwsStorageEnabled
	return params
}
func (params *CreateCompositionSettingsParams) SetEncryptionEnabled(EncryptionEnabled bool) *CreateCompositionSettingsParams {
	params.EncryptionEnabled = &EncryptionEnabled
	return params
}
func (params *CreateCompositionSettingsParams) SetEncryptionKeySid(EncryptionKeySid string) *CreateCompositionSettingsParams {
	params.EncryptionKeySid = &EncryptionKeySid
	return params
}
func (params *CreateCompositionSettingsParams) SetFriendlyName(FriendlyName string) *CreateCompositionSettingsParams {
	params.FriendlyName = &FriendlyName
	return params
}

func (c *DefaultApiService) CreateCompositionSettings(params *CreateCompositionSettingsParams) (*VideoV1CompositionSettings, error) {
	path := "/v1/CompositionSettings/Default"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AwsCredentialsSid != nil {
		data.Set("AwsCredentialsSid", *params.AwsCredentialsSid)
	}
	if params != nil && params.AwsS3Url != nil {
		data.Set("AwsS3Url", *params.AwsS3Url)
	}
	if params != nil && params.AwsStorageEnabled != nil {
		data.Set("AwsStorageEnabled", fmt.Sprint(*params.AwsStorageEnabled))
	}
	if params != nil && params.EncryptionEnabled != nil {
		data.Set("EncryptionEnabled", fmt.Sprint(*params.EncryptionEnabled))
	}
	if params != nil && params.EncryptionKeySid != nil {
		data.Set("EncryptionKeySid", *params.EncryptionKeySid)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1CompositionSettings{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateRecordingSettings'
type CreateRecordingSettingsParams struct {
	// The SID of the stored Credential resource.
	AwsCredentialsSid *string `json:"AwsCredentialsSid,omitempty"`
	// The URL of the AWS S3 bucket where the recordings should be stored. We only support DNS-compliant URLs like `https://documentation-example-twilio-bucket/recordings`, where `recordings` is the path in which you want the recordings to be stored. This URL accepts only URI-valid characters, as described in the <a href='https://tools.ietf.org/html/rfc3986#section-2'>RFC 3986</a>.
	AwsS3Url *string `json:"AwsS3Url,omitempty"`
	// Whether all recordings should be written to the `aws_s3_url`. When `false`, all recordings are stored in our cloud.
	AwsStorageEnabled *bool `json:"AwsStorageEnabled,omitempty"`
	// Whether all recordings should be stored in an encrypted form. The default is `false`.
	EncryptionEnabled *bool `json:"EncryptionEnabled,omitempty"`
	// The SID of the Public Key resource to use for encryption.
	EncryptionKeySid *string `json:"EncryptionKeySid,omitempty"`
	// A descriptive string that you create to describe the resource and be shown to users in the console
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *CreateRecordingSettingsParams) SetAwsCredentialsSid(AwsCredentialsSid string) *CreateRecordingSettingsParams {
	params.AwsCredentialsSid = &AwsCredentialsSid
	return params
}
func (params *CreateRecordingSettingsParams) SetAwsS3Url(AwsS3Url string) *CreateRecordingSettingsParams {
	params.AwsS3Url = &AwsS3Url
	return params
}
func (params *CreateRecordingSettingsParams) SetAwsStorageEnabled(AwsStorageEnabled bool) *CreateRecordingSettingsParams {
	params.AwsStorageEnabled = &AwsStorageEnabled
	return params
}
func (params *CreateRecordingSettingsParams) SetEncryptionEnabled(EncryptionEnabled bool) *CreateRecordingSettingsParams {
	params.EncryptionEnabled = &EncryptionEnabled
	return params
}
func (params *CreateRecordingSettingsParams) SetEncryptionKeySid(EncryptionKeySid string) *CreateRecordingSettingsParams {
	params.EncryptionKeySid = &EncryptionKeySid
	return params
}
func (params *CreateRecordingSettingsParams) SetFriendlyName(FriendlyName string) *CreateRecordingSettingsParams {
	params.FriendlyName = &FriendlyName
	return params
}

func (c *DefaultApiService) CreateRecordingSettings(params *CreateRecordingSettingsParams) (*VideoV1RecordingSettings, error) {
	path := "/v1/RecordingSettings/Default"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AwsCredentialsSid != nil {
		data.Set("AwsCredentialsSid", *params.AwsCredentialsSid)
	}
	if params != nil && params.AwsS3Url != nil {
		data.Set("AwsS3Url", *params.AwsS3Url)
	}
	if params != nil && params.AwsStorageEnabled != nil {
		data.Set("AwsStorageEnabled", fmt.Sprint(*params.AwsStorageEnabled))
	}
	if params != nil && params.EncryptionEnabled != nil {
		data.Set("EncryptionEnabled", fmt.Sprint(*params.EncryptionEnabled))
	}
	if params != nil && params.EncryptionKeySid != nil {
		data.Set("EncryptionKeySid", *params.EncryptionKeySid)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RecordingSettings{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateRoom'
type CreateRoomParams struct {
	// Deprecated, now always considered to be true.
	EnableTurn *bool `json:"EnableTurn,omitempty"`
	// The maximum number of concurrent Participants allowed in the room. Peer-to-peer rooms can have up to 10 Participants. Small Group rooms can have up to 4 Participants. Group rooms can have up to 50 Participants.
	MaxParticipants *int32 `json:"MaxParticipants,omitempty"`
	// The region for the media server in Group Rooms.  Can be: one of the [available Media Regions](https://www.twilio.com/docs/video/ip-address-whitelisting#group-rooms-media-servers). ***This feature is not available in `peer-to-peer` rooms.***
	MediaRegion *string `json:"MediaRegion,omitempty"`
	// Whether to start recording when Participants connect. ***This feature is not available in `peer-to-peer` rooms.***
	RecordParticipantsOnConnect *bool `json:"RecordParticipantsOnConnect,omitempty"`
	// A collection of Recording Rules that describe how to include or exclude matching tracks for recording
	RecordingRules *map[string]interface{} `json:"RecordingRules,omitempty"`
	// The URL we should call using the `status_callback_method` to send status information to your application on every room event. See [Status Callbacks](https://www.twilio.com/docs/video/api/status-callbacks) for more info.
	StatusCallback *string `json:"StatusCallback,omitempty"`
	// The HTTP method we should use to call `status_callback`. Can be `POST` or `GET`.
	StatusCallbackMethod *string `json:"StatusCallbackMethod,omitempty"`
	// The type of room. Can be: `go`, `peer-to-peer`, `group-small`, or `group`. The default value is `group`.
	Type *string `json:"Type,omitempty"`
	// An application-defined string that uniquely identifies the resource. It can be used as a `room_sid` in place of the resource's `sid` in the URL to address the resource. This value is unique for `in-progress` rooms. SDK clients can use this name to connect to the room. REST API clients can use this name in place of the Room SID to interact with the room as long as the room is `in-progress`.
	UniqueName *string `json:"UniqueName,omitempty"`
	// An array of the video codecs that are supported when publishing a track in the room.  Can be: `VP8` and `H264`.  ***This feature is not available in `peer-to-peer` rooms***
	VideoCodecs *[]string `json:"VideoCodecs,omitempty"`
}

func (params *CreateRoomParams) SetEnableTurn(EnableTurn bool) *CreateRoomParams {
	params.EnableTurn = &EnableTurn
	return params
}
func (params *CreateRoomParams) SetMaxParticipants(MaxParticipants int32) *CreateRoomParams {
	params.MaxParticipants = &MaxParticipants
	return params
}
func (params *CreateRoomParams) SetMediaRegion(MediaRegion string) *CreateRoomParams {
	params.MediaRegion = &MediaRegion
	return params
}
func (params *CreateRoomParams) SetRecordParticipantsOnConnect(RecordParticipantsOnConnect bool) *CreateRoomParams {
	params.RecordParticipantsOnConnect = &RecordParticipantsOnConnect
	return params
}
func (params *CreateRoomParams) SetRecordingRules(RecordingRules map[string]interface{}) *CreateRoomParams {
	params.RecordingRules = &RecordingRules
	return params
}
func (params *CreateRoomParams) SetStatusCallback(StatusCallback string) *CreateRoomParams {
	params.StatusCallback = &StatusCallback
	return params
}
func (params *CreateRoomParams) SetStatusCallbackMethod(StatusCallbackMethod string) *CreateRoomParams {
	params.StatusCallbackMethod = &StatusCallbackMethod
	return params
}
func (params *CreateRoomParams) SetType(Type string) *CreateRoomParams {
	params.Type = &Type
	return params
}
func (params *CreateRoomParams) SetUniqueName(UniqueName string) *CreateRoomParams {
	params.UniqueName = &UniqueName
	return params
}
func (params *CreateRoomParams) SetVideoCodecs(VideoCodecs []string) *CreateRoomParams {
	params.VideoCodecs = &VideoCodecs
	return params
}

func (c *DefaultApiService) CreateRoom(params *CreateRoomParams) (*VideoV1Room, error) {
	path := "/v1/Rooms"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EnableTurn != nil {
		data.Set("EnableTurn", fmt.Sprint(*params.EnableTurn))
	}
	if params != nil && params.MaxParticipants != nil {
		data.Set("MaxParticipants", fmt.Sprint(*params.MaxParticipants))
	}
	if params != nil && params.MediaRegion != nil {
		data.Set("MediaRegion", *params.MediaRegion)
	}
	if params != nil && params.RecordParticipantsOnConnect != nil {
		data.Set("RecordParticipantsOnConnect", fmt.Sprint(*params.RecordParticipantsOnConnect))
	}
	if params != nil && params.RecordingRules != nil {
		v, err := json.Marshal(params.RecordingRules)

		if err != nil {
			return nil, err
		}

		data.Set("RecordingRules", string(v))
	}
	if params != nil && params.StatusCallback != nil {
		data.Set("StatusCallback", *params.StatusCallback)
	}
	if params != nil && params.StatusCallbackMethod != nil {
		data.Set("StatusCallbackMethod", *params.StatusCallbackMethod)
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}
	if params != nil && params.VideoCodecs != nil {
		data.Set("VideoCodecs", strings.Join(*params.VideoCodecs, ","))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1Room{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Delete a Recording Composition resource identified by a Composition SID.
func (c *DefaultApiService) DeleteComposition(Sid string) error {
	path := "/v1/Compositions/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a Recording CompositionHook resource identified by a &#x60;CompositionHook SID&#x60;.
func (c *DefaultApiService) DeleteCompositionHook(Sid string) error {
	path := "/v1/CompositionHooks/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a Recording resource identified by a Recording SID.
func (c *DefaultApiService) DeleteRecording(Sid string) error {
	path := "/v1/Recordings/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

func (c *DefaultApiService) DeleteRoomRecording(RoomSid string, Sid string) error {
	path := "/v1/Rooms/{RoomSid}/Recordings/{Sid}"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Returns a single Composition resource identified by a Composition SID.
func (c *DefaultApiService) FetchComposition(Sid string) (*VideoV1Composition, error) {
	path := "/v1/Compositions/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1Composition{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Returns a single CompositionHook resource identified by a CompositionHook SID.
func (c *DefaultApiService) FetchCompositionHook(Sid string) (*VideoV1CompositionHook, error) {
	path := "/v1/CompositionHooks/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1CompositionHook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

func (c *DefaultApiService) FetchCompositionSettings() (*VideoV1CompositionSettings, error) {
	path := "/v1/CompositionSettings/Default"

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1CompositionSettings{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Returns a single Recording resource identified by a Recording SID.
func (c *DefaultApiService) FetchRecording(Sid string) (*VideoV1Recording, error) {
	path := "/v1/Recordings/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1Recording{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

func (c *DefaultApiService) FetchRecordingSettings() (*VideoV1RecordingSettings, error) {
	path := "/v1/RecordingSettings/Default"

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RecordingSettings{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

func (c *DefaultApiService) FetchRoom(Sid string) (*VideoV1Room, error) {
	path := "/v1/Rooms/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1Room{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

func (c *DefaultApiService) FetchRoomParticipant(RoomSid string, Sid string) (*VideoV1RoomRoomParticipant, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Returns a single Track resource represented by TrackName or SID.
func (c *DefaultApiService) FetchRoomParticipantPublishedTrack(RoomSid string, ParticipantSid string, Sid string) (*VideoV1RoomRoomParticipantRoomParticipantPublishedTrack, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks/{Sid}"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"ParticipantSid"+"}", ParticipantSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomParticipantRoomParticipantPublishedTrack{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Returns a list of Subscribe Rules for the Participant.
func (c *DefaultApiService) FetchRoomParticipantSubscribeRule(RoomSid string, ParticipantSid string) (*VideoV1RoomRoomParticipantRoomParticipantSubscribeRule, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"ParticipantSid"+"}", ParticipantSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomParticipantRoomParticipantSubscribeRule{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Returns a single Track resource represented by &#x60;track_sid&#x60;.  Note: This is one resource with the Video API that requires a SID, be Track Name on the subscriber side is not guaranteed to be unique.
func (c *DefaultApiService) FetchRoomParticipantSubscribedTrack(RoomSid string, ParticipantSid string, Sid string) (*VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks/{Sid}"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"ParticipantSid"+"}", ParticipantSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

func (c *DefaultApiService) FetchRoomRecording(RoomSid string, Sid string) (*VideoV1RoomRoomRecording, error) {
	path := "/v1/Rooms/{RoomSid}/Recordings/{Sid}"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomRecording{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Returns a list of Recording Rules for the Room.
func (c *DefaultApiService) FetchRoomRecordingRule(RoomSid string) (*VideoV1RoomRoomRecordingRule, error) {
	path := "/v1/Rooms/{RoomSid}/RecordingRules"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomRecordingRule{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListComposition'
type ListCompositionParams struct {
	// Read only Composition resources with this status. Can be: `enqueued`, `processing`, `completed`, `deleted`, or `failed`.
	Status *string `json:"Status,omitempty"`
	// Read only Composition resources created on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time with time zone.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Read only Composition resources created before this ISO 8601 date-time with time zone.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// Read only Composition resources with this Room SID.
	RoomSid *string `json:"RoomSid,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListCompositionParams) SetStatus(Status string) *ListCompositionParams {
	params.Status = &Status
	return params
}
func (params *ListCompositionParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListCompositionParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListCompositionParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListCompositionParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListCompositionParams) SetRoomSid(RoomSid string) *ListCompositionParams {
	params.RoomSid = &RoomSid
	return params
}
func (params *ListCompositionParams) SetPageSize(PageSize int32) *ListCompositionParams {
	params.PageSize = &PageSize
	return params
}

// List of all Recording compositions.
func (c *DefaultApiService) ListComposition(params *ListCompositionParams) (*ListCompositionResponse, error) {
	path := "/v1/Compositions"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.RoomSid != nil {
		data.Set("RoomSid", *params.RoomSid)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListCompositionResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListCompositionHook'
type ListCompositionHookParams struct {
	// Read only CompositionHook resources with an `enabled` value that matches this parameter.
	Enabled *bool `json:"Enabled,omitempty"`
	// Read only CompositionHook resources created on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Read only CompositionHook resources created before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// Read only CompositionHook resources with friendly names that match this string. The match is not case sensitive and can include asterisk `*` characters as wildcard match.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListCompositionHookParams) SetEnabled(Enabled bool) *ListCompositionHookParams {
	params.Enabled = &Enabled
	return params
}
func (params *ListCompositionHookParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListCompositionHookParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListCompositionHookParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListCompositionHookParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListCompositionHookParams) SetFriendlyName(FriendlyName string) *ListCompositionHookParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListCompositionHookParams) SetPageSize(PageSize int32) *ListCompositionHookParams {
	params.PageSize = &PageSize
	return params
}

// List of all Recording CompositionHook resources.
func (c *DefaultApiService) ListCompositionHook(params *ListCompositionHookParams) (*ListCompositionHookResponse, error) {
	path := "/v1/CompositionHooks"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Enabled != nil {
		data.Set("Enabled", fmt.Sprint(*params.Enabled))
	}
	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListCompositionHookResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRecording'
type ListRecordingParams struct {
	// Read only the recordings that have this status. Can be: `processing`, `completed`, or `deleted`.
	Status *string `json:"Status,omitempty"`
	// Read only the recordings that have this `source_sid`.
	SourceSid *string `json:"SourceSid,omitempty"`
	// Read only recordings with this `grouping_sid`, which may include a `participant_sid` and/or a `room_sid`.
	GroupingSid *[]string `json:"GroupingSid,omitempty"`
	// Read only recordings that started on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time with time zone.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Read only recordings that started before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time with time zone, given as `YYYY-MM-DDThh:mm:ss+|-hh:mm` or `YYYY-MM-DDThh:mm:ssZ`.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// Read only recordings that have this media type. Can be either `audio` or `video`.
	MediaType *string `json:"MediaType,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRecordingParams) SetStatus(Status string) *ListRecordingParams {
	params.Status = &Status
	return params
}
func (params *ListRecordingParams) SetSourceSid(SourceSid string) *ListRecordingParams {
	params.SourceSid = &SourceSid
	return params
}
func (params *ListRecordingParams) SetGroupingSid(GroupingSid []string) *ListRecordingParams {
	params.GroupingSid = &GroupingSid
	return params
}
func (params *ListRecordingParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListRecordingParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListRecordingParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListRecordingParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListRecordingParams) SetMediaType(MediaType string) *ListRecordingParams {
	params.MediaType = &MediaType
	return params
}
func (params *ListRecordingParams) SetPageSize(PageSize int32) *ListRecordingParams {
	params.PageSize = &PageSize
	return params
}

// List of all Track recordings.
func (c *DefaultApiService) ListRecording(params *ListRecordingParams) (*ListRecordingResponse, error) {
	path := "/v1/Recordings"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.SourceSid != nil {
		data.Set("SourceSid", *params.SourceSid)
	}
	if params != nil && params.GroupingSid != nil {
		data.Set("GroupingSid", strings.Join(*params.GroupingSid, ","))
	}
	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.MediaType != nil {
		data.Set("MediaType", *params.MediaType)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRecordingResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRoom'
type ListRoomParams struct {
	// Read only the rooms with this status. Can be: `in-progress` (default) or `completed`
	Status *string `json:"Status,omitempty"`
	// Read only rooms with the this `unique_name`.
	UniqueName *string `json:"UniqueName,omitempty"`
	// Read only rooms that started on or after this date, given as `YYYY-MM-DD`.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Read only rooms that started before this date, given as `YYYY-MM-DD`.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRoomParams) SetStatus(Status string) *ListRoomParams {
	params.Status = &Status
	return params
}
func (params *ListRoomParams) SetUniqueName(UniqueName string) *ListRoomParams {
	params.UniqueName = &UniqueName
	return params
}
func (params *ListRoomParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListRoomParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListRoomParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListRoomParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListRoomParams) SetPageSize(PageSize int32) *ListRoomParams {
	params.PageSize = &PageSize
	return params
}

func (c *DefaultApiService) ListRoom(params *ListRoomParams) (*ListRoomResponse, error) {
	path := "/v1/Rooms"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}
	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoomResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRoomParticipant'
type ListRoomParticipantParams struct {
	// Read only the participants with this status. Can be: `connected` or `disconnected`. For `in-progress` Rooms the default Status is `connected`, for `completed` Rooms only `disconnected` Participants are returned.
	Status *string `json:"Status,omitempty"`
	// Read only the Participants with this [User](https://www.twilio.com/docs/chat/rest/user-resource) `identity` value.
	Identity *string `json:"Identity,omitempty"`
	// Read only Participants that started after this date in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#UTC) format.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Read only Participants that started before this date in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#UTC) format.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRoomParticipantParams) SetStatus(Status string) *ListRoomParticipantParams {
	params.Status = &Status
	return params
}
func (params *ListRoomParticipantParams) SetIdentity(Identity string) *ListRoomParticipantParams {
	params.Identity = &Identity
	return params
}
func (params *ListRoomParticipantParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListRoomParticipantParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListRoomParticipantParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListRoomParticipantParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListRoomParticipantParams) SetPageSize(PageSize int32) *ListRoomParticipantParams {
	params.PageSize = &PageSize
	return params
}

func (c *DefaultApiService) ListRoomParticipant(RoomSid string, params *ListRoomParticipantParams) (*ListRoomParticipantResponse, error) {
	path := "/v1/Rooms/{RoomSid}/Participants"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoomParticipantResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRoomParticipantPublishedTrack'
type ListRoomParticipantPublishedTrackParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRoomParticipantPublishedTrackParams) SetPageSize(PageSize int32) *ListRoomParticipantPublishedTrackParams {
	params.PageSize = &PageSize
	return params
}

// Returns a list of tracks associated with a given Participant. Only &#x60;currently&#x60; Published Tracks are in the list resource.
func (c *DefaultApiService) ListRoomParticipantPublishedTrack(RoomSid string, ParticipantSid string, params *ListRoomParticipantPublishedTrackParams) (*ListRoomParticipantPublishedTrackResponse, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"ParticipantSid"+"}", ParticipantSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoomParticipantPublishedTrackResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRoomParticipantSubscribedTrack'
type ListRoomParticipantSubscribedTrackParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRoomParticipantSubscribedTrackParams) SetPageSize(PageSize int32) *ListRoomParticipantSubscribedTrackParams {
	params.PageSize = &PageSize
	return params
}

// Returns a list of tracks that are subscribed for the participant.
func (c *DefaultApiService) ListRoomParticipantSubscribedTrack(RoomSid string, ParticipantSid string, params *ListRoomParticipantSubscribedTrackParams) (*ListRoomParticipantSubscribedTrackResponse, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"ParticipantSid"+"}", ParticipantSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoomParticipantSubscribedTrackResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRoomRecording'
type ListRoomRecordingParams struct {
	// Read only the recordings with this status. Can be: `processing`, `completed`, or `deleted`.
	Status *string `json:"Status,omitempty"`
	// Read only the recordings that have this `source_sid`.
	SourceSid *string `json:"SourceSid,omitempty"`
	// Read only recordings that started on or after this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Read only Recordings that started before this [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime with time zone.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRoomRecordingParams) SetStatus(Status string) *ListRoomRecordingParams {
	params.Status = &Status
	return params
}
func (params *ListRoomRecordingParams) SetSourceSid(SourceSid string) *ListRoomRecordingParams {
	params.SourceSid = &SourceSid
	return params
}
func (params *ListRoomRecordingParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListRoomRecordingParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListRoomRecordingParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListRoomRecordingParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListRoomRecordingParams) SetPageSize(PageSize int32) *ListRoomRecordingParams {
	params.PageSize = &PageSize
	return params
}

func (c *DefaultApiService) ListRoomRecording(RoomSid string, params *ListRoomRecordingParams) (*ListRoomRecordingResponse, error) {
	path := "/v1/Rooms/{RoomSid}/Recordings"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.SourceSid != nil {
		data.Set("SourceSid", *params.SourceSid)
	}
	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoomRecordingResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateCompositionHook'
type UpdateCompositionHookParams struct {
	// An array of track names from the same group room to merge into the compositions created by the composition hook. Can include zero or more track names. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` includes tracks named `student` as well as `studentTeam`.
	AudioSources *[]string `json:"AudioSources,omitempty"`
	// An array of track names to exclude. A composition triggered by the composition hook includes all audio sources specified in `audio_sources` except for those specified in `audio_sources_excluded`. The track names in this parameter can include an asterisk as a wild card character, which matches zero or more characters in a track name. For example, `student*` excludes `student` as well as `studentTeam`. This parameter can also be empty.
	AudioSourcesExcluded *[]string `json:"AudioSourcesExcluded,omitempty"`
	// Whether the composition hook is active. When `true`, the composition hook will be triggered for every completed Group Room in the account. When `false`, the composition hook never triggers.
	Enabled *bool `json:"Enabled,omitempty"`
	// The container format of the media files used by the compositions created by the composition hook. Can be: `mp4` or `webm` and the default is `webm`. If `mp4` or `webm`, `audio_sources` must have one or more tracks and/or a `video_layout` element must contain a valid `video_sources` list, otherwise an error occurs.
	Format *string `json:"Format,omitempty"`
	// A descriptive string that you create to describe the resource. It can be up to  100 characters long and it must be unique within the account.
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// A string that describes the columns (width) and rows (height) of the generated composed video in pixels. Defaults to `640x480`.  The string's format is `{width}x{height}` where:   * 16 <= `{width}` <= 1280 * 16 <= `{height}` <= 1280 * `{width}` * `{height}` <= 921,600  Typical values are:   * HD = `1280x720` * PAL = `1024x576` * VGA = `640x480` * CIF = `320x240`  Note that the `resolution` imposes an aspect ratio to the resulting composition. When the original video tracks are constrained by the aspect ratio, they are scaled to fit. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	Resolution *string `json:"Resolution,omitempty"`
	// The URL we should call using the `status_callback_method` to send status information to your application on every composition event. If not provided, status callback events will not be dispatched.
	StatusCallback *string `json:"StatusCallback,omitempty"`
	// The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
	StatusCallbackMethod *string `json:"StatusCallbackMethod,omitempty"`
	// Whether to clip the intervals where there is no active media in the compositions triggered by the composition hook. The default is `true`. Compositions with `trim` enabled are shorter when the Room is created and no Participant joins for a while as well as if all the Participants leave the room and join later, because those gaps will be removed. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	Trim *bool `json:"Trim,omitempty"`
	// A JSON object that describes the video layout of the composition hook in terms of regions. See [Specifying Video Layouts](https://www.twilio.com/docs/video/api/compositions-resource#specifying-video-layouts) for more info.
	VideoLayout *map[string]interface{} `json:"VideoLayout,omitempty"`
}

func (params *UpdateCompositionHookParams) SetAudioSources(AudioSources []string) *UpdateCompositionHookParams {
	params.AudioSources = &AudioSources
	return params
}
func (params *UpdateCompositionHookParams) SetAudioSourcesExcluded(AudioSourcesExcluded []string) *UpdateCompositionHookParams {
	params.AudioSourcesExcluded = &AudioSourcesExcluded
	return params
}
func (params *UpdateCompositionHookParams) SetEnabled(Enabled bool) *UpdateCompositionHookParams {
	params.Enabled = &Enabled
	return params
}
func (params *UpdateCompositionHookParams) SetFormat(Format string) *UpdateCompositionHookParams {
	params.Format = &Format
	return params
}
func (params *UpdateCompositionHookParams) SetFriendlyName(FriendlyName string) *UpdateCompositionHookParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateCompositionHookParams) SetResolution(Resolution string) *UpdateCompositionHookParams {
	params.Resolution = &Resolution
	return params
}
func (params *UpdateCompositionHookParams) SetStatusCallback(StatusCallback string) *UpdateCompositionHookParams {
	params.StatusCallback = &StatusCallback
	return params
}
func (params *UpdateCompositionHookParams) SetStatusCallbackMethod(StatusCallbackMethod string) *UpdateCompositionHookParams {
	params.StatusCallbackMethod = &StatusCallbackMethod
	return params
}
func (params *UpdateCompositionHookParams) SetTrim(Trim bool) *UpdateCompositionHookParams {
	params.Trim = &Trim
	return params
}
func (params *UpdateCompositionHookParams) SetVideoLayout(VideoLayout map[string]interface{}) *UpdateCompositionHookParams {
	params.VideoLayout = &VideoLayout
	return params
}

func (c *DefaultApiService) UpdateCompositionHook(Sid string, params *UpdateCompositionHookParams) (*VideoV1CompositionHook, error) {
	path := "/v1/CompositionHooks/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AudioSources != nil {
		data.Set("AudioSources", strings.Join(*params.AudioSources, ","))
	}
	if params != nil && params.AudioSourcesExcluded != nil {
		data.Set("AudioSourcesExcluded", strings.Join(*params.AudioSourcesExcluded, ","))
	}
	if params != nil && params.Enabled != nil {
		data.Set("Enabled", fmt.Sprint(*params.Enabled))
	}
	if params != nil && params.Format != nil {
		data.Set("Format", *params.Format)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Resolution != nil {
		data.Set("Resolution", *params.Resolution)
	}
	if params != nil && params.StatusCallback != nil {
		data.Set("StatusCallback", *params.StatusCallback)
	}
	if params != nil && params.StatusCallbackMethod != nil {
		data.Set("StatusCallbackMethod", *params.StatusCallbackMethod)
	}
	if params != nil && params.Trim != nil {
		data.Set("Trim", fmt.Sprint(*params.Trim))
	}
	if params != nil && params.VideoLayout != nil {
		v, err := json.Marshal(params.VideoLayout)

		if err != nil {
			return nil, err
		}

		data.Set("VideoLayout", string(v))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1CompositionHook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateRoom'
type UpdateRoomParams struct {
	// The new status of the resource. Set to `completed` to end the room.
	Status *string `json:"Status,omitempty"`
}

func (params *UpdateRoomParams) SetStatus(Status string) *UpdateRoomParams {
	params.Status = &Status
	return params
}

func (c *DefaultApiService) UpdateRoom(Sid string, params *UpdateRoomParams) (*VideoV1Room, error) {
	path := "/v1/Rooms/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1Room{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateRoomParticipant'
type UpdateRoomParticipantParams struct {
	// The new status of the resource. Can be: `connected` or `disconnected`. For `in-progress` Rooms the default Status is `connected`, for `completed` Rooms only `disconnected` Participants are returned.
	Status *string `json:"Status,omitempty"`
}

func (params *UpdateRoomParticipantParams) SetStatus(Status string) *UpdateRoomParticipantParams {
	params.Status = &Status
	return params
}

func (c *DefaultApiService) UpdateRoomParticipant(RoomSid string, Sid string, params *UpdateRoomParticipantParams) (*VideoV1RoomRoomParticipant, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{Sid}"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomParticipant{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateRoomParticipantSubscribeRule'
type UpdateRoomParticipantSubscribeRuleParams struct {
	// A JSON-encoded array of subscribe rules. See the [Specifying Subscribe Rules](https://www.twilio.com/docs/video/api/track-subscriptions#specifying-sr) section for further information.
	Rules *map[string]interface{} `json:"Rules,omitempty"`
}

func (params *UpdateRoomParticipantSubscribeRuleParams) SetRules(Rules map[string]interface{}) *UpdateRoomParticipantSubscribeRuleParams {
	params.Rules = &Rules
	return params
}

// Update the Subscribe Rules for the Participant
func (c *DefaultApiService) UpdateRoomParticipantSubscribeRule(RoomSid string, ParticipantSid string, params *UpdateRoomParticipantSubscribeRuleParams) (*VideoV1RoomRoomParticipantRoomParticipantSubscribeRule, error) {
	path := "/v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)
	path = strings.Replace(path, "{"+"ParticipantSid"+"}", ParticipantSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Rules != nil {
		v, err := json.Marshal(params.Rules)

		if err != nil {
			return nil, err
		}

		data.Set("Rules", string(v))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomParticipantRoomParticipantSubscribeRule{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateRoomRecordingRule'
type UpdateRoomRecordingRuleParams struct {
	// A JSON-encoded array of recording rules.
	Rules *map[string]interface{} `json:"Rules,omitempty"`
}

func (params *UpdateRoomRecordingRuleParams) SetRules(Rules map[string]interface{}) *UpdateRoomRecordingRuleParams {
	params.Rules = &Rules
	return params
}

// Update the Recording Rules for the Room
func (c *DefaultApiService) UpdateRoomRecordingRule(RoomSid string, params *UpdateRoomRecordingRuleParams) (*VideoV1RoomRoomRecordingRule, error) {
	path := "/v1/Rooms/{RoomSid}/RecordingRules"
	path = strings.Replace(path, "{"+"RoomSid"+"}", RoomSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Rules != nil {
		v, err := json.Marshal(params.Rules)

		if err != nil {
			return nil, err
		}

		data.Set("Rules", string(v))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VideoV1RoomRoomRecordingRule{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}
