/*
 * Twilio - Verify
 *
 * This is the public Twilio REST API.
 *
 * API version: 1.16.0
 * Contact: support@twilio.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"

	"strings"
	"time"

	twilio "github.com/twilio/twilio-go/client"
)

type DefaultApiService struct {
	baseURL        string
	requestHandler *twilio.RequestHandler
}

func NewDefaultApiService(requestHandler *twilio.RequestHandler) *DefaultApiService {
	return &DefaultApiService{
		requestHandler: requestHandler,
		baseURL:        "https://verify.twilio.com",
	}
}

func NewDefaultApiServiceWithClient(client twilio.BaseClient) *DefaultApiService {
	return NewDefaultApiService(twilio.NewRequestHandler(client))
}

// Optional parameters for the method 'CreateAccessToken'
type CreateAccessTokenParams struct {
	// The Type of this Factor. Eg. `push`
	FactorType *string `json:"FactorType,omitempty"`
	// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, and generated by your external system, such as your user's UUID, GUID, or SID.
	Identity *string `json:"Identity,omitempty"`
}

func (params *CreateAccessTokenParams) SetFactorType(FactorType string) *CreateAccessTokenParams {
	params.FactorType = &FactorType
	return params
}
func (params *CreateAccessTokenParams) SetIdentity(Identity string) *CreateAccessTokenParams {
	params.Identity = &Identity
	return params
}

// Create a new enrollment Access Token for the Entity
func (c *DefaultApiService) CreateAccessToken(ServiceSid string, params *CreateAccessTokenParams) (*VerifyV2ServiceAccessToken, error) {
	path := "/v2/Services/{ServiceSid}/AccessTokens"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FactorType != nil {
		data.Set("FactorType", *params.FactorType)
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceAccessToken{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateBucket'
type CreateBucketParams struct {
	// Number of seconds that the rate limit will be enforced over.
	Interval *int32 `json:"Interval,omitempty"`
	// Maximum number of requests permitted in during the interval.
	Max *int32 `json:"Max,omitempty"`
}

func (params *CreateBucketParams) SetInterval(Interval int32) *CreateBucketParams {
	params.Interval = &Interval
	return params
}
func (params *CreateBucketParams) SetMax(Max int32) *CreateBucketParams {
	params.Max = &Max
	return params
}

// Create a new Bucket for a Rate Limit
func (c *DefaultApiService) CreateBucket(ServiceSid string, RateLimitSid string, params *CreateBucketParams) (*VerifyV2ServiceRateLimitBucket, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"RateLimitSid"+"}", RateLimitSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Interval != nil {
		data.Set("Interval", fmt.Sprint(*params.Interval))
	}
	if params != nil && params.Max != nil {
		data.Set("Max", fmt.Sprint(*params.Max))
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceRateLimitBucket{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateChallenge'
type CreateChallengeParams struct {
	// Optional payload used to verify the Challenge upon creation. Only used with a Factor of type `totp` to carry the TOTP code that needs to be verified.
	AuthPayload *string `json:"AuthPayload,omitempty"`
	// A list of objects that describe the Fields included in the Challenge. Each object contains the label and value of the field. Used when `factor_type` is `push`.
	DetailsFields *[]map[string]interface{} `json:"Details.Fields,omitempty"`
	// Shown to the user when the push notification arrives. Required when `factor_type` is `push`
	DetailsMessage *string `json:"Details.Message,omitempty"`
	// The date-time when this Challenge expires, given in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. The default value is five (5) minutes after Challenge creation. The max value is sixty (60) minutes after creation.
	ExpirationDate *time.Time `json:"ExpirationDate,omitempty"`
	// The unique SID identifier of the Factor.
	FactorSid *string `json:"FactorSid,omitempty"`
	// Details provided to give context about the Challenge. Not shown to the end user. It must be a stringified JSON with only strings values eg. `{\\\"ip\\\": \\\"172.168.1.234\\\"}`
	HiddenDetails *map[string]interface{} `json:"HiddenDetails,omitempty"`
}

func (params *CreateChallengeParams) SetAuthPayload(AuthPayload string) *CreateChallengeParams {
	params.AuthPayload = &AuthPayload
	return params
}
func (params *CreateChallengeParams) SetDetailsFields(DetailsFields []map[string]interface{}) *CreateChallengeParams {
	params.DetailsFields = &DetailsFields
	return params
}
func (params *CreateChallengeParams) SetDetailsMessage(DetailsMessage string) *CreateChallengeParams {
	params.DetailsMessage = &DetailsMessage
	return params
}
func (params *CreateChallengeParams) SetExpirationDate(ExpirationDate time.Time) *CreateChallengeParams {
	params.ExpirationDate = &ExpirationDate
	return params
}
func (params *CreateChallengeParams) SetFactorSid(FactorSid string) *CreateChallengeParams {
	params.FactorSid = &FactorSid
	return params
}
func (params *CreateChallengeParams) SetHiddenDetails(HiddenDetails map[string]interface{}) *CreateChallengeParams {
	params.HiddenDetails = &HiddenDetails
	return params
}

// Create a new Challenge for the Factor
func (c *DefaultApiService) CreateChallenge(ServiceSid string, Identity string, params *CreateChallengeParams) (*VerifyV2ServiceEntityChallenge, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AuthPayload != nil {
		data.Set("AuthPayload", *params.AuthPayload)
	}
	if params != nil && params.DetailsFields != nil {
		v, err := json.Marshal(params.DetailsFields)

		if err != nil {
			return nil, err
		}

		data.Set("Details.Fields", string(v))
	}
	if params != nil && params.DetailsMessage != nil {
		data.Set("Details.Message", *params.DetailsMessage)
	}
	if params != nil && params.ExpirationDate != nil {
		data.Set("ExpirationDate", fmt.Sprint((*params.ExpirationDate).Format(time.RFC3339)))
	}
	if params != nil && params.FactorSid != nil {
		data.Set("FactorSid", *params.FactorSid)
	}
	if params != nil && params.HiddenDetails != nil {
		v, err := json.Marshal(params.HiddenDetails)

		if err != nil {
			return nil, err
		}

		data.Set("HiddenDetails", string(v))
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityChallenge{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateEntity'
type CreateEntityParams struct {
	// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID.
	Identity *string `json:"Identity,omitempty"`
}

func (params *CreateEntityParams) SetIdentity(Identity string) *CreateEntityParams {
	params.Identity = &Identity
	return params
}

// Create a new Entity for the Service
func (c *DefaultApiService) CreateEntity(ServiceSid string, params *CreateEntityParams) (*VerifyV2ServiceEntity, error) {
	path := "/v2/Services/{ServiceSid}/Entities"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntity{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateMessagingConfiguration'
type CreateMessagingConfigurationParams struct {
	// The [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country code of the country this configuration will be applied to. If this is a global configuration, Country will take the value `all`.
	Country *string `json:"Country,omitempty"`
	// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) to be used to send SMS to the country of this configuration.
	MessagingServiceSid *string `json:"MessagingServiceSid,omitempty"`
}

func (params *CreateMessagingConfigurationParams) SetCountry(Country string) *CreateMessagingConfigurationParams {
	params.Country = &Country
	return params
}
func (params *CreateMessagingConfigurationParams) SetMessagingServiceSid(MessagingServiceSid string) *CreateMessagingConfigurationParams {
	params.MessagingServiceSid = &MessagingServiceSid
	return params
}

// Create a new MessagingConfiguration for a service.
func (c *DefaultApiService) CreateMessagingConfiguration(ServiceSid string, params *CreateMessagingConfigurationParams) (*VerifyV2ServiceMessagingConfiguration, error) {
	path := "/v2/Services/{ServiceSid}/MessagingConfigurations"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Country != nil {
		data.Set("Country", *params.Country)
	}
	if params != nil && params.MessagingServiceSid != nil {
		data.Set("MessagingServiceSid", *params.MessagingServiceSid)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceMessagingConfiguration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateNewFactor'
type CreateNewFactorParams struct {
	// The algorithm used when `factor_type` is `push`. Algorithm supported: `ES256`
	BindingAlg *string `json:"Binding.Alg,omitempty"`
	// The Ecdsa public key in PKIX, ASN.1 DER format encoded in Base64.  Required when `factor_type` is `push`
	BindingPublicKey *string `json:"Binding.PublicKey,omitempty"`
	// The shared secret for TOTP factors encoded in Base32. This can be provided when creating the Factor, otherwise it will be generated.  Used when `factor_type` is `totp`
	BindingSecret *string `json:"Binding.Secret,omitempty"`
	// The algorithm used to derive the TOTP codes. Can be `sha1`, `sha256` or `sha512`. Defaults to `sha1`.  Used when `factor_type` is `totp`
	ConfigAlg *string `json:"Config.Alg,omitempty"`
	// The ID that uniquely identifies your app in the Google or Apple store, such as `com.example.myapp`. It can be up to 100 characters long.  Required when `factor_type` is `push`.
	ConfigAppId *string `json:"Config.AppId,omitempty"`
	// Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. The default value is defined at the service level in the property `totp.code_length`. If not configured defaults to 6.  Used when `factor_type` is `totp`
	ConfigCodeLength *int32 `json:"Config.CodeLength,omitempty"`
	// The transport technology used to generate the Notification Token. Can be `apn` or `fcm`.  Required when `factor_type` is `push`.
	ConfigNotificationPlatform *string `json:"Config.NotificationPlatform,omitempty"`
	// For APN, the device token. For FCM the registration token. It used to send the push notifications. Must be between 32 and 255 characters long.  Required when `factor_type` is `push`.
	ConfigNotificationToken *string `json:"Config.NotificationToken,omitempty"`
	// The Verify Push SDK version used to configure the factor  Required when `factor_type` is `push`
	ConfigSdkVersion *string `json:"Config.SdkVersion,omitempty"`
	// The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. The default value is defined at the service level in the property `totp.skew`. If not configured defaults to 1.  Used when `factor_type` is `totp`
	ConfigSkew *int32 `json:"Config.Skew,omitempty"`
	// Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. The default value is defined at the service level in the property `totp.time_step`. Defaults to 30 seconds if not configured.  Used when `factor_type` is `totp`
	ConfigTimeStep *int32 `json:"Config.TimeStep,omitempty"`
	// The Type of this Factor. Currently `push` and `totp` are supported. For `totp` to work, you need to contact [Twilio sales](https://www.twilio.com/help/sales) first to have the Verify TOTP feature enabled for your Twilio account.
	FactorType *string `json:"FactorType,omitempty"`
	// The friendly name of this Factor. This can be any string up to 64 characters, meant for humans to distinguish between Factors. For `factor_type` `push`, this could be a device name. For `factor_type` `totp`, this value is used as the “account name” in constructing the `binding.uri` property. At the same time, we recommend avoiding providing PII.
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *CreateNewFactorParams) SetBindingAlg(BindingAlg string) *CreateNewFactorParams {
	params.BindingAlg = &BindingAlg
	return params
}
func (params *CreateNewFactorParams) SetBindingPublicKey(BindingPublicKey string) *CreateNewFactorParams {
	params.BindingPublicKey = &BindingPublicKey
	return params
}
func (params *CreateNewFactorParams) SetBindingSecret(BindingSecret string) *CreateNewFactorParams {
	params.BindingSecret = &BindingSecret
	return params
}
func (params *CreateNewFactorParams) SetConfigAlg(ConfigAlg string) *CreateNewFactorParams {
	params.ConfigAlg = &ConfigAlg
	return params
}
func (params *CreateNewFactorParams) SetConfigAppId(ConfigAppId string) *CreateNewFactorParams {
	params.ConfigAppId = &ConfigAppId
	return params
}
func (params *CreateNewFactorParams) SetConfigCodeLength(ConfigCodeLength int32) *CreateNewFactorParams {
	params.ConfigCodeLength = &ConfigCodeLength
	return params
}
func (params *CreateNewFactorParams) SetConfigNotificationPlatform(ConfigNotificationPlatform string) *CreateNewFactorParams {
	params.ConfigNotificationPlatform = &ConfigNotificationPlatform
	return params
}
func (params *CreateNewFactorParams) SetConfigNotificationToken(ConfigNotificationToken string) *CreateNewFactorParams {
	params.ConfigNotificationToken = &ConfigNotificationToken
	return params
}
func (params *CreateNewFactorParams) SetConfigSdkVersion(ConfigSdkVersion string) *CreateNewFactorParams {
	params.ConfigSdkVersion = &ConfigSdkVersion
	return params
}
func (params *CreateNewFactorParams) SetConfigSkew(ConfigSkew int32) *CreateNewFactorParams {
	params.ConfigSkew = &ConfigSkew
	return params
}
func (params *CreateNewFactorParams) SetConfigTimeStep(ConfigTimeStep int32) *CreateNewFactorParams {
	params.ConfigTimeStep = &ConfigTimeStep
	return params
}
func (params *CreateNewFactorParams) SetFactorType(FactorType string) *CreateNewFactorParams {
	params.FactorType = &FactorType
	return params
}
func (params *CreateNewFactorParams) SetFriendlyName(FriendlyName string) *CreateNewFactorParams {
	params.FriendlyName = &FriendlyName
	return params
}

// Create a new Factor for the Entity
func (c *DefaultApiService) CreateNewFactor(ServiceSid string, Identity string, params *CreateNewFactorParams) (*VerifyV2ServiceEntityNewFactor, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.BindingAlg != nil {
		data.Set("Binding.Alg", *params.BindingAlg)
	}
	if params != nil && params.BindingPublicKey != nil {
		data.Set("Binding.PublicKey", *params.BindingPublicKey)
	}
	if params != nil && params.BindingSecret != nil {
		data.Set("Binding.Secret", *params.BindingSecret)
	}
	if params != nil && params.ConfigAlg != nil {
		data.Set("Config.Alg", *params.ConfigAlg)
	}
	if params != nil && params.ConfigAppId != nil {
		data.Set("Config.AppId", *params.ConfigAppId)
	}
	if params != nil && params.ConfigCodeLength != nil {
		data.Set("Config.CodeLength", fmt.Sprint(*params.ConfigCodeLength))
	}
	if params != nil && params.ConfigNotificationPlatform != nil {
		data.Set("Config.NotificationPlatform", *params.ConfigNotificationPlatform)
	}
	if params != nil && params.ConfigNotificationToken != nil {
		data.Set("Config.NotificationToken", *params.ConfigNotificationToken)
	}
	if params != nil && params.ConfigSdkVersion != nil {
		data.Set("Config.SdkVersion", *params.ConfigSdkVersion)
	}
	if params != nil && params.ConfigSkew != nil {
		data.Set("Config.Skew", fmt.Sprint(*params.ConfigSkew))
	}
	if params != nil && params.ConfigTimeStep != nil {
		data.Set("Config.TimeStep", fmt.Sprint(*params.ConfigTimeStep))
	}
	if params != nil && params.FactorType != nil {
		data.Set("FactorType", *params.FactorType)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityNewFactor{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateNotification'
type CreateNotificationParams struct {
	// How long, in seconds, the Notification is valid. Delivery will be attempted if the device is offline until the TTL elapses. 0 means that the notification delivery is attempted immediately, only once, and is not stored for future delivery. Must be an integer between 0 and 300 seconds, inclusive. Defaults to 300 seconds.
	Ttl *int32 `json:"Ttl,omitempty"`
}

func (params *CreateNotificationParams) SetTtl(Ttl int32) *CreateNotificationParams {
	params.Ttl = &Ttl
	return params
}

// Create a new Notification for the corresponding Challenge
func (c *DefaultApiService) CreateNotification(ServiceSid string, Identity string, ChallengeSid string, params *CreateNotificationParams) (*VerifyV2ServiceEntityChallengeNotification, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{ChallengeSid}/Notifications"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)
	path = strings.Replace(path, "{"+"ChallengeSid"+"}", ChallengeSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Ttl != nil {
		data.Set("Ttl", fmt.Sprint(*params.Ttl))
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityChallengeNotification{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateRateLimit'
type CreateRateLimitParams struct {
	// Description of this Rate Limit
	Description *string `json:"Description,omitempty"`
	// Provides a unique and addressable name to be assigned to this Rate Limit, assigned by the developer, to be optionally used in addition to SID. **This value should not contain PII.**
	UniqueName *string `json:"UniqueName,omitempty"`
}

func (params *CreateRateLimitParams) SetDescription(Description string) *CreateRateLimitParams {
	params.Description = &Description
	return params
}
func (params *CreateRateLimitParams) SetUniqueName(UniqueName string) *CreateRateLimitParams {
	params.UniqueName = &UniqueName
	return params
}

// Create a new Rate Limit for a Service
func (c *DefaultApiService) CreateRateLimit(ServiceSid string, params *CreateRateLimitParams) (*VerifyV2ServiceRateLimit, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Description != nil {
		data.Set("Description", *params.Description)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceRateLimit{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateService'
type CreateServiceParams struct {
	// The length of the verification code to generate. Must be an integer value between 4 and 10, inclusive.
	CodeLength *int32 `json:"CodeLength,omitempty"`
	// Whether to allow sending verifications with a custom code instead of a randomly generated one. Not available for all customers.
	CustomCodeEnabled *bool `json:"CustomCodeEnabled,omitempty"`
	// Whether to add a security warning at the end of an SMS verification body. Disabled by default and applies only to SMS. Example SMS body: `Your AppName verification code is: 1234. Don’t share this code with anyone; our employees will never ask for the code`
	DoNotShareWarningEnabled *bool `json:"DoNotShareWarningEnabled,omitempty"`
	// Whether to ask the user to press a number before delivering the verify code in a phone call.
	DtmfInputRequired *bool `json:"DtmfInputRequired,omitempty"`
	// A descriptive string that you create to describe the verification service. It can be up to 30 characters long. **This value should not contain PII.**
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// Whether to perform a lookup with each verification started and return info about the phone number.
	LookupEnabled *bool `json:"LookupEnabled,omitempty"`
	// Whether to pass PSD2 transaction parameters when starting a verification.
	Psd2Enabled *bool `json:"Psd2Enabled,omitempty"`
	// Optional configuration for the Push factors. Set the APN Credential for this service. This will allow to send push notifications to iOS devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
	PushApnCredentialSid *string `json:"Push.ApnCredentialSid,omitempty"`
	// Optional configuration for the Push factors. Set the FCM Credential for this service. This will allow to send push notifications to Android devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
	PushFcmCredentialSid *string `json:"Push.FcmCredentialSid,omitempty"`
	// Optional configuration for the Push factors. If true, include the date in the Challenge's reponse. Otherwise, the date is omitted from the response. See [Challenge](https://www.twilio.com/docs/verify/api/challenge) resource’s details parameter for more info. Default: true
	PushIncludeDate *bool `json:"Push.IncludeDate,omitempty"`
	// Whether to skip sending SMS verifications to landlines. Requires `lookup_enabled`.
	SkipSmsToLandlines *bool `json:"SkipSmsToLandlines,omitempty"`
	// Optional configuration for the TOTP factors. Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. Defaults to 6
	TotpCodeLength *int32 `json:"Totp.CodeLength,omitempty"`
	// Optional configuration for the TOTP factors. Set TOTP Issuer for this service. This will allow to configure the issuer of the TOTP URI. Defaults to the service friendly name if not provided.
	TotpIssuer *string `json:"Totp.Issuer,omitempty"`
	// Optional configuration for the TOTP factors. The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. Defaults to 1
	TotpSkew *int32 `json:"Totp.Skew,omitempty"`
	// Optional configuration for the TOTP factors. Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. Defaults to 30 seconds
	TotpTimeStep *int32 `json:"Totp.TimeStep,omitempty"`
	// The name of an alternative text-to-speech service to use in phone calls. Applies only to TTS languages.
	TtsName *string `json:"TtsName,omitempty"`
}

func (params *CreateServiceParams) SetCodeLength(CodeLength int32) *CreateServiceParams {
	params.CodeLength = &CodeLength
	return params
}
func (params *CreateServiceParams) SetCustomCodeEnabled(CustomCodeEnabled bool) *CreateServiceParams {
	params.CustomCodeEnabled = &CustomCodeEnabled
	return params
}
func (params *CreateServiceParams) SetDoNotShareWarningEnabled(DoNotShareWarningEnabled bool) *CreateServiceParams {
	params.DoNotShareWarningEnabled = &DoNotShareWarningEnabled
	return params
}
func (params *CreateServiceParams) SetDtmfInputRequired(DtmfInputRequired bool) *CreateServiceParams {
	params.DtmfInputRequired = &DtmfInputRequired
	return params
}
func (params *CreateServiceParams) SetFriendlyName(FriendlyName string) *CreateServiceParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateServiceParams) SetLookupEnabled(LookupEnabled bool) *CreateServiceParams {
	params.LookupEnabled = &LookupEnabled
	return params
}
func (params *CreateServiceParams) SetPsd2Enabled(Psd2Enabled bool) *CreateServiceParams {
	params.Psd2Enabled = &Psd2Enabled
	return params
}
func (params *CreateServiceParams) SetPushApnCredentialSid(PushApnCredentialSid string) *CreateServiceParams {
	params.PushApnCredentialSid = &PushApnCredentialSid
	return params
}
func (params *CreateServiceParams) SetPushFcmCredentialSid(PushFcmCredentialSid string) *CreateServiceParams {
	params.PushFcmCredentialSid = &PushFcmCredentialSid
	return params
}
func (params *CreateServiceParams) SetPushIncludeDate(PushIncludeDate bool) *CreateServiceParams {
	params.PushIncludeDate = &PushIncludeDate
	return params
}
func (params *CreateServiceParams) SetSkipSmsToLandlines(SkipSmsToLandlines bool) *CreateServiceParams {
	params.SkipSmsToLandlines = &SkipSmsToLandlines
	return params
}
func (params *CreateServiceParams) SetTotpCodeLength(TotpCodeLength int32) *CreateServiceParams {
	params.TotpCodeLength = &TotpCodeLength
	return params
}
func (params *CreateServiceParams) SetTotpIssuer(TotpIssuer string) *CreateServiceParams {
	params.TotpIssuer = &TotpIssuer
	return params
}
func (params *CreateServiceParams) SetTotpSkew(TotpSkew int32) *CreateServiceParams {
	params.TotpSkew = &TotpSkew
	return params
}
func (params *CreateServiceParams) SetTotpTimeStep(TotpTimeStep int32) *CreateServiceParams {
	params.TotpTimeStep = &TotpTimeStep
	return params
}
func (params *CreateServiceParams) SetTtsName(TtsName string) *CreateServiceParams {
	params.TtsName = &TtsName
	return params
}

// Create a new Verification Service.
func (c *DefaultApiService) CreateService(params *CreateServiceParams) (*VerifyV2Service, error) {
	path := "/v2/Services"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.CodeLength != nil {
		data.Set("CodeLength", fmt.Sprint(*params.CodeLength))
	}
	if params != nil && params.CustomCodeEnabled != nil {
		data.Set("CustomCodeEnabled", fmt.Sprint(*params.CustomCodeEnabled))
	}
	if params != nil && params.DoNotShareWarningEnabled != nil {
		data.Set("DoNotShareWarningEnabled", fmt.Sprint(*params.DoNotShareWarningEnabled))
	}
	if params != nil && params.DtmfInputRequired != nil {
		data.Set("DtmfInputRequired", fmt.Sprint(*params.DtmfInputRequired))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.LookupEnabled != nil {
		data.Set("LookupEnabled", fmt.Sprint(*params.LookupEnabled))
	}
	if params != nil && params.Psd2Enabled != nil {
		data.Set("Psd2Enabled", fmt.Sprint(*params.Psd2Enabled))
	}
	if params != nil && params.PushApnCredentialSid != nil {
		data.Set("Push.ApnCredentialSid", *params.PushApnCredentialSid)
	}
	if params != nil && params.PushFcmCredentialSid != nil {
		data.Set("Push.FcmCredentialSid", *params.PushFcmCredentialSid)
	}
	if params != nil && params.PushIncludeDate != nil {
		data.Set("Push.IncludeDate", fmt.Sprint(*params.PushIncludeDate))
	}
	if params != nil && params.SkipSmsToLandlines != nil {
		data.Set("SkipSmsToLandlines", fmt.Sprint(*params.SkipSmsToLandlines))
	}
	if params != nil && params.TotpCodeLength != nil {
		data.Set("Totp.CodeLength", fmt.Sprint(*params.TotpCodeLength))
	}
	if params != nil && params.TotpIssuer != nil {
		data.Set("Totp.Issuer", *params.TotpIssuer)
	}
	if params != nil && params.TotpSkew != nil {
		data.Set("Totp.Skew", fmt.Sprint(*params.TotpSkew))
	}
	if params != nil && params.TotpTimeStep != nil {
		data.Set("Totp.TimeStep", fmt.Sprint(*params.TotpTimeStep))
	}
	if params != nil && params.TtsName != nil {
		data.Set("TtsName", *params.TtsName)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateVerification'
type CreateVerificationParams struct {
	// The amount of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
	Amount *string `json:"Amount,omitempty"`
	// Your [App Hash](https://developers.google.com/identity/sms-retriever/verify#computing_your_apps_hash_string) to be appended at the end of your verification SMS body. Applies only to SMS. Example SMS body: `<#> Your AppName verification code is: 1234 He42w354ol9`.
	AppHash *string `json:"AppHash,omitempty"`
	// The verification method to use. Can be: [`email`](https://www.twilio.com/docs/verify/email), `sms` or `call`.
	Channel *string `json:"Channel,omitempty"`
	// [`email`](https://www.twilio.com/docs/verify/email) channel configuration in json format. Must include 'from' and 'from_name'.
	ChannelConfiguration *map[string]interface{} `json:"ChannelConfiguration,omitempty"`
	// A pre-generated code to use for verification. The code can be between 4 and 10 characters, inclusive.
	CustomCode *string `json:"CustomCode,omitempty"`
	// A custom user defined friendly name that overwrites the existing one in the verification message
	CustomFriendlyName *string `json:"CustomFriendlyName,omitempty"`
	// The text of a custom message to use for the verification.
	CustomMessage *string `json:"CustomMessage,omitempty"`
	// The locale to use for the verification SMS or call. Can be: `af`, `ar`, `ca`, `cs`, `da`, `de`, `el`, `en`, `en-GB`, `es`, `fi`, `fr`, `he`, `hi`, `hr`, `hu`, `id`, `it`, `ja`, `ko`, `ms`, `nb`, `nl`, `pl`, `pt`, `pr-BR`, `ro`, `ru`, `sv`, `th`, `tl`, `tr`, `vi`, `zh`, `zh-CN`, or `zh-HK.`
	Locale *string `json:"Locale,omitempty"`
	// The payee of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
	Payee *string `json:"Payee,omitempty"`
	// The custom key-value pairs of Programmable Rate Limits. Keys correspond to `unique_name` fields defined when [creating your Rate Limit](https://www.twilio.com/docs/verify/api/service-rate-limits). Associated value pairs represent values in the request that you are rate limiting on. You may include multiple Rate Limit values in each request.
	RateLimits *map[string]interface{} `json:"RateLimits,omitempty"`
	// The digits to send after a phone call is answered, for example, to dial an extension. For more information, see the Programmable Voice documentation of [sendDigits](https://www.twilio.com/docs/voice/twiml/number#attributes-sendDigits).
	SendDigits *string `json:"SendDigits,omitempty"`
	// The phone number or [email](https://www.twilio.com/docs/verify/email) to verify. Phone numbers must be in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).
	To *string `json:"To,omitempty"`
}

func (params *CreateVerificationParams) SetAmount(Amount string) *CreateVerificationParams {
	params.Amount = &Amount
	return params
}
func (params *CreateVerificationParams) SetAppHash(AppHash string) *CreateVerificationParams {
	params.AppHash = &AppHash
	return params
}
func (params *CreateVerificationParams) SetChannel(Channel string) *CreateVerificationParams {
	params.Channel = &Channel
	return params
}
func (params *CreateVerificationParams) SetChannelConfiguration(ChannelConfiguration map[string]interface{}) *CreateVerificationParams {
	params.ChannelConfiguration = &ChannelConfiguration
	return params
}
func (params *CreateVerificationParams) SetCustomCode(CustomCode string) *CreateVerificationParams {
	params.CustomCode = &CustomCode
	return params
}
func (params *CreateVerificationParams) SetCustomFriendlyName(CustomFriendlyName string) *CreateVerificationParams {
	params.CustomFriendlyName = &CustomFriendlyName
	return params
}
func (params *CreateVerificationParams) SetCustomMessage(CustomMessage string) *CreateVerificationParams {
	params.CustomMessage = &CustomMessage
	return params
}
func (params *CreateVerificationParams) SetLocale(Locale string) *CreateVerificationParams {
	params.Locale = &Locale
	return params
}
func (params *CreateVerificationParams) SetPayee(Payee string) *CreateVerificationParams {
	params.Payee = &Payee
	return params
}
func (params *CreateVerificationParams) SetRateLimits(RateLimits map[string]interface{}) *CreateVerificationParams {
	params.RateLimits = &RateLimits
	return params
}
func (params *CreateVerificationParams) SetSendDigits(SendDigits string) *CreateVerificationParams {
	params.SendDigits = &SendDigits
	return params
}
func (params *CreateVerificationParams) SetTo(To string) *CreateVerificationParams {
	params.To = &To
	return params
}

// Create a new Verification using a Service
func (c *DefaultApiService) CreateVerification(ServiceSid string, params *CreateVerificationParams) (*VerifyV2ServiceVerification, error) {
	path := "/v2/Services/{ServiceSid}/Verifications"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Amount != nil {
		data.Set("Amount", *params.Amount)
	}
	if params != nil && params.AppHash != nil {
		data.Set("AppHash", *params.AppHash)
	}
	if params != nil && params.Channel != nil {
		data.Set("Channel", *params.Channel)
	}
	if params != nil && params.ChannelConfiguration != nil {
		v, err := json.Marshal(params.ChannelConfiguration)

		if err != nil {
			return nil, err
		}

		data.Set("ChannelConfiguration", string(v))
	}
	if params != nil && params.CustomCode != nil {
		data.Set("CustomCode", *params.CustomCode)
	}
	if params != nil && params.CustomFriendlyName != nil {
		data.Set("CustomFriendlyName", *params.CustomFriendlyName)
	}
	if params != nil && params.CustomMessage != nil {
		data.Set("CustomMessage", *params.CustomMessage)
	}
	if params != nil && params.Locale != nil {
		data.Set("Locale", *params.Locale)
	}
	if params != nil && params.Payee != nil {
		data.Set("Payee", *params.Payee)
	}
	if params != nil && params.RateLimits != nil {
		v, err := json.Marshal(params.RateLimits)

		if err != nil {
			return nil, err
		}

		data.Set("RateLimits", string(v))
	}
	if params != nil && params.SendDigits != nil {
		data.Set("SendDigits", *params.SendDigits)
	}
	if params != nil && params.To != nil {
		data.Set("To", *params.To)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceVerification{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateVerificationCheck'
type CreateVerificationCheckParams struct {
	// The amount of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
	Amount *string `json:"Amount,omitempty"`
	// The 4-10 character string being verified.
	Code *string `json:"Code,omitempty"`
	// The payee of the associated PSD2 compliant transaction. Requires the PSD2 Service flag enabled.
	Payee *string `json:"Payee,omitempty"`
	// The phone number or [email](https://www.twilio.com/docs/verify/email) to verify. Either this parameter or the `verification_sid` must be specified. Phone numbers must be in [E.164 format](https://www.twilio.com/docs/glossary/what-e164).
	To *string `json:"To,omitempty"`
	// A SID that uniquely identifies the Verification Check. Either this parameter or the `to` phone number/[email](https://www.twilio.com/docs/verify/email) must be specified.
	VerificationSid *string `json:"VerificationSid,omitempty"`
}

func (params *CreateVerificationCheckParams) SetAmount(Amount string) *CreateVerificationCheckParams {
	params.Amount = &Amount
	return params
}
func (params *CreateVerificationCheckParams) SetCode(Code string) *CreateVerificationCheckParams {
	params.Code = &Code
	return params
}
func (params *CreateVerificationCheckParams) SetPayee(Payee string) *CreateVerificationCheckParams {
	params.Payee = &Payee
	return params
}
func (params *CreateVerificationCheckParams) SetTo(To string) *CreateVerificationCheckParams {
	params.To = &To
	return params
}
func (params *CreateVerificationCheckParams) SetVerificationSid(VerificationSid string) *CreateVerificationCheckParams {
	params.VerificationSid = &VerificationSid
	return params
}

// challenge a specific Verification Check.
func (c *DefaultApiService) CreateVerificationCheck(ServiceSid string, params *CreateVerificationCheckParams) (*VerifyV2ServiceVerificationCheck, error) {
	path := "/v2/Services/{ServiceSid}/VerificationCheck"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Amount != nil {
		data.Set("Amount", *params.Amount)
	}
	if params != nil && params.Code != nil {
		data.Set("Code", *params.Code)
	}
	if params != nil && params.Payee != nil {
		data.Set("Payee", *params.Payee)
	}
	if params != nil && params.To != nil {
		data.Set("To", *params.To)
	}
	if params != nil && params.VerificationSid != nil {
		data.Set("VerificationSid", *params.VerificationSid)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceVerificationCheck{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'CreateWebhook'
type CreateWebhookParams struct {
	// The array of events that this Webhook is subscribed to. Possible event types: `*, factor.deleted, factor.created, factor.verified, challenge.approved, challenge.denied`
	EventTypes *[]string `json:"EventTypes,omitempty"`
	// The string that you assigned to describe the webhook. **This value should not contain PII.**
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The webhook status. Default value is `enabled`. One of: `enabled` or `disabled`
	Status *string `json:"Status,omitempty"`
	// The URL associated with this Webhook.
	WebhookUrl *string `json:"WebhookUrl,omitempty"`
}

func (params *CreateWebhookParams) SetEventTypes(EventTypes []string) *CreateWebhookParams {
	params.EventTypes = &EventTypes
	return params
}
func (params *CreateWebhookParams) SetFriendlyName(FriendlyName string) *CreateWebhookParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateWebhookParams) SetStatus(Status string) *CreateWebhookParams {
	params.Status = &Status
	return params
}
func (params *CreateWebhookParams) SetWebhookUrl(WebhookUrl string) *CreateWebhookParams {
	params.WebhookUrl = &WebhookUrl
	return params
}

// Create a new Webhook for the Service
func (c *DefaultApiService) CreateWebhook(ServiceSid string, params *CreateWebhookParams) (*VerifyV2ServiceWebhook, error) {
	path := "/v2/Services/{ServiceSid}/Webhooks"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EventTypes != nil {
		data.Set("EventTypes", strings.Join(*params.EventTypes, ","))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.WebhookUrl != nil {
		data.Set("WebhookUrl", *params.WebhookUrl)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Delete a specific Bucket.
func (c *DefaultApiService) DeleteBucket(ServiceSid string, RateLimitSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"RateLimitSid"+"}", RateLimitSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a specific Entity.
func (c *DefaultApiService) DeleteEntity(ServiceSid string, Identity string) error {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a specific Factor.
func (c *DefaultApiService) DeleteFactor(ServiceSid string, Identity string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a specific MessagingConfiguration.
func (c *DefaultApiService) DeleteMessagingConfiguration(ServiceSid string, Country string) error {
	path := "/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Country"+"}", Country, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a specific Rate Limit.
func (c *DefaultApiService) DeleteRateLimit(ServiceSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/RateLimits/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a specific Verification Service Instance.
func (c *DefaultApiService) DeleteService(Sid string) error {
	path := "/v2/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Delete a specific Webhook.
func (c *DefaultApiService) DeleteWebhook(ServiceSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// Fetch a specific Bucket.
func (c *DefaultApiService) FetchBucket(ServiceSid string, RateLimitSid string, Sid string) (*VerifyV2ServiceRateLimitBucket, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"RateLimitSid"+"}", RateLimitSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceRateLimitBucket{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific Challenge.
func (c *DefaultApiService) FetchChallenge(ServiceSid string, Identity string, Sid string) (*VerifyV2ServiceEntityChallenge, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityChallenge{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific Entity.
func (c *DefaultApiService) FetchEntity(ServiceSid string, Identity string) (*VerifyV2ServiceEntity, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntity{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific Factor.
func (c *DefaultApiService) FetchFactor(ServiceSid string, Identity string, Sid string) (*VerifyV2ServiceEntityFactor, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityFactor{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch the forms for a specific Form Type.
func (c *DefaultApiService) FetchForm(FormType string) (*VerifyV2Form, error) {
	path := "/v2/Forms/{FormType}"
	path = strings.Replace(path, "{"+"FormType"+"}", FormType, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2Form{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific MessagingConfiguration.
func (c *DefaultApiService) FetchMessagingConfiguration(ServiceSid string, Country string) (*VerifyV2ServiceMessagingConfiguration, error) {
	path := "/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Country"+"}", Country, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceMessagingConfiguration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific Rate Limit.
func (c *DefaultApiService) FetchRateLimit(ServiceSid string, Sid string) (*VerifyV2ServiceRateLimit, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceRateLimit{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch specific Verification Service Instance.
func (c *DefaultApiService) FetchService(Sid string) (*VerifyV2Service, error) {
	path := "/v2/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific Verification
func (c *DefaultApiService) FetchVerification(ServiceSid string, Sid string) (*VerifyV2ServiceVerification, error) {
	path := "/v2/Services/{ServiceSid}/Verifications/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceVerification{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific verification attempt.
func (c *DefaultApiService) FetchVerificationAttempt(Sid string) (*VerifyV2VerificationAttempt, error) {
	path := "/v2/Attempts/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2VerificationAttempt{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Fetch a specific Webhook.
func (c *DefaultApiService) FetchWebhook(ServiceSid string, Sid string) (*VerifyV2ServiceWebhook, error) {
	path := "/v2/Services/{ServiceSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListBucket'
type ListBucketParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListBucketParams) SetPageSize(PageSize int32) *ListBucketParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Buckets for a Rate Limit.
func (c *DefaultApiService) ListBucket(ServiceSid string, RateLimitSid string, params *ListBucketParams) (*ListBucketResponse, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"RateLimitSid"+"}", RateLimitSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListBucketResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListChallenge'
type ListChallengeParams struct {
	// The unique SID identifier of the Factor.
	FactorSid *string `json:"FactorSid,omitempty"`
	// The Status of the Challenges to fetch. One of `pending`, `expired`, `approved` or `denied`.
	Status *string `json:"Status,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListChallengeParams) SetFactorSid(FactorSid string) *ListChallengeParams {
	params.FactorSid = &FactorSid
	return params
}
func (params *ListChallengeParams) SetStatus(Status string) *ListChallengeParams {
	params.Status = &Status
	return params
}
func (params *ListChallengeParams) SetPageSize(PageSize int32) *ListChallengeParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Challenges for a Factor.
func (c *DefaultApiService) ListChallenge(ServiceSid string, Identity string, params *ListChallengeParams) (*ListChallengeResponse, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FactorSid != nil {
		data.Set("FactorSid", *params.FactorSid)
	}
	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListChallengeResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListEntity'
type ListEntityParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListEntityParams) SetPageSize(PageSize int32) *ListEntityParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Entities for a Service.
func (c *DefaultApiService) ListEntity(ServiceSid string, params *ListEntityParams) (*ListEntityResponse, error) {
	path := "/v2/Services/{ServiceSid}/Entities"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListEntityResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListFactor'
type ListFactorParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListFactorParams) SetPageSize(PageSize int32) *ListFactorParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Factors for an Entity.
func (c *DefaultApiService) ListFactor(ServiceSid string, Identity string, params *ListFactorParams) (*ListFactorResponse, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListFactorResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListMessagingConfiguration'
type ListMessagingConfigurationParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListMessagingConfigurationParams) SetPageSize(PageSize int32) *ListMessagingConfigurationParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Messaging Configurations for a Service.
func (c *DefaultApiService) ListMessagingConfiguration(ServiceSid string, params *ListMessagingConfigurationParams) (*ListMessagingConfigurationResponse, error) {
	path := "/v2/Services/{ServiceSid}/MessagingConfigurations"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListMessagingConfigurationResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListRateLimit'
type ListRateLimitParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListRateLimitParams) SetPageSize(PageSize int32) *ListRateLimitParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Rate Limits for a service.
func (c *DefaultApiService) ListRateLimit(ServiceSid string, params *ListRateLimitParams) (*ListRateLimitResponse, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRateLimitResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListService'
type ListServiceParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListServiceParams) SetPageSize(PageSize int32) *ListServiceParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Verification Services for an account.
func (c *DefaultApiService) ListService(params *ListServiceParams) (*ListServiceResponse, error) {
	path := "/v2/Services"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListVerificationAttempt'
type ListVerificationAttemptParams struct {
	// Datetime filter used to query Verification Attempts created after this datetime.
	DateCreatedAfter *time.Time `json:"DateCreatedAfter,omitempty"`
	// Datetime filter used to query Verification Attempts created before this datetime.
	DateCreatedBefore *time.Time `json:"DateCreatedBefore,omitempty"`
	// Destination of a verification. Depending on the type of channel, it could be a phone number in E.164 format or an email address.
	ChannelDataTo *string `json:"ChannelData.To,omitempty"`
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListVerificationAttemptParams) SetDateCreatedAfter(DateCreatedAfter time.Time) *ListVerificationAttemptParams {
	params.DateCreatedAfter = &DateCreatedAfter
	return params
}
func (params *ListVerificationAttemptParams) SetDateCreatedBefore(DateCreatedBefore time.Time) *ListVerificationAttemptParams {
	params.DateCreatedBefore = &DateCreatedBefore
	return params
}
func (params *ListVerificationAttemptParams) SetChannelDataTo(ChannelDataTo string) *ListVerificationAttemptParams {
	params.ChannelDataTo = &ChannelDataTo
	return params
}
func (params *ListVerificationAttemptParams) SetPageSize(PageSize int32) *ListVerificationAttemptParams {
	params.PageSize = &PageSize
	return params
}

// List all the verification attempts for a given Account.
func (c *DefaultApiService) ListVerificationAttempt(params *ListVerificationAttemptParams) (*ListVerificationAttemptResponse, error) {
	path := "/v2/Attempts"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.DateCreatedAfter != nil {
		data.Set("DateCreatedAfter", fmt.Sprint((*params.DateCreatedAfter).Format(time.RFC3339)))
	}
	if params != nil && params.DateCreatedBefore != nil {
		data.Set("DateCreatedBefore", fmt.Sprint((*params.DateCreatedBefore).Format(time.RFC3339)))
	}
	if params != nil && params.ChannelDataTo != nil {
		data.Set("ChannelData.To", *params.ChannelDataTo)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListVerificationAttemptResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'ListWebhook'
type ListWebhookParams struct {
	// How many resources to return in each list page. The default is 50, and the maximum is 1000.
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListWebhookParams) SetPageSize(PageSize int32) *ListWebhookParams {
	params.PageSize = &PageSize
	return params
}

// Retrieve a list of all Webhooks for a Service.
func (c *DefaultApiService) ListWebhook(ServiceSid string, params *ListWebhookParams) (*ListWebhookResponse, error) {
	path := "/v2/Services/{ServiceSid}/Webhooks"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.requestHandler.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListWebhookResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateBucket'
type UpdateBucketParams struct {
	// Number of seconds that the rate limit will be enforced over.
	Interval *int32 `json:"Interval,omitempty"`
	// Maximum number of requests permitted in during the interval.
	Max *int32 `json:"Max,omitempty"`
}

func (params *UpdateBucketParams) SetInterval(Interval int32) *UpdateBucketParams {
	params.Interval = &Interval
	return params
}
func (params *UpdateBucketParams) SetMax(Max int32) *UpdateBucketParams {
	params.Max = &Max
	return params
}

// Update a specific Bucket.
func (c *DefaultApiService) UpdateBucket(ServiceSid string, RateLimitSid string, Sid string, params *UpdateBucketParams) (*VerifyV2ServiceRateLimitBucket, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"RateLimitSid"+"}", RateLimitSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Interval != nil {
		data.Set("Interval", fmt.Sprint(*params.Interval))
	}
	if params != nil && params.Max != nil {
		data.Set("Max", fmt.Sprint(*params.Max))
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceRateLimitBucket{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateChallenge'
type UpdateChallengeParams struct {
	// The optional payload needed to verify the Challenge. E.g., a TOTP would use the numeric code.
	AuthPayload *string `json:"AuthPayload,omitempty"`
}

func (params *UpdateChallengeParams) SetAuthPayload(AuthPayload string) *UpdateChallengeParams {
	params.AuthPayload = &AuthPayload
	return params
}

// Verify a specific Challenge.
func (c *DefaultApiService) UpdateChallenge(ServiceSid string, Identity string, Sid string, params *UpdateChallengeParams) (*VerifyV2ServiceEntityChallenge, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AuthPayload != nil {
		data.Set("AuthPayload", *params.AuthPayload)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityChallenge{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateFactor'
type UpdateFactorParams struct {
	// The optional payload needed to verify the Factor for the first time. E.g. for a TOTP, the numeric code.
	AuthPayload *string `json:"AuthPayload,omitempty"`
	// The algorithm used to derive the TOTP codes. Can be `sha1`, `sha256` or `sha512`
	ConfigAlg *string `json:"Config.Alg,omitempty"`
	// Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive
	ConfigCodeLength *int32 `json:"Config.CodeLength,omitempty"`
	// For APN, the device token. For FCM the registration token. It used to send the push notifications. Required when `factor_type` is `push`. If specified, this value must be between 32 and 255 characters long.
	ConfigNotificationToken *string `json:"Config.NotificationToken,omitempty"`
	// The Verify Push SDK version used to configure the factor
	ConfigSdkVersion *string `json:"Config.SdkVersion,omitempty"`
	// The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive
	ConfigSkew *int32 `json:"Config.Skew,omitempty"`
	// Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive
	ConfigTimeStep *int32 `json:"Config.TimeStep,omitempty"`
	// The new friendly name of this Factor. It can be up to 64 characters.
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *UpdateFactorParams) SetAuthPayload(AuthPayload string) *UpdateFactorParams {
	params.AuthPayload = &AuthPayload
	return params
}
func (params *UpdateFactorParams) SetConfigAlg(ConfigAlg string) *UpdateFactorParams {
	params.ConfigAlg = &ConfigAlg
	return params
}
func (params *UpdateFactorParams) SetConfigCodeLength(ConfigCodeLength int32) *UpdateFactorParams {
	params.ConfigCodeLength = &ConfigCodeLength
	return params
}
func (params *UpdateFactorParams) SetConfigNotificationToken(ConfigNotificationToken string) *UpdateFactorParams {
	params.ConfigNotificationToken = &ConfigNotificationToken
	return params
}
func (params *UpdateFactorParams) SetConfigSdkVersion(ConfigSdkVersion string) *UpdateFactorParams {
	params.ConfigSdkVersion = &ConfigSdkVersion
	return params
}
func (params *UpdateFactorParams) SetConfigSkew(ConfigSkew int32) *UpdateFactorParams {
	params.ConfigSkew = &ConfigSkew
	return params
}
func (params *UpdateFactorParams) SetConfigTimeStep(ConfigTimeStep int32) *UpdateFactorParams {
	params.ConfigTimeStep = &ConfigTimeStep
	return params
}
func (params *UpdateFactorParams) SetFriendlyName(FriendlyName string) *UpdateFactorParams {
	params.FriendlyName = &FriendlyName
	return params
}

// Update a specific Factor. This endpoint can be used to Verify a Factor if passed an &#x60;AuthPayload&#x60; param.
func (c *DefaultApiService) UpdateFactor(ServiceSid string, Identity string, Sid string, params *UpdateFactorParams) (*VerifyV2ServiceEntityFactor, error) {
	path := "/v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Identity"+"}", Identity, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AuthPayload != nil {
		data.Set("AuthPayload", *params.AuthPayload)
	}
	if params != nil && params.ConfigAlg != nil {
		data.Set("Config.Alg", *params.ConfigAlg)
	}
	if params != nil && params.ConfigCodeLength != nil {
		data.Set("Config.CodeLength", fmt.Sprint(*params.ConfigCodeLength))
	}
	if params != nil && params.ConfigNotificationToken != nil {
		data.Set("Config.NotificationToken", *params.ConfigNotificationToken)
	}
	if params != nil && params.ConfigSdkVersion != nil {
		data.Set("Config.SdkVersion", *params.ConfigSdkVersion)
	}
	if params != nil && params.ConfigSkew != nil {
		data.Set("Config.Skew", fmt.Sprint(*params.ConfigSkew))
	}
	if params != nil && params.ConfigTimeStep != nil {
		data.Set("Config.TimeStep", fmt.Sprint(*params.ConfigTimeStep))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceEntityFactor{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateMessagingConfiguration'
type UpdateMessagingConfigurationParams struct {
	// The SID of the [Messaging Service](https://www.twilio.com/docs/sms/services/api) to be used to send SMS to the country of this configuration.
	MessagingServiceSid *string `json:"MessagingServiceSid,omitempty"`
}

func (params *UpdateMessagingConfigurationParams) SetMessagingServiceSid(MessagingServiceSid string) *UpdateMessagingConfigurationParams {
	params.MessagingServiceSid = &MessagingServiceSid
	return params
}

// Update a specific MessagingConfiguration
func (c *DefaultApiService) UpdateMessagingConfiguration(ServiceSid string, Country string, params *UpdateMessagingConfigurationParams) (*VerifyV2ServiceMessagingConfiguration, error) {
	path := "/v2/Services/{ServiceSid}/MessagingConfigurations/{Country}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Country"+"}", Country, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.MessagingServiceSid != nil {
		data.Set("MessagingServiceSid", *params.MessagingServiceSid)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceMessagingConfiguration{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateRateLimit'
type UpdateRateLimitParams struct {
	// Description of this Rate Limit
	Description *string `json:"Description,omitempty"`
}

func (params *UpdateRateLimitParams) SetDescription(Description string) *UpdateRateLimitParams {
	params.Description = &Description
	return params
}

// Update a specific Rate Limit.
func (c *DefaultApiService) UpdateRateLimit(ServiceSid string, Sid string, params *UpdateRateLimitParams) (*VerifyV2ServiceRateLimit, error) {
	path := "/v2/Services/{ServiceSid}/RateLimits/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Description != nil {
		data.Set("Description", *params.Description)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceRateLimit{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateService'
type UpdateServiceParams struct {
	// The length of the verification code to generate. Must be an integer value between 4 and 10, inclusive.
	CodeLength *int32 `json:"CodeLength,omitempty"`
	// Whether to allow sending verifications with a custom code instead of a randomly generated one. Not available for all customers.
	CustomCodeEnabled *bool `json:"CustomCodeEnabled,omitempty"`
	// Whether to add a privacy warning at the end of an SMS. **Disabled by default and applies only for SMS.**
	DoNotShareWarningEnabled *bool `json:"DoNotShareWarningEnabled,omitempty"`
	// Whether to ask the user to press a number before delivering the verify code in a phone call.
	DtmfInputRequired *bool `json:"DtmfInputRequired,omitempty"`
	// A descriptive string that you create to describe the verification service. It can be up to 30 characters long. **This value should not contain PII.**
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// Whether to perform a lookup with each verification started and return info about the phone number.
	LookupEnabled *bool `json:"LookupEnabled,omitempty"`
	// Whether to pass PSD2 transaction parameters when starting a verification.
	Psd2Enabled *bool `json:"Psd2Enabled,omitempty"`
	// Optional configuration for the Push factors. Set the APN Credential for this service. This will allow to send push notifications to iOS devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
	PushApnCredentialSid *string `json:"Push.ApnCredentialSid,omitempty"`
	// Optional configuration for the Push factors. Set the FCM Credential for this service. This will allow to send push notifications to Android devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
	PushFcmCredentialSid *string `json:"Push.FcmCredentialSid,omitempty"`
	// Optional configuration for the Push factors. If true, include the date in the Challenge's reponse. Otherwise, the date is omitted from the response. See [Challenge](https://www.twilio.com/docs/verify/api/challenge) resource’s details parameter for more info. Default: true
	PushIncludeDate *bool `json:"Push.IncludeDate,omitempty"`
	// Whether to skip sending SMS verifications to landlines. Requires `lookup_enabled`.
	SkipSmsToLandlines *bool `json:"SkipSmsToLandlines,omitempty"`
	// Optional configuration for the TOTP factors. Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. Defaults to 6
	TotpCodeLength *int32 `json:"Totp.CodeLength,omitempty"`
	// Optional configuration for the TOTP factors. Set TOTP Issuer for this service. This will allow to configure the issuer of the TOTP URI.
	TotpIssuer *string `json:"Totp.Issuer,omitempty"`
	// Optional configuration for the TOTP factors. The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. Defaults to 1
	TotpSkew *int32 `json:"Totp.Skew,omitempty"`
	// Optional configuration for the TOTP factors. Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. Defaults to 30 seconds
	TotpTimeStep *int32 `json:"Totp.TimeStep,omitempty"`
	// The name of an alternative text-to-speech service to use in phone calls. Applies only to TTS languages.
	TtsName *string `json:"TtsName,omitempty"`
}

func (params *UpdateServiceParams) SetCodeLength(CodeLength int32) *UpdateServiceParams {
	params.CodeLength = &CodeLength
	return params
}
func (params *UpdateServiceParams) SetCustomCodeEnabled(CustomCodeEnabled bool) *UpdateServiceParams {
	params.CustomCodeEnabled = &CustomCodeEnabled
	return params
}
func (params *UpdateServiceParams) SetDoNotShareWarningEnabled(DoNotShareWarningEnabled bool) *UpdateServiceParams {
	params.DoNotShareWarningEnabled = &DoNotShareWarningEnabled
	return params
}
func (params *UpdateServiceParams) SetDtmfInputRequired(DtmfInputRequired bool) *UpdateServiceParams {
	params.DtmfInputRequired = &DtmfInputRequired
	return params
}
func (params *UpdateServiceParams) SetFriendlyName(FriendlyName string) *UpdateServiceParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateServiceParams) SetLookupEnabled(LookupEnabled bool) *UpdateServiceParams {
	params.LookupEnabled = &LookupEnabled
	return params
}
func (params *UpdateServiceParams) SetPsd2Enabled(Psd2Enabled bool) *UpdateServiceParams {
	params.Psd2Enabled = &Psd2Enabled
	return params
}
func (params *UpdateServiceParams) SetPushApnCredentialSid(PushApnCredentialSid string) *UpdateServiceParams {
	params.PushApnCredentialSid = &PushApnCredentialSid
	return params
}
func (params *UpdateServiceParams) SetPushFcmCredentialSid(PushFcmCredentialSid string) *UpdateServiceParams {
	params.PushFcmCredentialSid = &PushFcmCredentialSid
	return params
}
func (params *UpdateServiceParams) SetPushIncludeDate(PushIncludeDate bool) *UpdateServiceParams {
	params.PushIncludeDate = &PushIncludeDate
	return params
}
func (params *UpdateServiceParams) SetSkipSmsToLandlines(SkipSmsToLandlines bool) *UpdateServiceParams {
	params.SkipSmsToLandlines = &SkipSmsToLandlines
	return params
}
func (params *UpdateServiceParams) SetTotpCodeLength(TotpCodeLength int32) *UpdateServiceParams {
	params.TotpCodeLength = &TotpCodeLength
	return params
}
func (params *UpdateServiceParams) SetTotpIssuer(TotpIssuer string) *UpdateServiceParams {
	params.TotpIssuer = &TotpIssuer
	return params
}
func (params *UpdateServiceParams) SetTotpSkew(TotpSkew int32) *UpdateServiceParams {
	params.TotpSkew = &TotpSkew
	return params
}
func (params *UpdateServiceParams) SetTotpTimeStep(TotpTimeStep int32) *UpdateServiceParams {
	params.TotpTimeStep = &TotpTimeStep
	return params
}
func (params *UpdateServiceParams) SetTtsName(TtsName string) *UpdateServiceParams {
	params.TtsName = &TtsName
	return params
}

// Update a specific Verification Service.
func (c *DefaultApiService) UpdateService(Sid string, params *UpdateServiceParams) (*VerifyV2Service, error) {
	path := "/v2/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.CodeLength != nil {
		data.Set("CodeLength", fmt.Sprint(*params.CodeLength))
	}
	if params != nil && params.CustomCodeEnabled != nil {
		data.Set("CustomCodeEnabled", fmt.Sprint(*params.CustomCodeEnabled))
	}
	if params != nil && params.DoNotShareWarningEnabled != nil {
		data.Set("DoNotShareWarningEnabled", fmt.Sprint(*params.DoNotShareWarningEnabled))
	}
	if params != nil && params.DtmfInputRequired != nil {
		data.Set("DtmfInputRequired", fmt.Sprint(*params.DtmfInputRequired))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.LookupEnabled != nil {
		data.Set("LookupEnabled", fmt.Sprint(*params.LookupEnabled))
	}
	if params != nil && params.Psd2Enabled != nil {
		data.Set("Psd2Enabled", fmt.Sprint(*params.Psd2Enabled))
	}
	if params != nil && params.PushApnCredentialSid != nil {
		data.Set("Push.ApnCredentialSid", *params.PushApnCredentialSid)
	}
	if params != nil && params.PushFcmCredentialSid != nil {
		data.Set("Push.FcmCredentialSid", *params.PushFcmCredentialSid)
	}
	if params != nil && params.PushIncludeDate != nil {
		data.Set("Push.IncludeDate", fmt.Sprint(*params.PushIncludeDate))
	}
	if params != nil && params.SkipSmsToLandlines != nil {
		data.Set("SkipSmsToLandlines", fmt.Sprint(*params.SkipSmsToLandlines))
	}
	if params != nil && params.TotpCodeLength != nil {
		data.Set("Totp.CodeLength", fmt.Sprint(*params.TotpCodeLength))
	}
	if params != nil && params.TotpIssuer != nil {
		data.Set("Totp.Issuer", *params.TotpIssuer)
	}
	if params != nil && params.TotpSkew != nil {
		data.Set("Totp.Skew", fmt.Sprint(*params.TotpSkew))
	}
	if params != nil && params.TotpTimeStep != nil {
		data.Set("Totp.TimeStep", fmt.Sprint(*params.TotpTimeStep))
	}
	if params != nil && params.TtsName != nil {
		data.Set("TtsName", *params.TtsName)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateVerification'
type UpdateVerificationParams struct {
	// The new status of the resource. Can be: `canceled` or `approved`.
	Status *string `json:"Status,omitempty"`
}

func (params *UpdateVerificationParams) SetStatus(Status string) *UpdateVerificationParams {
	params.Status = &Status
	return params
}

// Update a Verification status
func (c *DefaultApiService) UpdateVerification(ServiceSid string, Sid string, params *UpdateVerificationParams) (*VerifyV2ServiceVerification, error) {
	path := "/v2/Services/{ServiceSid}/Verifications/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceVerification{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// Optional parameters for the method 'UpdateWebhook'
type UpdateWebhookParams struct {
	// The array of events that this Webhook is subscribed to. Possible event types: `*, factor.deleted, factor.created, factor.verified, challenge.approved, challenge.denied`
	EventTypes *[]string `json:"EventTypes,omitempty"`
	// The string that you assigned to describe the webhook. **This value should not contain PII.**
	FriendlyName *string `json:"FriendlyName,omitempty"`
	// The webhook status. Default value is `enabled`. One of: `enabled` or `disabled`
	Status *string `json:"Status,omitempty"`
	// The URL associated with this Webhook.
	WebhookUrl *string `json:"WebhookUrl,omitempty"`
}

func (params *UpdateWebhookParams) SetEventTypes(EventTypes []string) *UpdateWebhookParams {
	params.EventTypes = &EventTypes
	return params
}
func (params *UpdateWebhookParams) SetFriendlyName(FriendlyName string) *UpdateWebhookParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateWebhookParams) SetStatus(Status string) *UpdateWebhookParams {
	params.Status = &Status
	return params
}
func (params *UpdateWebhookParams) SetWebhookUrl(WebhookUrl string) *UpdateWebhookParams {
	params.WebhookUrl = &WebhookUrl
	return params
}

func (c *DefaultApiService) UpdateWebhook(ServiceSid string, Sid string, params *UpdateWebhookParams) (*VerifyV2ServiceWebhook, error) {
	path := "/v2/Services/{ServiceSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EventTypes != nil {
		data.Set("EventTypes", strings.Join(*params.EventTypes, ","))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Status != nil {
		data.Set("Status", *params.Status)
	}
	if params != nil && params.WebhookUrl != nil {
		data.Set("WebhookUrl", *params.WebhookUrl)
	}

	resp, err := c.requestHandler.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &VerifyV2ServiceWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}
