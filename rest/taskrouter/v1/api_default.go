/*
 * Twilio - Taskrouter
 *
 * This is the public Twilio REST API.
 *
 * API version: 1.15.0
 * Contact: support@twilio.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"time"

	twilio "github.com/twilio/twilio-go/client"
)

type DefaultApiService struct {
	baseURL string
	client  twilio.BaseClient
}

func NewDefaultApiService(client twilio.BaseClient) *DefaultApiService {
	return &DefaultApiService{
		client:  client,
		baseURL: "https://taskrouter.twilio.com",
	}
}

// CreateActivityParams Optional parameters for the method 'CreateActivity'
type CreateActivityParams struct {
	Available    *bool   `json:"Available,omitempty"`
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *CreateActivityParams) SetAvailable(Available bool) *CreateActivityParams {
	params.Available = &Available
	return params
}
func (params *CreateActivityParams) SetFriendlyName(FriendlyName string) *CreateActivityParams {
	params.FriendlyName = &FriendlyName
	return params
}

// CreateActivity Method for CreateActivity
//
// param: WorkspaceSid The SID of the Workspace that the new Activity belongs to.
//
// param: optional nil or *CreateActivityParams - Optional Parameters:
//
// param: "Available" (bool) - Whether the Worker should be eligible to receive a Task when it occupies the Activity. A value of `true`, `1`, or `yes` specifies the Activity is available. All other values specify that it is not. The value cannot be changed after the Activity is created.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
//
// return: TaskrouterV1WorkspaceActivity
func (c *DefaultApiService) CreateActivity(WorkspaceSid string, params *CreateActivityParams) (*TaskrouterV1WorkspaceActivity, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Activities"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Available != nil {
		data.Set("Available", fmt.Sprint(*params.Available))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceActivity{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateTaskParams Optional parameters for the method 'CreateTask'
type CreateTaskParams struct {
	Attributes  *string `json:"Attributes,omitempty"`
	Priority    *int32  `json:"Priority,omitempty"`
	TaskChannel *string `json:"TaskChannel,omitempty"`
	Timeout     *int32  `json:"Timeout,omitempty"`
	WorkflowSid *string `json:"WorkflowSid,omitempty"`
}

func (params *CreateTaskParams) SetAttributes(Attributes string) *CreateTaskParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateTaskParams) SetPriority(Priority int32) *CreateTaskParams {
	params.Priority = &Priority
	return params
}
func (params *CreateTaskParams) SetTaskChannel(TaskChannel string) *CreateTaskParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *CreateTaskParams) SetTimeout(Timeout int32) *CreateTaskParams {
	params.Timeout = &Timeout
	return params
}
func (params *CreateTaskParams) SetWorkflowSid(WorkflowSid string) *CreateTaskParams {
	params.WorkflowSid = &WorkflowSid
	return params
}

// CreateTask Method for CreateTask
//
// param: WorkspaceSid The SID of the Workspace that the new Task belongs to.
//
// param: optional nil or *CreateTaskParams - Optional Parameters:
//
// param: "Attributes" (string) - A URL-encoded JSON string with the attributes of the new task. This value is passed to the Workflow's `assignment_callback_url` when the Task is assigned to a Worker. For example: `{ \\\"task_type\\\": \\\"call\\\", \\\"twilio_call_sid\\\": \\\"CAxxx\\\", \\\"customer_ticket_number\\\": \\\"12345\\\" }`.
//
// param: "Priority" (int32) - The priority to assign the new task and override the default. When supplied, the new Task will have this priority unless it matches a Workflow Target with a Priority set. When not supplied, the new Task will have the priority of the matching Workflow Target. Value can be 0 to 2^31^ (2,147,483,647).
//
// param: "TaskChannel" (string) - When MultiTasking is enabled, specify the TaskChannel by passing either its `unique_name` or `sid`. Default value is `default`.
//
// param: "Timeout" (int32) - The amount of time in seconds the new task can live before being assigned. Can be up to a maximum of 2 weeks (1,209,600 seconds). The default value is 24 hours (86,400 seconds). On timeout, the `task.canceled` event will fire with description `Task TTL Exceeded`.
//
// param: "WorkflowSid" (string) - The SID of the Workflow that you would like to handle routing for the new Task. If there is only one Workflow defined for the Workspace that you are posting the new task to, this parameter is optional.
//
// return: TaskrouterV1WorkspaceTask
func (c *DefaultApiService) CreateTask(WorkspaceSid string, params *CreateTaskParams) (*TaskrouterV1WorkspaceTask, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Priority != nil {
		data.Set("Priority", fmt.Sprint(*params.Priority))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.Timeout != nil {
		data.Set("Timeout", fmt.Sprint(*params.Timeout))
	}
	if params != nil && params.WorkflowSid != nil {
		data.Set("WorkflowSid", *params.WorkflowSid)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTask{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateTaskChannelParams Optional parameters for the method 'CreateTaskChannel'
type CreateTaskChannelParams struct {
	ChannelOptimizedRouting *bool   `json:"ChannelOptimizedRouting,omitempty"`
	FriendlyName            *string `json:"FriendlyName,omitempty"`
	UniqueName              *string `json:"UniqueName,omitempty"`
}

func (params *CreateTaskChannelParams) SetChannelOptimizedRouting(ChannelOptimizedRouting bool) *CreateTaskChannelParams {
	params.ChannelOptimizedRouting = &ChannelOptimizedRouting
	return params
}
func (params *CreateTaskChannelParams) SetFriendlyName(FriendlyName string) *CreateTaskChannelParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateTaskChannelParams) SetUniqueName(UniqueName string) *CreateTaskChannelParams {
	params.UniqueName = &UniqueName
	return params
}

// CreateTaskChannel Method for CreateTaskChannel
//
// param: WorkspaceSid The SID of the Workspace that the new Task Channel belongs to.
//
// param: optional nil or *CreateTaskChannelParams - Optional Parameters:
//
// param: "ChannelOptimizedRouting" (bool) - Whether the Task Channel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
//
// param: "UniqueName" (string) - An application-defined string that uniquely identifies the Task Channel, such as `voice` or `sms`.
//
// return: TaskrouterV1WorkspaceTaskChannel
func (c *DefaultApiService) CreateTaskChannel(WorkspaceSid string, params *CreateTaskChannelParams) (*TaskrouterV1WorkspaceTaskChannel, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskChannels"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ChannelOptimizedRouting != nil {
		data.Set("ChannelOptimizedRouting", fmt.Sprint(*params.ChannelOptimizedRouting))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateTaskQueueParams Optional parameters for the method 'CreateTaskQueue'
type CreateTaskQueueParams struct {
	AssignmentActivitySid  *string `json:"AssignmentActivitySid,omitempty"`
	FriendlyName           *string `json:"FriendlyName,omitempty"`
	MaxReservedWorkers     *int32  `json:"MaxReservedWorkers,omitempty"`
	ReservationActivitySid *string `json:"ReservationActivitySid,omitempty"`
	TargetWorkers          *string `json:"TargetWorkers,omitempty"`
	TaskOrder              *string `json:"TaskOrder,omitempty"`
}

func (params *CreateTaskQueueParams) SetAssignmentActivitySid(AssignmentActivitySid string) *CreateTaskQueueParams {
	params.AssignmentActivitySid = &AssignmentActivitySid
	return params
}
func (params *CreateTaskQueueParams) SetFriendlyName(FriendlyName string) *CreateTaskQueueParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateTaskQueueParams) SetMaxReservedWorkers(MaxReservedWorkers int32) *CreateTaskQueueParams {
	params.MaxReservedWorkers = &MaxReservedWorkers
	return params
}
func (params *CreateTaskQueueParams) SetReservationActivitySid(ReservationActivitySid string) *CreateTaskQueueParams {
	params.ReservationActivitySid = &ReservationActivitySid
	return params
}
func (params *CreateTaskQueueParams) SetTargetWorkers(TargetWorkers string) *CreateTaskQueueParams {
	params.TargetWorkers = &TargetWorkers
	return params
}
func (params *CreateTaskQueueParams) SetTaskOrder(TaskOrder string) *CreateTaskQueueParams {
	params.TaskOrder = &TaskOrder
	return params
}

// CreateTaskQueue Method for CreateTaskQueue
//
// param: WorkspaceSid The SID of the Workspace that the new TaskQueue belongs to.
//
// param: optional nil or *CreateTaskQueueParams - Optional Parameters:
//
// param: "AssignmentActivitySid" (string) - The SID of the Activity to assign Workers when a task is assigned to them.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
//
// param: "MaxReservedWorkers" (int32) - The maximum number of Workers to reserve for the assignment of a Task in the queue. Can be an integer between 1 and 50, inclusive and defaults to 1.
//
// param: "ReservationActivitySid" (string) - The SID of the Activity to assign Workers when a task is reserved for them.
//
// param: "TargetWorkers" (string) - A string that describes the Worker selection criteria for any Tasks that enter the TaskQueue. For example, `'\\\"language\\\" == \\\"spanish\\\"'`. The default value is `1==1`. If this value is empty, Tasks will wait in the TaskQueue until they are deleted or moved to another TaskQueue. For more information about Worker selection, see [Describing Worker selection criteria](https://www.twilio.com/docs/taskrouter/api/taskqueues#target-workers).
//
// param: "TaskOrder" (string) - How Tasks will be assigned to Workers. Set this parameter to `LIFO` to assign most recently created Task first or FIFO to assign the oldest Task first. Default is `FIFO`. [Click here](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo) to learn more.
//
// return: TaskrouterV1WorkspaceTaskQueue
func (c *DefaultApiService) CreateTaskQueue(WorkspaceSid string, params *CreateTaskQueueParams) (*TaskrouterV1WorkspaceTaskQueue, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AssignmentActivitySid != nil {
		data.Set("AssignmentActivitySid", *params.AssignmentActivitySid)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MaxReservedWorkers != nil {
		data.Set("MaxReservedWorkers", fmt.Sprint(*params.MaxReservedWorkers))
	}
	if params != nil && params.ReservationActivitySid != nil {
		data.Set("ReservationActivitySid", *params.ReservationActivitySid)
	}
	if params != nil && params.TargetWorkers != nil {
		data.Set("TargetWorkers", *params.TargetWorkers)
	}
	if params != nil && params.TaskOrder != nil {
		data.Set("TaskOrder", *params.TaskOrder)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskQueue{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateWorkerParams Optional parameters for the method 'CreateWorker'
type CreateWorkerParams struct {
	ActivitySid  *string `json:"ActivitySid,omitempty"`
	Attributes   *string `json:"Attributes,omitempty"`
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *CreateWorkerParams) SetActivitySid(ActivitySid string) *CreateWorkerParams {
	params.ActivitySid = &ActivitySid
	return params
}
func (params *CreateWorkerParams) SetAttributes(Attributes string) *CreateWorkerParams {
	params.Attributes = &Attributes
	return params
}
func (params *CreateWorkerParams) SetFriendlyName(FriendlyName string) *CreateWorkerParams {
	params.FriendlyName = &FriendlyName
	return params
}

// CreateWorker Method for CreateWorker
//
// param: WorkspaceSid The SID of the Workspace that the new Worker belongs to.
//
// param: optional nil or *CreateWorkerParams - Optional Parameters:
//
// param: "ActivitySid" (string) - The SID of a valid Activity that will describe the new Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information. If not provided, the new Worker's initial state is the `default_activity_sid` configured on the Workspace.
//
// param: "Attributes" (string) - A valid JSON string that describes the new Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the new Worker. It can be up to 64 characters long.
//
// return: TaskrouterV1WorkspaceWorker
func (c *DefaultApiService) CreateWorker(WorkspaceSid string, params *CreateWorkerParams) (*TaskrouterV1WorkspaceWorker, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ActivitySid != nil {
		data.Set("ActivitySid", *params.ActivitySid)
	}
	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorker{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateWorkflowParams Optional parameters for the method 'CreateWorkflow'
type CreateWorkflowParams struct {
	AssignmentCallbackUrl         *string `json:"AssignmentCallbackUrl,omitempty"`
	Configuration                 *string `json:"Configuration,omitempty"`
	FallbackAssignmentCallbackUrl *string `json:"FallbackAssignmentCallbackUrl,omitempty"`
	FriendlyName                  *string `json:"FriendlyName,omitempty"`
	TaskReservationTimeout        *int32  `json:"TaskReservationTimeout,omitempty"`
}

func (params *CreateWorkflowParams) SetAssignmentCallbackUrl(AssignmentCallbackUrl string) *CreateWorkflowParams {
	params.AssignmentCallbackUrl = &AssignmentCallbackUrl
	return params
}
func (params *CreateWorkflowParams) SetConfiguration(Configuration string) *CreateWorkflowParams {
	params.Configuration = &Configuration
	return params
}
func (params *CreateWorkflowParams) SetFallbackAssignmentCallbackUrl(FallbackAssignmentCallbackUrl string) *CreateWorkflowParams {
	params.FallbackAssignmentCallbackUrl = &FallbackAssignmentCallbackUrl
	return params
}
func (params *CreateWorkflowParams) SetFriendlyName(FriendlyName string) *CreateWorkflowParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateWorkflowParams) SetTaskReservationTimeout(TaskReservationTimeout int32) *CreateWorkflowParams {
	params.TaskReservationTimeout = &TaskReservationTimeout
	return params
}

// CreateWorkflow Method for CreateWorkflow
//
// param: WorkspaceSid The SID of the Workspace that the new Workflow to create belongs to.
//
// param: optional nil or *CreateWorkflowParams - Optional Parameters:
//
// param: "AssignmentCallbackUrl" (string) - The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
//
// param: "Configuration" (string) - A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
//
// param: "FallbackAssignmentCallbackUrl" (string) - The URL that we should call when a call to the `assignment_callback_url` fails.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
//
// param: "TaskReservationTimeout" (int32) - How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
//
// return: TaskrouterV1WorkspaceWorkflow
func (c *DefaultApiService) CreateWorkflow(WorkspaceSid string, params *CreateWorkflowParams) (*TaskrouterV1WorkspaceWorkflow, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AssignmentCallbackUrl != nil {
		data.Set("AssignmentCallbackUrl", *params.AssignmentCallbackUrl)
	}
	if params != nil && params.Configuration != nil {
		data.Set("Configuration", *params.Configuration)
	}
	if params != nil && params.FallbackAssignmentCallbackUrl != nil {
		data.Set("FallbackAssignmentCallbackUrl", *params.FallbackAssignmentCallbackUrl)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.TaskReservationTimeout != nil {
		data.Set("TaskReservationTimeout", fmt.Sprint(*params.TaskReservationTimeout))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkflow{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateWorkspaceParams Optional parameters for the method 'CreateWorkspace'
type CreateWorkspaceParams struct {
	EventCallbackUrl     *string `json:"EventCallbackUrl,omitempty"`
	EventsFilter         *string `json:"EventsFilter,omitempty"`
	FriendlyName         *string `json:"FriendlyName,omitempty"`
	MultiTaskEnabled     *bool   `json:"MultiTaskEnabled,omitempty"`
	PrioritizeQueueOrder *string `json:"PrioritizeQueueOrder,omitempty"`
	Template             *string `json:"Template,omitempty"`
}

func (params *CreateWorkspaceParams) SetEventCallbackUrl(EventCallbackUrl string) *CreateWorkspaceParams {
	params.EventCallbackUrl = &EventCallbackUrl
	return params
}
func (params *CreateWorkspaceParams) SetEventsFilter(EventsFilter string) *CreateWorkspaceParams {
	params.EventsFilter = &EventsFilter
	return params
}
func (params *CreateWorkspaceParams) SetFriendlyName(FriendlyName string) *CreateWorkspaceParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *CreateWorkspaceParams) SetMultiTaskEnabled(MultiTaskEnabled bool) *CreateWorkspaceParams {
	params.MultiTaskEnabled = &MultiTaskEnabled
	return params
}
func (params *CreateWorkspaceParams) SetPrioritizeQueueOrder(PrioritizeQueueOrder string) *CreateWorkspaceParams {
	params.PrioritizeQueueOrder = &PrioritizeQueueOrder
	return params
}
func (params *CreateWorkspaceParams) SetTemplate(Template string) *CreateWorkspaceParams {
	params.Template = &Template
	return params
}

// CreateWorkspace Method for CreateWorkspace
//
// param: optional nil or *CreateWorkspaceParams - Optional Parameters:
//
// param: "EventCallbackUrl" (string) - The URL we should call when an event occurs. If provided, the Workspace will publish events to this URL, for example, to collect data for reporting. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information.
//
// param: "EventsFilter" (string) - The list of Workspace events for which to call event_callback_url. For example, if `EventsFilter=task.created, task.canceled, worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Workspace resource. It can be up to 64 characters long. For example: `Customer Support` or `2014 Election Campaign`.
//
// param: "MultiTaskEnabled" (bool) - Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. The default is `false`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. Otherwise, each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
//
// param: "PrioritizeQueueOrder" (string) - The type of TaskQueue to prioritize when Workers are receiving Tasks from both types of TaskQueues. Can be: `LIFO` or `FIFO` and the default is `FIFO`. For more information, see [Queue Ordering](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo).
//
// param: "Template" (string) - An available template name. Can be: `NONE` or `FIFO` and the default is `NONE`. Pre-configures the Workspace with the Workflow and Activities specified in the template. `NONE` will create a Workspace with only a set of default activities. `FIFO` will configure TaskRouter with a set of default activities and a single TaskQueue for first-in, first-out distribution, which can be useful when you are getting started with TaskRouter.
//
// return: TaskrouterV1Workspace
func (c *DefaultApiService) CreateWorkspace(params *CreateWorkspaceParams) (*TaskrouterV1Workspace, error) {
	path := "/v1/Workspaces"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EventCallbackUrl != nil {
		data.Set("EventCallbackUrl", *params.EventCallbackUrl)
	}
	if params != nil && params.EventsFilter != nil {
		data.Set("EventsFilter", *params.EventsFilter)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MultiTaskEnabled != nil {
		data.Set("MultiTaskEnabled", fmt.Sprint(*params.MultiTaskEnabled))
	}
	if params != nil && params.PrioritizeQueueOrder != nil {
		data.Set("PrioritizeQueueOrder", *params.PrioritizeQueueOrder)
	}
	if params != nil && params.Template != nil {
		data.Set("Template", *params.Template)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1Workspace{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// DeleteActivity Method for DeleteActivity
//
// param: WorkspaceSid The SID of the Workspace with the Activity resources to delete.
//
// param: Sid The SID of the Activity resource to delete.
//
func (c *DefaultApiService) DeleteActivity(WorkspaceSid string, Sid string) error {
	path := "/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteTaskParams Optional parameters for the method 'DeleteTask'
type DeleteTaskParams struct {
	IfMatch *string `json:"If-Match,omitempty"`
}

func (params *DeleteTaskParams) SetIfMatch(IfMatch string) *DeleteTaskParams {
	params.IfMatch = &IfMatch
	return params
}

// DeleteTask Method for DeleteTask
//
// param: WorkspaceSid The SID of the Workspace with the Task to delete.
//
// param: Sid The SID of the Task resource to delete.
//
// param: optional nil or *DeleteTaskParams - Optional Parameters:
//
// param: "IfMatch" (string) - If provided, deletes this Task if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
//
func (c *DefaultApiService) DeleteTask(WorkspaceSid string, Sid string, params *DeleteTaskParams) error {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.IfMatch != nil {
		headers["If-Match"] = *params.IfMatch
	}

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteTaskChannel Method for DeleteTaskChannel
//
// param: WorkspaceSid The SID of the Workspace with the Task Channel to delete.
//
// param: Sid The SID of the Task Channel resource to delete.
//
func (c *DefaultApiService) DeleteTaskChannel(WorkspaceSid string, Sid string) error {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteTaskQueue Method for DeleteTaskQueue
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to delete.
//
// param: Sid The SID of the TaskQueue resource to delete.
//
func (c *DefaultApiService) DeleteTaskQueue(WorkspaceSid string, Sid string) error {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteWorker Method for DeleteWorker
//
// param: WorkspaceSid The SID of the Workspace with the Worker to delete.
//
// param: Sid The SID of the Worker resource to delete.
//
func (c *DefaultApiService) DeleteWorker(WorkspaceSid string, Sid string) error {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteWorkflow Method for DeleteWorkflow
//
// param: WorkspaceSid The SID of the Workspace with the Workflow to delete.
//
// param: Sid The SID of the Workflow resource to delete.
//
func (c *DefaultApiService) DeleteWorkflow(WorkspaceSid string, Sid string) error {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteWorkspace Method for DeleteWorkspace
//
// param: Sid The SID of the Workspace resource to delete.
//
func (c *DefaultApiService) DeleteWorkspace(Sid string) error {
	path := "/v1/Workspaces/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// FetchActivity Method for FetchActivity
//
// param: WorkspaceSid The SID of the Workspace with the Activity resources to fetch.
//
// param: Sid The SID of the Activity resource to fetch.
//
// return: TaskrouterV1WorkspaceActivity
func (c *DefaultApiService) FetchActivity(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceActivity, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceActivity{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchEvent Method for FetchEvent
//
// param: WorkspaceSid The SID of the Workspace with the Event to fetch.
//
// param: Sid The SID of the Event resource to fetch.
//
// return: TaskrouterV1WorkspaceEvent
func (c *DefaultApiService) FetchEvent(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceEvent, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Events/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceEvent{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTask Method for FetchTask
//
// param: WorkspaceSid The SID of the Workspace with the Task to fetch.
//
// param: Sid The SID of the Task resource to fetch.
//
// return: TaskrouterV1WorkspaceTask
func (c *DefaultApiService) FetchTask(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceTask, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTask{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTaskChannel Method for FetchTaskChannel
//
// param: WorkspaceSid The SID of the Workspace with the Task Channel to fetch.
//
// param: Sid The SID of the Task Channel resource to fetch.
//
// return: TaskrouterV1WorkspaceTaskChannel
func (c *DefaultApiService) FetchTaskChannel(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceTaskChannel, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTaskQueue Method for FetchTaskQueue
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to fetch.
//
// param: Sid The SID of the TaskQueue resource to fetch.
//
// return: TaskrouterV1WorkspaceTaskQueue
func (c *DefaultApiService) FetchTaskQueue(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceTaskQueue, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskQueue{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTaskQueueCumulativeStatisticsParams Optional parameters for the method 'FetchTaskQueueCumulativeStatistics'
type FetchTaskQueueCumulativeStatisticsParams struct {
	EndDate         *time.Time `json:"EndDate,omitempty"`
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
}

func (params *FetchTaskQueueCumulativeStatisticsParams) SetEndDate(EndDate time.Time) *FetchTaskQueueCumulativeStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchTaskQueueCumulativeStatisticsParams) SetMinutes(Minutes int32) *FetchTaskQueueCumulativeStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchTaskQueueCumulativeStatisticsParams) SetStartDate(StartDate time.Time) *FetchTaskQueueCumulativeStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchTaskQueueCumulativeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchTaskQueueCumulativeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *FetchTaskQueueCumulativeStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *FetchTaskQueueCumulativeStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}

// FetchTaskQueueCumulativeStatistics Method for FetchTaskQueueCumulativeStatistics
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to fetch.
//
// param: TaskQueueSid The SID of the TaskQueue for which to fetch statistics.
//
// param: optional nil or *FetchTaskQueueCumulativeStatisticsParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default is 15 minutes.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "TaskChannel" (string) - Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
//
// return: TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics
func (c *DefaultApiService) FetchTaskQueueCumulativeStatistics(WorkspaceSid string, TaskQueueSid string, params *FetchTaskQueueCumulativeStatisticsParams) (*TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/CumulativeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"TaskQueueSid"+"}", TaskQueueSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTaskQueueRealTimeStatisticsParams Optional parameters for the method 'FetchTaskQueueRealTimeStatistics'
type FetchTaskQueueRealTimeStatisticsParams struct {
	TaskChannel *string `json:"TaskChannel,omitempty"`
}

func (params *FetchTaskQueueRealTimeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchTaskQueueRealTimeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchTaskQueueRealTimeStatistics Method for FetchTaskQueueRealTimeStatistics
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to fetch.
//
// param: TaskQueueSid The SID of the TaskQueue for which to fetch statistics.
//
// param: optional nil or *FetchTaskQueueRealTimeStatisticsParams - Optional Parameters:
//
// param: "TaskChannel" (string) - The TaskChannel for which to fetch statistics. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics
func (c *DefaultApiService) FetchTaskQueueRealTimeStatistics(WorkspaceSid string, TaskQueueSid string, params *FetchTaskQueueRealTimeStatisticsParams) (*TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/RealTimeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"TaskQueueSid"+"}", TaskQueueSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTaskQueueStatisticsParams Optional parameters for the method 'FetchTaskQueueStatistics'
type FetchTaskQueueStatisticsParams struct {
	EndDate         *time.Time `json:"EndDate,omitempty"`
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
}

func (params *FetchTaskQueueStatisticsParams) SetEndDate(EndDate time.Time) *FetchTaskQueueStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchTaskQueueStatisticsParams) SetMinutes(Minutes int32) *FetchTaskQueueStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchTaskQueueStatisticsParams) SetStartDate(StartDate time.Time) *FetchTaskQueueStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchTaskQueueStatisticsParams) SetTaskChannel(TaskChannel string) *FetchTaskQueueStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *FetchTaskQueueStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *FetchTaskQueueStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}

// FetchTaskQueueStatistics Method for FetchTaskQueueStatistics
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to fetch.
//
// param: TaskQueueSid The SID of the TaskQueue for which to fetch statistics.
//
// param: optional nil or *FetchTaskQueueStatisticsParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default is 15 minutes.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "TaskChannel" (string) - Only calculate real-time and cumulative statistics for the specified TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
//
// return: TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics
func (c *DefaultApiService) FetchTaskQueueStatistics(WorkspaceSid string, TaskQueueSid string, params *FetchTaskQueueStatisticsParams) (*TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/Statistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"TaskQueueSid"+"}", TaskQueueSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchTaskReservation Method for FetchTaskReservation
//
// param: WorkspaceSid The SID of the Workspace with the TaskReservation resource to fetch.
//
// param: TaskSid The SID of the reserved Task resource with the TaskReservation resource to fetch.
//
// param: Sid The SID of the TaskReservation resource to fetch.
//
// return: TaskrouterV1WorkspaceTaskTaskReservation
func (c *DefaultApiService) FetchTaskReservation(WorkspaceSid string, TaskSid string, Sid string) (*TaskrouterV1WorkspaceTaskTaskReservation, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"TaskSid"+"}", TaskSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskTaskReservation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorker Method for FetchWorker
//
// param: WorkspaceSid The SID of the Workspace with the Worker to fetch.
//
// param: Sid The SID of the Worker resource to fetch.
//
// return: TaskrouterV1WorkspaceWorker
func (c *DefaultApiService) FetchWorker(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceWorker, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorker{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkerChannel Method for FetchWorkerChannel
//
// param: WorkspaceSid The SID of the Workspace with the WorkerChannel to fetch.
//
// param: WorkerSid The SID of the Worker with the WorkerChannel to fetch.
//
// param: Sid The SID of the WorkerChannel to fetch.
//
// return: TaskrouterV1WorkspaceWorkerWorkerChannel
func (c *DefaultApiService) FetchWorkerChannel(WorkspaceSid string, WorkerSid string, Sid string) (*TaskrouterV1WorkspaceWorkerWorkerChannel, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkerChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkerInstanceStatisticsParams Optional parameters for the method 'FetchWorkerInstanceStatistics'
type FetchWorkerInstanceStatisticsParams struct {
	Minutes     *int32     `json:"Minutes,omitempty"`
	StartDate   *time.Time `json:"StartDate,omitempty"`
	EndDate     *time.Time `json:"EndDate,omitempty"`
	TaskChannel *string    `json:"TaskChannel,omitempty"`
}

func (params *FetchWorkerInstanceStatisticsParams) SetMinutes(Minutes int32) *FetchWorkerInstanceStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkerInstanceStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkerInstanceStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkerInstanceStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkerInstanceStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkerInstanceStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkerInstanceStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchWorkerInstanceStatistics Method for FetchWorkerInstanceStatistics
//
// param: WorkspaceSid The SID of the Workspace with the WorkerChannel to fetch.
//
// param: WorkerSid The SID of the Worker with the WorkerChannel to fetch.
//
// param: optional nil or *FetchWorkerInstanceStatisticsParams - Optional Parameters:
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "EndDate" (time.Time) - Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "TaskChannel" (string) - Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics
func (c *DefaultApiService) FetchWorkerInstanceStatistics(WorkspaceSid string, WorkerSid string, params *FetchWorkerInstanceStatisticsParams) (*TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Statistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkerReservation Method for FetchWorkerReservation
//
// param: WorkspaceSid The SID of the Workspace with the WorkerReservation resource to fetch.
//
// param: WorkerSid The SID of the reserved Worker resource with the WorkerReservation resource to fetch.
//
// param: Sid The SID of the WorkerReservation resource to fetch.
//
// return: TaskrouterV1WorkspaceWorkerWorkerReservation
func (c *DefaultApiService) FetchWorkerReservation(WorkspaceSid string, WorkerSid string, Sid string) (*TaskrouterV1WorkspaceWorkerWorkerReservation, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkerReservation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkerStatisticsParams Optional parameters for the method 'FetchWorkerStatistics'
type FetchWorkerStatisticsParams struct {
	Minutes       *int32     `json:"Minutes,omitempty"`
	StartDate     *time.Time `json:"StartDate,omitempty"`
	EndDate       *time.Time `json:"EndDate,omitempty"`
	TaskQueueSid  *string    `json:"TaskQueueSid,omitempty"`
	TaskQueueName *string    `json:"TaskQueueName,omitempty"`
	FriendlyName  *string    `json:"FriendlyName,omitempty"`
	TaskChannel   *string    `json:"TaskChannel,omitempty"`
}

func (params *FetchWorkerStatisticsParams) SetMinutes(Minutes int32) *FetchWorkerStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkerStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkerStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkerStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkerStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkerStatisticsParams) SetTaskQueueSid(TaskQueueSid string) *FetchWorkerStatisticsParams {
	params.TaskQueueSid = &TaskQueueSid
	return params
}
func (params *FetchWorkerStatisticsParams) SetTaskQueueName(TaskQueueName string) *FetchWorkerStatisticsParams {
	params.TaskQueueName = &TaskQueueName
	return params
}
func (params *FetchWorkerStatisticsParams) SetFriendlyName(FriendlyName string) *FetchWorkerStatisticsParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *FetchWorkerStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkerStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchWorkerStatistics Method for FetchWorkerStatistics
//
// param: WorkspaceSid The SID of the Workspace with the Worker to fetch.
//
// param: optional nil or *FetchWorkerStatisticsParams - Optional Parameters:
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "TaskQueueSid" (string) - The SID of the TaskQueue for which to fetch Worker statistics.
//
// param: "TaskQueueName" (string) - The `friendly_name` of the TaskQueue for which to fetch Worker statistics.
//
// param: "FriendlyName" (string) - Only include Workers with `friendly_name` values that match this parameter.
//
// param: "TaskChannel" (string) - Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceWorkerWorkerStatistics
func (c *DefaultApiService) FetchWorkerStatistics(WorkspaceSid string, params *FetchWorkerStatisticsParams) (*TaskrouterV1WorkspaceWorkerWorkerStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/Statistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskQueueSid != nil {
		data.Set("TaskQueueSid", *params.TaskQueueSid)
	}
	if params != nil && params.TaskQueueName != nil {
		data.Set("TaskQueueName", *params.TaskQueueName)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkerStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkersCumulativeStatisticsParams Optional parameters for the method 'FetchWorkersCumulativeStatistics'
type FetchWorkersCumulativeStatisticsParams struct {
	EndDate     *time.Time `json:"EndDate,omitempty"`
	Minutes     *int32     `json:"Minutes,omitempty"`
	StartDate   *time.Time `json:"StartDate,omitempty"`
	TaskChannel *string    `json:"TaskChannel,omitempty"`
}

func (params *FetchWorkersCumulativeStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkersCumulativeStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkersCumulativeStatisticsParams) SetMinutes(Minutes int32) *FetchWorkersCumulativeStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkersCumulativeStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkersCumulativeStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkersCumulativeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkersCumulativeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchWorkersCumulativeStatistics Method for FetchWorkersCumulativeStatistics
//
// param: WorkspaceSid The SID of the Workspace with the resource to fetch.
//
// param: optional nil or *FetchWorkersCumulativeStatisticsParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "TaskChannel" (string) - Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics
func (c *DefaultApiService) FetchWorkersCumulativeStatistics(WorkspaceSid string, params *FetchWorkersCumulativeStatisticsParams) (*TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/CumulativeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkersRealTimeStatisticsParams Optional parameters for the method 'FetchWorkersRealTimeStatistics'
type FetchWorkersRealTimeStatisticsParams struct {
	TaskChannel *string `json:"TaskChannel,omitempty"`
}

func (params *FetchWorkersRealTimeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkersRealTimeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchWorkersRealTimeStatistics Method for FetchWorkersRealTimeStatistics
//
// param: WorkspaceSid The SID of the Workspace with the resource to fetch.
//
// param: optional nil or *FetchWorkersRealTimeStatisticsParams - Optional Parameters:
//
// param: "TaskChannel" (string) - Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics
func (c *DefaultApiService) FetchWorkersRealTimeStatistics(WorkspaceSid string, params *FetchWorkersRealTimeStatisticsParams) (*TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/RealTimeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkflow Method for FetchWorkflow
//
// param: WorkspaceSid The SID of the Workspace with the Workflow to fetch.
//
// param: Sid The SID of the Workflow resource to fetch.
//
// return: TaskrouterV1WorkspaceWorkflow
func (c *DefaultApiService) FetchWorkflow(WorkspaceSid string, Sid string) (*TaskrouterV1WorkspaceWorkflow, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkflow{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkflowCumulativeStatisticsParams Optional parameters for the method 'FetchWorkflowCumulativeStatistics'
type FetchWorkflowCumulativeStatisticsParams struct {
	EndDate         *time.Time `json:"EndDate,omitempty"`
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
}

func (params *FetchWorkflowCumulativeStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkflowCumulativeStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkflowCumulativeStatisticsParams) SetMinutes(Minutes int32) *FetchWorkflowCumulativeStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkflowCumulativeStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkflowCumulativeStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkflowCumulativeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkflowCumulativeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *FetchWorkflowCumulativeStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *FetchWorkflowCumulativeStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}

// FetchWorkflowCumulativeStatistics Method for FetchWorkflowCumulativeStatistics
//
// param: WorkspaceSid The SID of the Workspace with the resource to fetch.
//
// param: WorkflowSid Returns the list of Tasks that are being controlled by the Workflow with the specified Sid value.
//
// param: optional nil or *FetchWorkflowCumulativeStatisticsParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "TaskChannel" (string) - Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
//
// return: TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics
func (c *DefaultApiService) FetchWorkflowCumulativeStatistics(WorkspaceSid string, WorkflowSid string, params *FetchWorkflowCumulativeStatisticsParams) (*TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/CumulativeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkflowSid"+"}", WorkflowSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkflowRealTimeStatisticsParams Optional parameters for the method 'FetchWorkflowRealTimeStatistics'
type FetchWorkflowRealTimeStatisticsParams struct {
	TaskChannel *string `json:"TaskChannel,omitempty"`
}

func (params *FetchWorkflowRealTimeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkflowRealTimeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchWorkflowRealTimeStatistics Method for FetchWorkflowRealTimeStatistics
//
// param: WorkspaceSid The SID of the Workspace with the Workflow to fetch.
//
// param: WorkflowSid Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.
//
// param: optional nil or *FetchWorkflowRealTimeStatisticsParams - Optional Parameters:
//
// param: "TaskChannel" (string) - Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics
func (c *DefaultApiService) FetchWorkflowRealTimeStatistics(WorkspaceSid string, WorkflowSid string, params *FetchWorkflowRealTimeStatisticsParams) (*TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/RealTimeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkflowSid"+"}", WorkflowSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkflowStatisticsParams Optional parameters for the method 'FetchWorkflowStatistics'
type FetchWorkflowStatisticsParams struct {
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	EndDate         *time.Time `json:"EndDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
}

func (params *FetchWorkflowStatisticsParams) SetMinutes(Minutes int32) *FetchWorkflowStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkflowStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkflowStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkflowStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkflowStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkflowStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkflowStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *FetchWorkflowStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *FetchWorkflowStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}

// FetchWorkflowStatistics Method for FetchWorkflowStatistics
//
// param: WorkspaceSid The SID of the Workspace with the Workflow to fetch.
//
// param: WorkflowSid Returns the list of Tasks that are being controlled by the Workflow with the specified SID value.
//
// param: optional nil or *FetchWorkflowStatisticsParams - Optional Parameters:
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "TaskChannel" (string) - Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
//
// return: TaskrouterV1WorkspaceWorkflowWorkflowStatistics
func (c *DefaultApiService) FetchWorkflowStatistics(WorkspaceSid string, WorkflowSid string, params *FetchWorkflowStatisticsParams) (*TaskrouterV1WorkspaceWorkflowWorkflowStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/Statistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkflowSid"+"}", WorkflowSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkflowWorkflowStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkspace Method for FetchWorkspace
//
// param: Sid The SID of the Workspace resource to fetch.
//
// return: TaskrouterV1Workspace
func (c *DefaultApiService) FetchWorkspace(Sid string) (*TaskrouterV1Workspace, error) {
	path := "/v1/Workspaces/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1Workspace{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkspaceCumulativeStatisticsParams Optional parameters for the method 'FetchWorkspaceCumulativeStatistics'
type FetchWorkspaceCumulativeStatisticsParams struct {
	EndDate         *time.Time `json:"EndDate,omitempty"`
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
}

func (params *FetchWorkspaceCumulativeStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkspaceCumulativeStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkspaceCumulativeStatisticsParams) SetMinutes(Minutes int32) *FetchWorkspaceCumulativeStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkspaceCumulativeStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkspaceCumulativeStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkspaceCumulativeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkspaceCumulativeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *FetchWorkspaceCumulativeStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *FetchWorkspaceCumulativeStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}

// FetchWorkspaceCumulativeStatistics Method for FetchWorkspaceCumulativeStatistics
//
// param: WorkspaceSid The SID of the Workspace to fetch.
//
// param: optional nil or *FetchWorkspaceCumulativeStatisticsParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only include usage that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "TaskChannel" (string) - Only calculate cumulative statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
//
// return: TaskrouterV1WorkspaceWorkspaceCumulativeStatistics
func (c *DefaultApiService) FetchWorkspaceCumulativeStatistics(WorkspaceSid string, params *FetchWorkspaceCumulativeStatisticsParams) (*TaskrouterV1WorkspaceWorkspaceCumulativeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/CumulativeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkspaceCumulativeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkspaceRealTimeStatisticsParams Optional parameters for the method 'FetchWorkspaceRealTimeStatistics'
type FetchWorkspaceRealTimeStatisticsParams struct {
	TaskChannel *string `json:"TaskChannel,omitempty"`
}

func (params *FetchWorkspaceRealTimeStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkspaceRealTimeStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}

// FetchWorkspaceRealTimeStatistics Method for FetchWorkspaceRealTimeStatistics
//
// param: WorkspaceSid The SID of the Workspace to fetch.
//
// param: optional nil or *FetchWorkspaceRealTimeStatisticsParams - Optional Parameters:
//
// param: "TaskChannel" (string) - Only calculate real-time statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceWorkspaceRealTimeStatistics
func (c *DefaultApiService) FetchWorkspaceRealTimeStatistics(WorkspaceSid string, params *FetchWorkspaceRealTimeStatisticsParams) (*TaskrouterV1WorkspaceWorkspaceRealTimeStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/RealTimeStatistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkspaceRealTimeStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// FetchWorkspaceStatisticsParams Optional parameters for the method 'FetchWorkspaceStatistics'
type FetchWorkspaceStatisticsParams struct {
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	EndDate         *time.Time `json:"EndDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
}

func (params *FetchWorkspaceStatisticsParams) SetMinutes(Minutes int32) *FetchWorkspaceStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *FetchWorkspaceStatisticsParams) SetStartDate(StartDate time.Time) *FetchWorkspaceStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *FetchWorkspaceStatisticsParams) SetEndDate(EndDate time.Time) *FetchWorkspaceStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *FetchWorkspaceStatisticsParams) SetTaskChannel(TaskChannel string) *FetchWorkspaceStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *FetchWorkspaceStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *FetchWorkspaceStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}

// FetchWorkspaceStatistics Method for FetchWorkspaceStatistics
//
// param: WorkspaceSid The SID of the Workspace to fetch.
//
// param: optional nil or *FetchWorkspaceStatisticsParams - Optional Parameters:
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default 15 minutes. This is helpful for displaying statistics for the last 15 minutes, 240 minutes (4 hours), and 480 minutes (8 hours) to see trends.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "TaskChannel" (string) - Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed. For example, `5,30` would show splits of Tasks that were canceled or accepted before and after 5 seconds and before and after 30 seconds. This can be used to show short abandoned Tasks or Tasks that failed to meet an SLA.
//
// return: TaskrouterV1WorkspaceWorkspaceStatistics
func (c *DefaultApiService) FetchWorkspaceStatistics(WorkspaceSid string, params *FetchWorkspaceStatisticsParams) (*TaskrouterV1WorkspaceWorkspaceStatistics, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Statistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkspaceStatistics{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListActivityParams Optional parameters for the method 'ListActivity'
type ListActivityParams struct {
	FriendlyName *string `json:"FriendlyName,omitempty"`
	Available    *string `json:"Available,omitempty"`
	PageSize     *int32  `json:"PageSize,omitempty"`
}

func (params *ListActivityParams) SetFriendlyName(FriendlyName string) *ListActivityParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListActivityParams) SetAvailable(Available string) *ListActivityParams {
	params.Available = &Available
	return params
}
func (params *ListActivityParams) SetPageSize(PageSize int32) *ListActivityParams {
	params.PageSize = &PageSize
	return params
}

// ListActivity Method for ListActivity
//
// param: WorkspaceSid The SID of the Workspace with the Activity resources to read.
//
// param: optional nil or *ListActivityParams - Optional Parameters:
//
// param: "FriendlyName" (string) - The `friendly_name` of the Activity resources to read.
//
// param: "Available" (string) - Whether return only Activity resources that are available or unavailable. A value of `true` returns only available activities. Values of '1' or `yes` also indicate `true`. All other values represent `false` and return activities that are unavailable.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListActivityResponse
func (c *DefaultApiService) ListActivity(WorkspaceSid string, params *ListActivityParams) (*ListActivityResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Activities"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Available != nil {
		data.Set("Available", *params.Available)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListActivityResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListEventParams Optional parameters for the method 'ListEvent'
type ListEventParams struct {
	EndDate        *time.Time `json:"EndDate,omitempty"`
	EventType      *string    `json:"EventType,omitempty"`
	Minutes        *int32     `json:"Minutes,omitempty"`
	ReservationSid *string    `json:"ReservationSid,omitempty"`
	StartDate      *time.Time `json:"StartDate,omitempty"`
	TaskQueueSid   *string    `json:"TaskQueueSid,omitempty"`
	TaskSid        *string    `json:"TaskSid,omitempty"`
	WorkerSid      *string    `json:"WorkerSid,omitempty"`
	WorkflowSid    *string    `json:"WorkflowSid,omitempty"`
	TaskChannel    *string    `json:"TaskChannel,omitempty"`
	Sid            *string    `json:"Sid,omitempty"`
	PageSize       *int32     `json:"PageSize,omitempty"`
}

func (params *ListEventParams) SetEndDate(EndDate time.Time) *ListEventParams {
	params.EndDate = &EndDate
	return params
}
func (params *ListEventParams) SetEventType(EventType string) *ListEventParams {
	params.EventType = &EventType
	return params
}
func (params *ListEventParams) SetMinutes(Minutes int32) *ListEventParams {
	params.Minutes = &Minutes
	return params
}
func (params *ListEventParams) SetReservationSid(ReservationSid string) *ListEventParams {
	params.ReservationSid = &ReservationSid
	return params
}
func (params *ListEventParams) SetStartDate(StartDate time.Time) *ListEventParams {
	params.StartDate = &StartDate
	return params
}
func (params *ListEventParams) SetTaskQueueSid(TaskQueueSid string) *ListEventParams {
	params.TaskQueueSid = &TaskQueueSid
	return params
}
func (params *ListEventParams) SetTaskSid(TaskSid string) *ListEventParams {
	params.TaskSid = &TaskSid
	return params
}
func (params *ListEventParams) SetWorkerSid(WorkerSid string) *ListEventParams {
	params.WorkerSid = &WorkerSid
	return params
}
func (params *ListEventParams) SetWorkflowSid(WorkflowSid string) *ListEventParams {
	params.WorkflowSid = &WorkflowSid
	return params
}
func (params *ListEventParams) SetTaskChannel(TaskChannel string) *ListEventParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *ListEventParams) SetSid(Sid string) *ListEventParams {
	params.Sid = &Sid
	return params
}
func (params *ListEventParams) SetPageSize(PageSize int32) *ListEventParams {
	params.PageSize = &PageSize
	return params
}

// ListEvent Method for ListEvent
//
// param: WorkspaceSid The SID of the Workspace with the Events to read. Returns only the Events that pertain to the specified Workspace.
//
// param: optional nil or *ListEventParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only include Events that occurred on or before this date, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "EventType" (string) - The type of Events to read. Returns only Events of the type specified.
//
// param: "Minutes" (int32) - The period of events to read in minutes. Returns only Events that occurred since this many minutes in the past. The default is `15` minutes. Task Attributes for Events occuring more 43,200 minutes ago will be redacted.
//
// param: "ReservationSid" (string) - The SID of the Reservation with the Events to read. Returns only Events that pertain to the specified Reservation.
//
// param: "StartDate" (time.Time) - Only include Events from on or after this date and time, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. Task Attributes for Events older than 30 days will be redacted.
//
// param: "TaskQueueSid" (string) - The SID of the TaskQueue with the Events to read. Returns only the Events that pertain to the specified TaskQueue.
//
// param: "TaskSid" (string) - The SID of the Task with the Events to read. Returns only the Events that pertain to the specified Task.
//
// param: "WorkerSid" (string) - The SID of the Worker with the Events to read. Returns only the Events that pertain to the specified Worker.
//
// param: "WorkflowSid" (string) - The SID of the Workflow with the Events to read. Returns only the Events that pertain to the specified Workflow.
//
// param: "TaskChannel" (string) - The TaskChannel with the Events to read. Returns only the Events that pertain to the specified TaskChannel.
//
// param: "Sid" (string) - The SID of the Event resource to read.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListEventResponse
func (c *DefaultApiService) ListEvent(WorkspaceSid string, params *ListEventParams) (*ListEventResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Events"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.EventType != nil {
		data.Set("EventType", *params.EventType)
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.ReservationSid != nil {
		data.Set("ReservationSid", *params.ReservationSid)
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskQueueSid != nil {
		data.Set("TaskQueueSid", *params.TaskQueueSid)
	}
	if params != nil && params.TaskSid != nil {
		data.Set("TaskSid", *params.TaskSid)
	}
	if params != nil && params.WorkerSid != nil {
		data.Set("WorkerSid", *params.WorkerSid)
	}
	if params != nil && params.WorkflowSid != nil {
		data.Set("WorkflowSid", *params.WorkflowSid)
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.Sid != nil {
		data.Set("Sid", *params.Sid)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListEventResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListTaskParams Optional parameters for the method 'ListTask'
type ListTaskParams struct {
	Priority               *int32    `json:"Priority,omitempty"`
	AssignmentStatus       *[]string `json:"AssignmentStatus,omitempty"`
	WorkflowSid            *string   `json:"WorkflowSid,omitempty"`
	WorkflowName           *string   `json:"WorkflowName,omitempty"`
	TaskQueueSid           *string   `json:"TaskQueueSid,omitempty"`
	TaskQueueName          *string   `json:"TaskQueueName,omitempty"`
	EvaluateTaskAttributes *string   `json:"EvaluateTaskAttributes,omitempty"`
	Ordering               *string   `json:"Ordering,omitempty"`
	HasAddons              *bool     `json:"HasAddons,omitempty"`
	PageSize               *int32    `json:"PageSize,omitempty"`
}

func (params *ListTaskParams) SetPriority(Priority int32) *ListTaskParams {
	params.Priority = &Priority
	return params
}
func (params *ListTaskParams) SetAssignmentStatus(AssignmentStatus []string) *ListTaskParams {
	params.AssignmentStatus = &AssignmentStatus
	return params
}
func (params *ListTaskParams) SetWorkflowSid(WorkflowSid string) *ListTaskParams {
	params.WorkflowSid = &WorkflowSid
	return params
}
func (params *ListTaskParams) SetWorkflowName(WorkflowName string) *ListTaskParams {
	params.WorkflowName = &WorkflowName
	return params
}
func (params *ListTaskParams) SetTaskQueueSid(TaskQueueSid string) *ListTaskParams {
	params.TaskQueueSid = &TaskQueueSid
	return params
}
func (params *ListTaskParams) SetTaskQueueName(TaskQueueName string) *ListTaskParams {
	params.TaskQueueName = &TaskQueueName
	return params
}
func (params *ListTaskParams) SetEvaluateTaskAttributes(EvaluateTaskAttributes string) *ListTaskParams {
	params.EvaluateTaskAttributes = &EvaluateTaskAttributes
	return params
}
func (params *ListTaskParams) SetOrdering(Ordering string) *ListTaskParams {
	params.Ordering = &Ordering
	return params
}
func (params *ListTaskParams) SetHasAddons(HasAddons bool) *ListTaskParams {
	params.HasAddons = &HasAddons
	return params
}
func (params *ListTaskParams) SetPageSize(PageSize int32) *ListTaskParams {
	params.PageSize = &PageSize
	return params
}

// ListTask Method for ListTask
//
// param: WorkspaceSid The SID of the Workspace with the Tasks to read.
//
// param: optional nil or *ListTaskParams - Optional Parameters:
//
// param: "Priority" (int32) - The priority value of the Tasks to read. Returns the list of all Tasks in the Workspace with the specified priority.
//
// param: "AssignmentStatus" ([]string) - The `assignment_status` of the Tasks you want to read. Can be: `pending`, `reserved`, `assigned`, `canceled`, `wrapping`, or `completed`. Returns all Tasks in the Workspace with the specified `assignment_status`.
//
// param: "WorkflowSid" (string) - The SID of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this SID.
//
// param: "WorkflowName" (string) - The friendly name of the Workflow with the Tasks to read. Returns the Tasks controlled by the Workflow identified by this friendly name.
//
// param: "TaskQueueSid" (string) - The SID of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this SID.
//
// param: "TaskQueueName" (string) - The `friendly_name` of the TaskQueue with the Tasks to read. Returns the Tasks waiting in the TaskQueue identified by this friendly name.
//
// param: "EvaluateTaskAttributes" (string) - The attributes of the Tasks to read. Returns the Tasks that match the attributes specified in this parameter.
//
// param: "Ordering" (string) - How to order the returned Task resources. y default, Tasks are sorted by ascending DateCreated. This value is specified as: `Attribute:Order`, where `Attribute` can be either `Priority` or `DateCreated` and `Order` can be either `asc` or `desc`. For example, `Priority:desc` returns Tasks ordered in descending order of their Priority. Multiple sort orders can be specified in a comma-separated list such as `Priority:desc,DateCreated:asc`, which returns the Tasks in descending Priority order and ascending DateCreated Order.
//
// param: "HasAddons" (bool) - Whether to read Tasks with addons. If `true`, returns only Tasks with addons. If `false`, returns only Tasks without addons.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListTaskResponse
func (c *DefaultApiService) ListTask(WorkspaceSid string, params *ListTaskParams) (*ListTaskResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Priority != nil {
		data.Set("Priority", fmt.Sprint(*params.Priority))
	}
	if params != nil && params.AssignmentStatus != nil {
		data.Set("AssignmentStatus", strings.Join(*params.AssignmentStatus, ","))
	}
	if params != nil && params.WorkflowSid != nil {
		data.Set("WorkflowSid", *params.WorkflowSid)
	}
	if params != nil && params.WorkflowName != nil {
		data.Set("WorkflowName", *params.WorkflowName)
	}
	if params != nil && params.TaskQueueSid != nil {
		data.Set("TaskQueueSid", *params.TaskQueueSid)
	}
	if params != nil && params.TaskQueueName != nil {
		data.Set("TaskQueueName", *params.TaskQueueName)
	}
	if params != nil && params.EvaluateTaskAttributes != nil {
		data.Set("EvaluateTaskAttributes", *params.EvaluateTaskAttributes)
	}
	if params != nil && params.Ordering != nil {
		data.Set("Ordering", *params.Ordering)
	}
	if params != nil && params.HasAddons != nil {
		data.Set("HasAddons", fmt.Sprint(*params.HasAddons))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListTaskResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListTaskChannelParams Optional parameters for the method 'ListTaskChannel'
type ListTaskChannelParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListTaskChannelParams) SetPageSize(PageSize int32) *ListTaskChannelParams {
	params.PageSize = &PageSize
	return params
}

// ListTaskChannel Method for ListTaskChannel
//
// param: WorkspaceSid The SID of the Workspace with the Task Channel to read.
//
// param: optional nil or *ListTaskChannelParams - Optional Parameters:
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListTaskChannelResponse
func (c *DefaultApiService) ListTaskChannel(WorkspaceSid string, params *ListTaskChannelParams) (*ListTaskChannelResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskChannels"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListTaskChannelResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListTaskQueueParams Optional parameters for the method 'ListTaskQueue'
type ListTaskQueueParams struct {
	FriendlyName             *string `json:"FriendlyName,omitempty"`
	EvaluateWorkerAttributes *string `json:"EvaluateWorkerAttributes,omitempty"`
	WorkerSid                *string `json:"WorkerSid,omitempty"`
	PageSize                 *int32  `json:"PageSize,omitempty"`
}

func (params *ListTaskQueueParams) SetFriendlyName(FriendlyName string) *ListTaskQueueParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListTaskQueueParams) SetEvaluateWorkerAttributes(EvaluateWorkerAttributes string) *ListTaskQueueParams {
	params.EvaluateWorkerAttributes = &EvaluateWorkerAttributes
	return params
}
func (params *ListTaskQueueParams) SetWorkerSid(WorkerSid string) *ListTaskQueueParams {
	params.WorkerSid = &WorkerSid
	return params
}
func (params *ListTaskQueueParams) SetPageSize(PageSize int32) *ListTaskQueueParams {
	params.PageSize = &PageSize
	return params
}

// ListTaskQueue Method for ListTaskQueue
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to read.
//
// param: optional nil or *ListTaskQueueParams - Optional Parameters:
//
// param: "FriendlyName" (string) - The `friendly_name` of the TaskQueue resources to read.
//
// param: "EvaluateWorkerAttributes" (string) - The attributes of the Workers to read. Returns the TaskQueues with Workers that match the attributes specified in this parameter.
//
// param: "WorkerSid" (string) - The SID of the Worker with the TaskQueue resources to read.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListTaskQueueResponse
func (c *DefaultApiService) ListTaskQueue(WorkspaceSid string, params *ListTaskQueueParams) (*ListTaskQueueResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.EvaluateWorkerAttributes != nil {
		data.Set("EvaluateWorkerAttributes", *params.EvaluateWorkerAttributes)
	}
	if params != nil && params.WorkerSid != nil {
		data.Set("WorkerSid", *params.WorkerSid)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListTaskQueueResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListTaskQueuesStatisticsParams Optional parameters for the method 'ListTaskQueuesStatistics'
type ListTaskQueuesStatisticsParams struct {
	EndDate         *time.Time `json:"EndDate,omitempty"`
	FriendlyName    *string    `json:"FriendlyName,omitempty"`
	Minutes         *int32     `json:"Minutes,omitempty"`
	StartDate       *time.Time `json:"StartDate,omitempty"`
	TaskChannel     *string    `json:"TaskChannel,omitempty"`
	SplitByWaitTime *string    `json:"SplitByWaitTime,omitempty"`
	PageSize        *int32     `json:"PageSize,omitempty"`
}

func (params *ListTaskQueuesStatisticsParams) SetEndDate(EndDate time.Time) *ListTaskQueuesStatisticsParams {
	params.EndDate = &EndDate
	return params
}
func (params *ListTaskQueuesStatisticsParams) SetFriendlyName(FriendlyName string) *ListTaskQueuesStatisticsParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListTaskQueuesStatisticsParams) SetMinutes(Minutes int32) *ListTaskQueuesStatisticsParams {
	params.Minutes = &Minutes
	return params
}
func (params *ListTaskQueuesStatisticsParams) SetStartDate(StartDate time.Time) *ListTaskQueuesStatisticsParams {
	params.StartDate = &StartDate
	return params
}
func (params *ListTaskQueuesStatisticsParams) SetTaskChannel(TaskChannel string) *ListTaskQueuesStatisticsParams {
	params.TaskChannel = &TaskChannel
	return params
}
func (params *ListTaskQueuesStatisticsParams) SetSplitByWaitTime(SplitByWaitTime string) *ListTaskQueuesStatisticsParams {
	params.SplitByWaitTime = &SplitByWaitTime
	return params
}
func (params *ListTaskQueuesStatisticsParams) SetPageSize(PageSize int32) *ListTaskQueuesStatisticsParams {
	params.PageSize = &PageSize
	return params
}

// ListTaskQueuesStatistics Method for ListTaskQueuesStatistics
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueues to read.
//
// param: optional nil or *ListTaskQueuesStatisticsParams - Optional Parameters:
//
// param: "EndDate" (time.Time) - Only calculate statistics from this date and time and earlier, specified in GMT as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time.
//
// param: "FriendlyName" (string) - The `friendly_name` of the TaskQueue statistics to read.
//
// param: "Minutes" (int32) - Only calculate statistics since this many minutes in the past. The default is 15 minutes.
//
// param: "StartDate" (time.Time) - Only calculate statistics from this date and time and later, specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
//
// param: "TaskChannel" (string) - Only calculate statistics on this TaskChannel. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// param: "SplitByWaitTime" (string) - A comma separated list of values that describes the thresholds, in seconds, to calculate statistics on. For each threshold specified, the number of Tasks canceled and reservations accepted above and below the specified thresholds in seconds are computed.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListTaskQueuesStatisticsResponse
func (c *DefaultApiService) ListTaskQueuesStatistics(WorkspaceSid string, params *ListTaskQueuesStatisticsParams) (*ListTaskQueuesStatisticsResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/Statistics"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.EndDate != nil {
		data.Set("EndDate", fmt.Sprint((*params.EndDate).Format(time.RFC3339)))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Minutes != nil {
		data.Set("Minutes", fmt.Sprint(*params.Minutes))
	}
	if params != nil && params.StartDate != nil {
		data.Set("StartDate", fmt.Sprint((*params.StartDate).Format(time.RFC3339)))
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}
	if params != nil && params.SplitByWaitTime != nil {
		data.Set("SplitByWaitTime", *params.SplitByWaitTime)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListTaskQueuesStatisticsResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListTaskReservationParams Optional parameters for the method 'ListTaskReservation'
type ListTaskReservationParams struct {
	ReservationStatus *string `json:"ReservationStatus,omitempty"`
	PageSize          *int32  `json:"PageSize,omitempty"`
}

func (params *ListTaskReservationParams) SetReservationStatus(ReservationStatus string) *ListTaskReservationParams {
	params.ReservationStatus = &ReservationStatus
	return params
}
func (params *ListTaskReservationParams) SetPageSize(PageSize int32) *ListTaskReservationParams {
	params.PageSize = &PageSize
	return params
}

// ListTaskReservation Method for ListTaskReservation
//
// param: WorkspaceSid The SID of the Workspace with the TaskReservation resources to read.
//
// param: TaskSid The SID of the reserved Task resource with the TaskReservation resources to read.
//
// param: optional nil or *ListTaskReservationParams - Optional Parameters:
//
// param: "ReservationStatus" (string) - Returns the list of reservations for a task with a specified ReservationStatus.  Can be: `pending`, `accepted`, `rejected`, or `timeout`.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListTaskReservationResponse
func (c *DefaultApiService) ListTaskReservation(WorkspaceSid string, TaskSid string, params *ListTaskReservationParams) (*ListTaskReservationResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"TaskSid"+"}", TaskSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ReservationStatus != nil {
		data.Set("ReservationStatus", *params.ReservationStatus)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListTaskReservationResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListWorkerParams Optional parameters for the method 'ListWorker'
type ListWorkerParams struct {
	ActivityName            *string `json:"ActivityName,omitempty"`
	ActivitySid             *string `json:"ActivitySid,omitempty"`
	Available               *string `json:"Available,omitempty"`
	FriendlyName            *string `json:"FriendlyName,omitempty"`
	TargetWorkersExpression *string `json:"TargetWorkersExpression,omitempty"`
	TaskQueueName           *string `json:"TaskQueueName,omitempty"`
	TaskQueueSid            *string `json:"TaskQueueSid,omitempty"`
	PageSize                *int32  `json:"PageSize,omitempty"`
}

func (params *ListWorkerParams) SetActivityName(ActivityName string) *ListWorkerParams {
	params.ActivityName = &ActivityName
	return params
}
func (params *ListWorkerParams) SetActivitySid(ActivitySid string) *ListWorkerParams {
	params.ActivitySid = &ActivitySid
	return params
}
func (params *ListWorkerParams) SetAvailable(Available string) *ListWorkerParams {
	params.Available = &Available
	return params
}
func (params *ListWorkerParams) SetFriendlyName(FriendlyName string) *ListWorkerParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListWorkerParams) SetTargetWorkersExpression(TargetWorkersExpression string) *ListWorkerParams {
	params.TargetWorkersExpression = &TargetWorkersExpression
	return params
}
func (params *ListWorkerParams) SetTaskQueueName(TaskQueueName string) *ListWorkerParams {
	params.TaskQueueName = &TaskQueueName
	return params
}
func (params *ListWorkerParams) SetTaskQueueSid(TaskQueueSid string) *ListWorkerParams {
	params.TaskQueueSid = &TaskQueueSid
	return params
}
func (params *ListWorkerParams) SetPageSize(PageSize int32) *ListWorkerParams {
	params.PageSize = &PageSize
	return params
}

// ListWorker Method for ListWorker
//
// param: WorkspaceSid The SID of the Workspace with the Workers to read.
//
// param: optional nil or *ListWorkerParams - Optional Parameters:
//
// param: "ActivityName" (string) - The `activity_name` of the Worker resources to read.
//
// param: "ActivitySid" (string) - The `activity_sid` of the Worker resources to read.
//
// param: "Available" (string) - Whether to return only Worker resources that are available or unavailable. Can be `true`, `1`, or `yes` to return Worker resources that are available, and `false`, or any value returns the Worker resources that are not available.
//
// param: "FriendlyName" (string) - The `friendly_name` of the Worker resources to read.
//
// param: "TargetWorkersExpression" (string) - Filter by Workers that would match an expression on a TaskQueue. This is helpful for debugging which Workers would match a potential queue.
//
// param: "TaskQueueName" (string) - The `friendly_name` of the TaskQueue that the Workers to read are eligible for.
//
// param: "TaskQueueSid" (string) - The SID of the TaskQueue that the Workers to read are eligible for.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListWorkerResponse
func (c *DefaultApiService) ListWorker(WorkspaceSid string, params *ListWorkerParams) (*ListWorkerResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ActivityName != nil {
		data.Set("ActivityName", *params.ActivityName)
	}
	if params != nil && params.ActivitySid != nil {
		data.Set("ActivitySid", *params.ActivitySid)
	}
	if params != nil && params.Available != nil {
		data.Set("Available", *params.Available)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.TargetWorkersExpression != nil {
		data.Set("TargetWorkersExpression", *params.TargetWorkersExpression)
	}
	if params != nil && params.TaskQueueName != nil {
		data.Set("TaskQueueName", *params.TaskQueueName)
	}
	if params != nil && params.TaskQueueSid != nil {
		data.Set("TaskQueueSid", *params.TaskQueueSid)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListWorkerResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListWorkerChannelParams Optional parameters for the method 'ListWorkerChannel'
type ListWorkerChannelParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

func (params *ListWorkerChannelParams) SetPageSize(PageSize int32) *ListWorkerChannelParams {
	params.PageSize = &PageSize
	return params
}

// ListWorkerChannel Method for ListWorkerChannel
//
// param: WorkspaceSid The SID of the Workspace with the WorkerChannels to read.
//
// param: WorkerSid The SID of the Worker with the WorkerChannels to read.
//
// param: optional nil or *ListWorkerChannelParams - Optional Parameters:
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListWorkerChannelResponse
func (c *DefaultApiService) ListWorkerChannel(WorkspaceSid string, WorkerSid string, params *ListWorkerChannelParams) (*ListWorkerChannelResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListWorkerChannelResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListWorkerReservationParams Optional parameters for the method 'ListWorkerReservation'
type ListWorkerReservationParams struct {
	ReservationStatus *string `json:"ReservationStatus,omitempty"`
	PageSize          *int32  `json:"PageSize,omitempty"`
}

func (params *ListWorkerReservationParams) SetReservationStatus(ReservationStatus string) *ListWorkerReservationParams {
	params.ReservationStatus = &ReservationStatus
	return params
}
func (params *ListWorkerReservationParams) SetPageSize(PageSize int32) *ListWorkerReservationParams {
	params.PageSize = &PageSize
	return params
}

// ListWorkerReservation Method for ListWorkerReservation
//
// param: WorkspaceSid The SID of the Workspace with the WorkerReservation resources to read.
//
// param: WorkerSid The SID of the reserved Worker resource with the WorkerReservation resources to read.
//
// param: optional nil or *ListWorkerReservationParams - Optional Parameters:
//
// param: "ReservationStatus" (string) - Returns the list of reservations for a worker with a specified ReservationStatus. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListWorkerReservationResponse
func (c *DefaultApiService) ListWorkerReservation(WorkspaceSid string, WorkerSid string, params *ListWorkerReservationParams) (*ListWorkerReservationResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ReservationStatus != nil {
		data.Set("ReservationStatus", *params.ReservationStatus)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListWorkerReservationResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListWorkflowParams Optional parameters for the method 'ListWorkflow'
type ListWorkflowParams struct {
	FriendlyName *string `json:"FriendlyName,omitempty"`
	PageSize     *int32  `json:"PageSize,omitempty"`
}

func (params *ListWorkflowParams) SetFriendlyName(FriendlyName string) *ListWorkflowParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListWorkflowParams) SetPageSize(PageSize int32) *ListWorkflowParams {
	params.PageSize = &PageSize
	return params
}

// ListWorkflow Method for ListWorkflow
//
// param: WorkspaceSid The SID of the Workspace with the Workflow to read.
//
// param: optional nil or *ListWorkflowParams - Optional Parameters:
//
// param: "FriendlyName" (string) - The `friendly_name` of the Workflow resources to read.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListWorkflowResponse
func (c *DefaultApiService) ListWorkflow(WorkspaceSid string, params *ListWorkflowParams) (*ListWorkflowResponse, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListWorkflowResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListWorkspaceParams Optional parameters for the method 'ListWorkspace'
type ListWorkspaceParams struct {
	FriendlyName *string `json:"FriendlyName,omitempty"`
	PageSize     *int32  `json:"PageSize,omitempty"`
}

func (params *ListWorkspaceParams) SetFriendlyName(FriendlyName string) *ListWorkspaceParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *ListWorkspaceParams) SetPageSize(PageSize int32) *ListWorkspaceParams {
	params.PageSize = &PageSize
	return params
}

// ListWorkspace Method for ListWorkspace
//
// param: optional nil or *ListWorkspaceParams - Optional Parameters:
//
// param: "FriendlyName" (string) - The `friendly_name` of the Workspace resources to read. For example `Customer Support` or `2014 Election Campaign`.
//
// param: "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
//
// return: ListWorkspaceResponse
func (c *DefaultApiService) ListWorkspace(params *ListWorkspaceParams) (*ListWorkspaceResponse, error) {
	path := "/v1/Workspaces"

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListWorkspaceResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateActivityParams Optional parameters for the method 'UpdateActivity'
type UpdateActivityParams struct {
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

func (params *UpdateActivityParams) SetFriendlyName(FriendlyName string) *UpdateActivityParams {
	params.FriendlyName = &FriendlyName
	return params
}

// UpdateActivity Method for UpdateActivity
//
// param: WorkspaceSid The SID of the Workspace with the Activity resources to update.
//
// param: Sid The SID of the Activity resource to update.
//
// param: optional nil or *UpdateActivityParams - Optional Parameters:
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Activity resource. It can be up to 64 characters long. These names are used to calculate and expose statistics about Workers, and provide visibility into the state of each Worker. Examples of friendly names include: `on-call`, `break`, and `email`.
//
// return: TaskrouterV1WorkspaceActivity
func (c *DefaultApiService) UpdateActivity(WorkspaceSid string, Sid string, params *UpdateActivityParams) (*TaskrouterV1WorkspaceActivity, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceActivity{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateTaskParams Optional parameters for the method 'UpdateTask'
type UpdateTaskParams struct {
	IfMatch          *string `json:"If-Match,omitempty"`
	AssignmentStatus *string `json:"AssignmentStatus,omitempty"`
	Attributes       *string `json:"Attributes,omitempty"`
	Priority         *int32  `json:"Priority,omitempty"`
	Reason           *string `json:"Reason,omitempty"`
	TaskChannel      *string `json:"TaskChannel,omitempty"`
}

func (params *UpdateTaskParams) SetIfMatch(IfMatch string) *UpdateTaskParams {
	params.IfMatch = &IfMatch
	return params
}
func (params *UpdateTaskParams) SetAssignmentStatus(AssignmentStatus string) *UpdateTaskParams {
	params.AssignmentStatus = &AssignmentStatus
	return params
}
func (params *UpdateTaskParams) SetAttributes(Attributes string) *UpdateTaskParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateTaskParams) SetPriority(Priority int32) *UpdateTaskParams {
	params.Priority = &Priority
	return params
}
func (params *UpdateTaskParams) SetReason(Reason string) *UpdateTaskParams {
	params.Reason = &Reason
	return params
}
func (params *UpdateTaskParams) SetTaskChannel(TaskChannel string) *UpdateTaskParams {
	params.TaskChannel = &TaskChannel
	return params
}

// UpdateTask Method for UpdateTask
//
// param: WorkspaceSid The SID of the Workspace with the Task to update.
//
// param: Sid The SID of the Task resource to update.
//
// param: optional nil or *UpdateTaskParams - Optional Parameters:
//
// param: "IfMatch" (string) - If provided, applies this mutation if (and only if) the [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header of the Task matches the provided value. This matches the semantics of (and is implemented with) the HTTP [If-Match header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match).
//
// param: "AssignmentStatus" (string) - The new status of the task. Can be: `canceled`, to cancel a Task that is currently `pending` or `reserved`; `wrapping`, to move the Task to wrapup state; or `completed`, to move a Task to the completed state.
//
// param: "Attributes" (string) - The JSON string that describes the custom attributes of the task.
//
// param: "Priority" (int32) - The Task's new priority value. When supplied, the Task takes on the specified priority unless it matches a Workflow Target with a Priority set. Value can be 0 to 2^31^ (2,147,483,647).
//
// param: "Reason" (string) - The reason that the Task was canceled or completed. This parameter is required only if the Task is canceled or completed. Setting this value queues the task for deletion and logs the reason.
//
// param: "TaskChannel" (string) - When MultiTasking is enabled, specify the TaskChannel with the task to update. Can be the TaskChannel's SID or its `unique_name`, such as `voice`, `sms`, or `default`.
//
// return: TaskrouterV1WorkspaceTask
func (c *DefaultApiService) UpdateTask(WorkspaceSid string, Sid string, params *UpdateTaskParams) (*TaskrouterV1WorkspaceTask, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AssignmentStatus != nil {
		data.Set("AssignmentStatus", *params.AssignmentStatus)
	}
	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Priority != nil {
		data.Set("Priority", fmt.Sprint(*params.Priority))
	}
	if params != nil && params.Reason != nil {
		data.Set("Reason", *params.Reason)
	}
	if params != nil && params.TaskChannel != nil {
		data.Set("TaskChannel", *params.TaskChannel)
	}

	if params != nil && params.IfMatch != nil {
		headers["If-Match"] = *params.IfMatch
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTask{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateTaskChannelParams Optional parameters for the method 'UpdateTaskChannel'
type UpdateTaskChannelParams struct {
	ChannelOptimizedRouting *bool   `json:"ChannelOptimizedRouting,omitempty"`
	FriendlyName            *string `json:"FriendlyName,omitempty"`
}

func (params *UpdateTaskChannelParams) SetChannelOptimizedRouting(ChannelOptimizedRouting bool) *UpdateTaskChannelParams {
	params.ChannelOptimizedRouting = &ChannelOptimizedRouting
	return params
}
func (params *UpdateTaskChannelParams) SetFriendlyName(FriendlyName string) *UpdateTaskChannelParams {
	params.FriendlyName = &FriendlyName
	return params
}

// UpdateTaskChannel Method for UpdateTaskChannel
//
// param: WorkspaceSid The SID of the Workspace with the Task Channel to update.
//
// param: Sid The SID of the Task Channel resource to update.
//
// param: optional nil or *UpdateTaskChannelParams - Optional Parameters:
//
// param: "ChannelOptimizedRouting" (bool) - Whether the TaskChannel should prioritize Workers that have been idle. If `true`, Workers that have been idle the longest are prioritized.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Task Channel. It can be up to 64 characters long.
//
// return: TaskrouterV1WorkspaceTaskChannel
func (c *DefaultApiService) UpdateTaskChannel(WorkspaceSid string, Sid string, params *UpdateTaskChannelParams) (*TaskrouterV1WorkspaceTaskChannel, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ChannelOptimizedRouting != nil {
		data.Set("ChannelOptimizedRouting", fmt.Sprint(*params.ChannelOptimizedRouting))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateTaskQueueParams Optional parameters for the method 'UpdateTaskQueue'
type UpdateTaskQueueParams struct {
	AssignmentActivitySid  *string `json:"AssignmentActivitySid,omitempty"`
	FriendlyName           *string `json:"FriendlyName,omitempty"`
	MaxReservedWorkers     *int32  `json:"MaxReservedWorkers,omitempty"`
	ReservationActivitySid *string `json:"ReservationActivitySid,omitempty"`
	TargetWorkers          *string `json:"TargetWorkers,omitempty"`
	TaskOrder              *string `json:"TaskOrder,omitempty"`
}

func (params *UpdateTaskQueueParams) SetAssignmentActivitySid(AssignmentActivitySid string) *UpdateTaskQueueParams {
	params.AssignmentActivitySid = &AssignmentActivitySid
	return params
}
func (params *UpdateTaskQueueParams) SetFriendlyName(FriendlyName string) *UpdateTaskQueueParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateTaskQueueParams) SetMaxReservedWorkers(MaxReservedWorkers int32) *UpdateTaskQueueParams {
	params.MaxReservedWorkers = &MaxReservedWorkers
	return params
}
func (params *UpdateTaskQueueParams) SetReservationActivitySid(ReservationActivitySid string) *UpdateTaskQueueParams {
	params.ReservationActivitySid = &ReservationActivitySid
	return params
}
func (params *UpdateTaskQueueParams) SetTargetWorkers(TargetWorkers string) *UpdateTaskQueueParams {
	params.TargetWorkers = &TargetWorkers
	return params
}
func (params *UpdateTaskQueueParams) SetTaskOrder(TaskOrder string) *UpdateTaskQueueParams {
	params.TaskOrder = &TaskOrder
	return params
}

// UpdateTaskQueue Method for UpdateTaskQueue
//
// param: WorkspaceSid The SID of the Workspace with the TaskQueue to update.
//
// param: Sid The SID of the TaskQueue resource to update.
//
// param: optional nil or *UpdateTaskQueueParams - Optional Parameters:
//
// param: "AssignmentActivitySid" (string) - The SID of the Activity to assign Workers when a task is assigned for them.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the TaskQueue. For example `Support-Tier 1`, `Sales`, or `Escalation`.
//
// param: "MaxReservedWorkers" (int32) - The maximum number of Workers to create reservations for the assignment of a task while in the queue. Maximum of 50.
//
// param: "ReservationActivitySid" (string) - The SID of the Activity to assign Workers when a task is reserved for them.
//
// param: "TargetWorkers" (string) - A string describing the Worker selection criteria for any Tasks that enter the TaskQueue. For example '\\\"language\\\" == \\\"spanish\\\"' If no TargetWorkers parameter is provided, Tasks will wait in the queue until they are either deleted or moved to another queue. Additional examples on how to describing Worker selection criteria below.
//
// param: "TaskOrder" (string) - How Tasks will be assigned to Workers. Can be: `FIFO` or `LIFO` and the default is `FIFO`. Use `FIFO` to assign the oldest task first and `LIFO` to assign the most recent task first. For more information, see [Queue Ordering](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo).
//
// return: TaskrouterV1WorkspaceTaskQueue
func (c *DefaultApiService) UpdateTaskQueue(WorkspaceSid string, Sid string, params *UpdateTaskQueueParams) (*TaskrouterV1WorkspaceTaskQueue, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AssignmentActivitySid != nil {
		data.Set("AssignmentActivitySid", *params.AssignmentActivitySid)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MaxReservedWorkers != nil {
		data.Set("MaxReservedWorkers", fmt.Sprint(*params.MaxReservedWorkers))
	}
	if params != nil && params.ReservationActivitySid != nil {
		data.Set("ReservationActivitySid", *params.ReservationActivitySid)
	}
	if params != nil && params.TargetWorkers != nil {
		data.Set("TargetWorkers", *params.TargetWorkers)
	}
	if params != nil && params.TaskOrder != nil {
		data.Set("TaskOrder", *params.TaskOrder)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskQueue{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateTaskReservationParams Optional parameters for the method 'UpdateTaskReservation'
type UpdateTaskReservationParams struct {
	Beep                                    *string   `json:"Beep,omitempty"`
	BeepOnCustomerEntrance                  *bool     `json:"BeepOnCustomerEntrance,omitempty"`
	CallAccept                              *bool     `json:"CallAccept,omitempty"`
	CallFrom                                *string   `json:"CallFrom,omitempty"`
	CallRecord                              *string   `json:"CallRecord,omitempty"`
	CallStatusCallbackUrl                   *string   `json:"CallStatusCallbackUrl,omitempty"`
	CallTimeout                             *int32    `json:"CallTimeout,omitempty"`
	CallTo                                  *string   `json:"CallTo,omitempty"`
	CallUrl                                 *string   `json:"CallUrl,omitempty"`
	ConferenceRecord                        *string   `json:"ConferenceRecord,omitempty"`
	ConferenceRecordingStatusCallback       *string   `json:"ConferenceRecordingStatusCallback,omitempty"`
	ConferenceRecordingStatusCallbackMethod *string   `json:"ConferenceRecordingStatusCallbackMethod,omitempty"`
	ConferenceStatusCallback                *string   `json:"ConferenceStatusCallback,omitempty"`
	ConferenceStatusCallbackEvent           *[]string `json:"ConferenceStatusCallbackEvent,omitempty"`
	ConferenceStatusCallbackMethod          *string   `json:"ConferenceStatusCallbackMethod,omitempty"`
	ConferenceTrim                          *string   `json:"ConferenceTrim,omitempty"`
	DequeueFrom                             *string   `json:"DequeueFrom,omitempty"`
	DequeuePostWorkActivitySid              *string   `json:"DequeuePostWorkActivitySid,omitempty"`
	DequeueRecord                           *string   `json:"DequeueRecord,omitempty"`
	DequeueStatusCallbackEvent              *[]string `json:"DequeueStatusCallbackEvent,omitempty"`
	DequeueStatusCallbackUrl                *string   `json:"DequeueStatusCallbackUrl,omitempty"`
	DequeueTimeout                          *int32    `json:"DequeueTimeout,omitempty"`
	DequeueTo                               *string   `json:"DequeueTo,omitempty"`
	EarlyMedia                              *bool     `json:"EarlyMedia,omitempty"`
	EndConferenceOnCustomerExit             *bool     `json:"EndConferenceOnCustomerExit,omitempty"`
	EndConferenceOnExit                     *bool     `json:"EndConferenceOnExit,omitempty"`
	From                                    *string   `json:"From,omitempty"`
	Instruction                             *string   `json:"Instruction,omitempty"`
	MaxParticipants                         *int32    `json:"MaxParticipants,omitempty"`
	Muted                                   *bool     `json:"Muted,omitempty"`
	PostWorkActivitySid                     *string   `json:"PostWorkActivitySid,omitempty"`
	Record                                  *bool     `json:"Record,omitempty"`
	RecordingChannels                       *string   `json:"RecordingChannels,omitempty"`
	RecordingStatusCallback                 *string   `json:"RecordingStatusCallback,omitempty"`
	RecordingStatusCallbackMethod           *string   `json:"RecordingStatusCallbackMethod,omitempty"`
	RedirectAccept                          *bool     `json:"RedirectAccept,omitempty"`
	RedirectCallSid                         *string   `json:"RedirectCallSid,omitempty"`
	RedirectUrl                             *string   `json:"RedirectUrl,omitempty"`
	Region                                  *string   `json:"Region,omitempty"`
	ReservationStatus                       *string   `json:"ReservationStatus,omitempty"`
	SipAuthPassword                         *string   `json:"SipAuthPassword,omitempty"`
	SipAuthUsername                         *string   `json:"SipAuthUsername,omitempty"`
	StartConferenceOnEnter                  *bool     `json:"StartConferenceOnEnter,omitempty"`
	StatusCallback                          *string   `json:"StatusCallback,omitempty"`
	StatusCallbackEvent                     *[]string `json:"StatusCallbackEvent,omitempty"`
	StatusCallbackMethod                    *string   `json:"StatusCallbackMethod,omitempty"`
	Supervisor                              *string   `json:"Supervisor,omitempty"`
	SupervisorMode                          *string   `json:"SupervisorMode,omitempty"`
	Timeout                                 *int32    `json:"Timeout,omitempty"`
	To                                      *string   `json:"To,omitempty"`
	WaitMethod                              *string   `json:"WaitMethod,omitempty"`
	WaitUrl                                 *string   `json:"WaitUrl,omitempty"`
	WorkerActivitySid                       *string   `json:"WorkerActivitySid,omitempty"`
}

func (params *UpdateTaskReservationParams) SetBeep(Beep string) *UpdateTaskReservationParams {
	params.Beep = &Beep
	return params
}
func (params *UpdateTaskReservationParams) SetBeepOnCustomerEntrance(BeepOnCustomerEntrance bool) *UpdateTaskReservationParams {
	params.BeepOnCustomerEntrance = &BeepOnCustomerEntrance
	return params
}
func (params *UpdateTaskReservationParams) SetCallAccept(CallAccept bool) *UpdateTaskReservationParams {
	params.CallAccept = &CallAccept
	return params
}
func (params *UpdateTaskReservationParams) SetCallFrom(CallFrom string) *UpdateTaskReservationParams {
	params.CallFrom = &CallFrom
	return params
}
func (params *UpdateTaskReservationParams) SetCallRecord(CallRecord string) *UpdateTaskReservationParams {
	params.CallRecord = &CallRecord
	return params
}
func (params *UpdateTaskReservationParams) SetCallStatusCallbackUrl(CallStatusCallbackUrl string) *UpdateTaskReservationParams {
	params.CallStatusCallbackUrl = &CallStatusCallbackUrl
	return params
}
func (params *UpdateTaskReservationParams) SetCallTimeout(CallTimeout int32) *UpdateTaskReservationParams {
	params.CallTimeout = &CallTimeout
	return params
}
func (params *UpdateTaskReservationParams) SetCallTo(CallTo string) *UpdateTaskReservationParams {
	params.CallTo = &CallTo
	return params
}
func (params *UpdateTaskReservationParams) SetCallUrl(CallUrl string) *UpdateTaskReservationParams {
	params.CallUrl = &CallUrl
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceRecord(ConferenceRecord string) *UpdateTaskReservationParams {
	params.ConferenceRecord = &ConferenceRecord
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceRecordingStatusCallback(ConferenceRecordingStatusCallback string) *UpdateTaskReservationParams {
	params.ConferenceRecordingStatusCallback = &ConferenceRecordingStatusCallback
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceRecordingStatusCallbackMethod(ConferenceRecordingStatusCallbackMethod string) *UpdateTaskReservationParams {
	params.ConferenceRecordingStatusCallbackMethod = &ConferenceRecordingStatusCallbackMethod
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceStatusCallback(ConferenceStatusCallback string) *UpdateTaskReservationParams {
	params.ConferenceStatusCallback = &ConferenceStatusCallback
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceStatusCallbackEvent(ConferenceStatusCallbackEvent []string) *UpdateTaskReservationParams {
	params.ConferenceStatusCallbackEvent = &ConferenceStatusCallbackEvent
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceStatusCallbackMethod(ConferenceStatusCallbackMethod string) *UpdateTaskReservationParams {
	params.ConferenceStatusCallbackMethod = &ConferenceStatusCallbackMethod
	return params
}
func (params *UpdateTaskReservationParams) SetConferenceTrim(ConferenceTrim string) *UpdateTaskReservationParams {
	params.ConferenceTrim = &ConferenceTrim
	return params
}
func (params *UpdateTaskReservationParams) SetDequeueFrom(DequeueFrom string) *UpdateTaskReservationParams {
	params.DequeueFrom = &DequeueFrom
	return params
}
func (params *UpdateTaskReservationParams) SetDequeuePostWorkActivitySid(DequeuePostWorkActivitySid string) *UpdateTaskReservationParams {
	params.DequeuePostWorkActivitySid = &DequeuePostWorkActivitySid
	return params
}
func (params *UpdateTaskReservationParams) SetDequeueRecord(DequeueRecord string) *UpdateTaskReservationParams {
	params.DequeueRecord = &DequeueRecord
	return params
}
func (params *UpdateTaskReservationParams) SetDequeueStatusCallbackEvent(DequeueStatusCallbackEvent []string) *UpdateTaskReservationParams {
	params.DequeueStatusCallbackEvent = &DequeueStatusCallbackEvent
	return params
}
func (params *UpdateTaskReservationParams) SetDequeueStatusCallbackUrl(DequeueStatusCallbackUrl string) *UpdateTaskReservationParams {
	params.DequeueStatusCallbackUrl = &DequeueStatusCallbackUrl
	return params
}
func (params *UpdateTaskReservationParams) SetDequeueTimeout(DequeueTimeout int32) *UpdateTaskReservationParams {
	params.DequeueTimeout = &DequeueTimeout
	return params
}
func (params *UpdateTaskReservationParams) SetDequeueTo(DequeueTo string) *UpdateTaskReservationParams {
	params.DequeueTo = &DequeueTo
	return params
}
func (params *UpdateTaskReservationParams) SetEarlyMedia(EarlyMedia bool) *UpdateTaskReservationParams {
	params.EarlyMedia = &EarlyMedia
	return params
}
func (params *UpdateTaskReservationParams) SetEndConferenceOnCustomerExit(EndConferenceOnCustomerExit bool) *UpdateTaskReservationParams {
	params.EndConferenceOnCustomerExit = &EndConferenceOnCustomerExit
	return params
}
func (params *UpdateTaskReservationParams) SetEndConferenceOnExit(EndConferenceOnExit bool) *UpdateTaskReservationParams {
	params.EndConferenceOnExit = &EndConferenceOnExit
	return params
}
func (params *UpdateTaskReservationParams) SetFrom(From string) *UpdateTaskReservationParams {
	params.From = &From
	return params
}
func (params *UpdateTaskReservationParams) SetInstruction(Instruction string) *UpdateTaskReservationParams {
	params.Instruction = &Instruction
	return params
}
func (params *UpdateTaskReservationParams) SetMaxParticipants(MaxParticipants int32) *UpdateTaskReservationParams {
	params.MaxParticipants = &MaxParticipants
	return params
}
func (params *UpdateTaskReservationParams) SetMuted(Muted bool) *UpdateTaskReservationParams {
	params.Muted = &Muted
	return params
}
func (params *UpdateTaskReservationParams) SetPostWorkActivitySid(PostWorkActivitySid string) *UpdateTaskReservationParams {
	params.PostWorkActivitySid = &PostWorkActivitySid
	return params
}
func (params *UpdateTaskReservationParams) SetRecord(Record bool) *UpdateTaskReservationParams {
	params.Record = &Record
	return params
}
func (params *UpdateTaskReservationParams) SetRecordingChannels(RecordingChannels string) *UpdateTaskReservationParams {
	params.RecordingChannels = &RecordingChannels
	return params
}
func (params *UpdateTaskReservationParams) SetRecordingStatusCallback(RecordingStatusCallback string) *UpdateTaskReservationParams {
	params.RecordingStatusCallback = &RecordingStatusCallback
	return params
}
func (params *UpdateTaskReservationParams) SetRecordingStatusCallbackMethod(RecordingStatusCallbackMethod string) *UpdateTaskReservationParams {
	params.RecordingStatusCallbackMethod = &RecordingStatusCallbackMethod
	return params
}
func (params *UpdateTaskReservationParams) SetRedirectAccept(RedirectAccept bool) *UpdateTaskReservationParams {
	params.RedirectAccept = &RedirectAccept
	return params
}
func (params *UpdateTaskReservationParams) SetRedirectCallSid(RedirectCallSid string) *UpdateTaskReservationParams {
	params.RedirectCallSid = &RedirectCallSid
	return params
}
func (params *UpdateTaskReservationParams) SetRedirectUrl(RedirectUrl string) *UpdateTaskReservationParams {
	params.RedirectUrl = &RedirectUrl
	return params
}
func (params *UpdateTaskReservationParams) SetRegion(Region string) *UpdateTaskReservationParams {
	params.Region = &Region
	return params
}
func (params *UpdateTaskReservationParams) SetReservationStatus(ReservationStatus string) *UpdateTaskReservationParams {
	params.ReservationStatus = &ReservationStatus
	return params
}
func (params *UpdateTaskReservationParams) SetSipAuthPassword(SipAuthPassword string) *UpdateTaskReservationParams {
	params.SipAuthPassword = &SipAuthPassword
	return params
}
func (params *UpdateTaskReservationParams) SetSipAuthUsername(SipAuthUsername string) *UpdateTaskReservationParams {
	params.SipAuthUsername = &SipAuthUsername
	return params
}
func (params *UpdateTaskReservationParams) SetStartConferenceOnEnter(StartConferenceOnEnter bool) *UpdateTaskReservationParams {
	params.StartConferenceOnEnter = &StartConferenceOnEnter
	return params
}
func (params *UpdateTaskReservationParams) SetStatusCallback(StatusCallback string) *UpdateTaskReservationParams {
	params.StatusCallback = &StatusCallback
	return params
}
func (params *UpdateTaskReservationParams) SetStatusCallbackEvent(StatusCallbackEvent []string) *UpdateTaskReservationParams {
	params.StatusCallbackEvent = &StatusCallbackEvent
	return params
}
func (params *UpdateTaskReservationParams) SetStatusCallbackMethod(StatusCallbackMethod string) *UpdateTaskReservationParams {
	params.StatusCallbackMethod = &StatusCallbackMethod
	return params
}
func (params *UpdateTaskReservationParams) SetSupervisor(Supervisor string) *UpdateTaskReservationParams {
	params.Supervisor = &Supervisor
	return params
}
func (params *UpdateTaskReservationParams) SetSupervisorMode(SupervisorMode string) *UpdateTaskReservationParams {
	params.SupervisorMode = &SupervisorMode
	return params
}
func (params *UpdateTaskReservationParams) SetTimeout(Timeout int32) *UpdateTaskReservationParams {
	params.Timeout = &Timeout
	return params
}
func (params *UpdateTaskReservationParams) SetTo(To string) *UpdateTaskReservationParams {
	params.To = &To
	return params
}
func (params *UpdateTaskReservationParams) SetWaitMethod(WaitMethod string) *UpdateTaskReservationParams {
	params.WaitMethod = &WaitMethod
	return params
}
func (params *UpdateTaskReservationParams) SetWaitUrl(WaitUrl string) *UpdateTaskReservationParams {
	params.WaitUrl = &WaitUrl
	return params
}
func (params *UpdateTaskReservationParams) SetWorkerActivitySid(WorkerActivitySid string) *UpdateTaskReservationParams {
	params.WorkerActivitySid = &WorkerActivitySid
	return params
}

// UpdateTaskReservation Method for UpdateTaskReservation
//
// param: WorkspaceSid The SID of the Workspace with the TaskReservation resources to update.
//
// param: TaskSid The SID of the reserved Task resource with the TaskReservation resources to update.
//
// param: Sid The SID of the TaskReservation resource to update.
//
// param: optional nil or *UpdateTaskReservationParams - Optional Parameters:
//
// param: "Beep" (string) - Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
//
// param: "BeepOnCustomerEntrance" (bool) - Whether to play a notification beep when the customer joins.
//
// param: "CallAccept" (bool) - Whether to accept a reservation when executing a Call instruction.
//
// param: "CallFrom" (string) - The Caller ID of the outbound call when executing a Call instruction.
//
// param: "CallRecord" (string) - Whether to record both legs of a call when executing a Call instruction or which leg to record.
//
// param: "CallStatusCallbackUrl" (string) - The URL to call  for the completed call event when executing a Call instruction.
//
// param: "CallTimeout" (int32) - Timeout for call when executing a Call instruction.
//
// param: "CallTo" (string) - The Contact URI of the worker when executing a Call instruction.  Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
//
// param: "CallUrl" (string) - TwiML URI executed on answering the worker's leg as a result of the Call instruction.
//
// param: "ConferenceRecord" (string) - Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
//
// param: "ConferenceRecordingStatusCallback" (string) - The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
//
// param: "ConferenceRecordingStatusCallbackMethod" (string) - The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
//
// param: "ConferenceStatusCallback" (string) - The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
//
// param: "ConferenceStatusCallbackEvent" ([]string) - The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
//
// param: "ConferenceStatusCallbackMethod" (string) - The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
//
// param: "ConferenceTrim" (string) - How to trim the leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
//
// param: "DequeueFrom" (string) - The Caller ID of the call to the worker when executing a Dequeue instruction.
//
// param: "DequeuePostWorkActivitySid" (string) - The SID of the Activity resource to start after executing a Dequeue instruction.
//
// param: "DequeueRecord" (string) - Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
//
// param: "DequeueStatusCallbackEvent" ([]string) - The Call progress events sent via webhooks as a result of a Dequeue instruction.
//
// param: "DequeueStatusCallbackUrl" (string) - The Callback URL for completed call event when executing a Dequeue instruction.
//
// param: "DequeueTimeout" (int32) - Timeout for call when executing a Dequeue instruction.
//
// param: "DequeueTo" (string) - The Contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
//
// param: "EarlyMedia" (bool) - Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
//
// param: "EndConferenceOnCustomerExit" (bool) - Whether to end the conference when the customer leaves.
//
// param: "EndConferenceOnExit" (bool) - Whether to end the conference when the agent leaves.
//
// param: "From" (string) - The Caller ID of the call to the worker when executing a Conference instruction.
//
// param: "Instruction" (string) - The assignment instruction for reservation.
//
// param: "MaxParticipants" (int32) - The maximum number of participants in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
//
// param: "Muted" (bool) - Whether the agent is muted in the conference. The default is `false`.
//
// param: "PostWorkActivitySid" (string) - The new worker activity SID after executing a Conference instruction.
//
// param: "Record" (bool) - Whether to record the participant and their conferences, including the time between conferences. The default is `false`.
//
// param: "RecordingChannels" (string) - The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
//
// param: "RecordingStatusCallback" (string) - The URL that we should call using the `recording_status_callback_method` when the recording status changes.
//
// param: "RecordingStatusCallbackMethod" (string) - The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
//
// param: "RedirectAccept" (bool) - Whether the reservation should be accepted when executing a Redirect instruction.
//
// param: "RedirectCallSid" (string) - The Call SID of the call parked in the queue when executing a Redirect instruction.
//
// param: "RedirectUrl" (string) - TwiML URI to redirect the call to when executing the Redirect instruction.
//
// param: "Region" (string) - The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
//
// param: "ReservationStatus" (string) - The new status of the reservation. Can be: `pending`, `accepted`, `rejected`, or `timeout`.
//
// param: "SipAuthPassword" (string) - The SIP password for authentication.
//
// param: "SipAuthUsername" (string) - The SIP username used for authentication.
//
// param: "StartConferenceOnEnter" (bool) - Whether to start the conference when the participant joins, if it has not already started. The default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
//
// param: "StatusCallback" (string) - The URL we should call using the `status_callback_method` to send status information to your application.
//
// param: "StatusCallbackEvent" ([]string) - The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
//
// param: "StatusCallbackMethod" (string) - The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
//
// param: "Supervisor" (string) - The Supervisor SID/URI when executing the Supervise instruction.
//
// param: "SupervisorMode" (string) - The Supervisor mode when executing the Supervise instruction.
//
// param: "Timeout" (int32) - Timeout for call when executing a Conference instruction.
//
// param: "To" (string) - The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
//
// param: "WaitMethod" (string) - The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
//
// param: "WaitUrl" (string) - The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
//
// param: "WorkerActivitySid" (string) - The new worker activity SID if rejecting a reservation.
//
// return: TaskrouterV1WorkspaceTaskTaskReservation
func (c *DefaultApiService) UpdateTaskReservation(WorkspaceSid string, TaskSid string, Sid string, params *UpdateTaskReservationParams) (*TaskrouterV1WorkspaceTaskTaskReservation, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"TaskSid"+"}", TaskSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Beep != nil {
		data.Set("Beep", *params.Beep)
	}
	if params != nil && params.BeepOnCustomerEntrance != nil {
		data.Set("BeepOnCustomerEntrance", fmt.Sprint(*params.BeepOnCustomerEntrance))
	}
	if params != nil && params.CallAccept != nil {
		data.Set("CallAccept", fmt.Sprint(*params.CallAccept))
	}
	if params != nil && params.CallFrom != nil {
		data.Set("CallFrom", *params.CallFrom)
	}
	if params != nil && params.CallRecord != nil {
		data.Set("CallRecord", *params.CallRecord)
	}
	if params != nil && params.CallStatusCallbackUrl != nil {
		data.Set("CallStatusCallbackUrl", *params.CallStatusCallbackUrl)
	}
	if params != nil && params.CallTimeout != nil {
		data.Set("CallTimeout", fmt.Sprint(*params.CallTimeout))
	}
	if params != nil && params.CallTo != nil {
		data.Set("CallTo", *params.CallTo)
	}
	if params != nil && params.CallUrl != nil {
		data.Set("CallUrl", *params.CallUrl)
	}
	if params != nil && params.ConferenceRecord != nil {
		data.Set("ConferenceRecord", *params.ConferenceRecord)
	}
	if params != nil && params.ConferenceRecordingStatusCallback != nil {
		data.Set("ConferenceRecordingStatusCallback", *params.ConferenceRecordingStatusCallback)
	}
	if params != nil && params.ConferenceRecordingStatusCallbackMethod != nil {
		data.Set("ConferenceRecordingStatusCallbackMethod", *params.ConferenceRecordingStatusCallbackMethod)
	}
	if params != nil && params.ConferenceStatusCallback != nil {
		data.Set("ConferenceStatusCallback", *params.ConferenceStatusCallback)
	}
	if params != nil && params.ConferenceStatusCallbackEvent != nil {
		data.Set("ConferenceStatusCallbackEvent", strings.Join(*params.ConferenceStatusCallbackEvent, ","))
	}
	if params != nil && params.ConferenceStatusCallbackMethod != nil {
		data.Set("ConferenceStatusCallbackMethod", *params.ConferenceStatusCallbackMethod)
	}
	if params != nil && params.ConferenceTrim != nil {
		data.Set("ConferenceTrim", *params.ConferenceTrim)
	}
	if params != nil && params.DequeueFrom != nil {
		data.Set("DequeueFrom", *params.DequeueFrom)
	}
	if params != nil && params.DequeuePostWorkActivitySid != nil {
		data.Set("DequeuePostWorkActivitySid", *params.DequeuePostWorkActivitySid)
	}
	if params != nil && params.DequeueRecord != nil {
		data.Set("DequeueRecord", *params.DequeueRecord)
	}
	if params != nil && params.DequeueStatusCallbackEvent != nil {
		data.Set("DequeueStatusCallbackEvent", strings.Join(*params.DequeueStatusCallbackEvent, ","))
	}
	if params != nil && params.DequeueStatusCallbackUrl != nil {
		data.Set("DequeueStatusCallbackUrl", *params.DequeueStatusCallbackUrl)
	}
	if params != nil && params.DequeueTimeout != nil {
		data.Set("DequeueTimeout", fmt.Sprint(*params.DequeueTimeout))
	}
	if params != nil && params.DequeueTo != nil {
		data.Set("DequeueTo", *params.DequeueTo)
	}
	if params != nil && params.EarlyMedia != nil {
		data.Set("EarlyMedia", fmt.Sprint(*params.EarlyMedia))
	}
	if params != nil && params.EndConferenceOnCustomerExit != nil {
		data.Set("EndConferenceOnCustomerExit", fmt.Sprint(*params.EndConferenceOnCustomerExit))
	}
	if params != nil && params.EndConferenceOnExit != nil {
		data.Set("EndConferenceOnExit", fmt.Sprint(*params.EndConferenceOnExit))
	}
	if params != nil && params.From != nil {
		data.Set("From", *params.From)
	}
	if params != nil && params.Instruction != nil {
		data.Set("Instruction", *params.Instruction)
	}
	if params != nil && params.MaxParticipants != nil {
		data.Set("MaxParticipants", fmt.Sprint(*params.MaxParticipants))
	}
	if params != nil && params.Muted != nil {
		data.Set("Muted", fmt.Sprint(*params.Muted))
	}
	if params != nil && params.PostWorkActivitySid != nil {
		data.Set("PostWorkActivitySid", *params.PostWorkActivitySid)
	}
	if params != nil && params.Record != nil {
		data.Set("Record", fmt.Sprint(*params.Record))
	}
	if params != nil && params.RecordingChannels != nil {
		data.Set("RecordingChannels", *params.RecordingChannels)
	}
	if params != nil && params.RecordingStatusCallback != nil {
		data.Set("RecordingStatusCallback", *params.RecordingStatusCallback)
	}
	if params != nil && params.RecordingStatusCallbackMethod != nil {
		data.Set("RecordingStatusCallbackMethod", *params.RecordingStatusCallbackMethod)
	}
	if params != nil && params.RedirectAccept != nil {
		data.Set("RedirectAccept", fmt.Sprint(*params.RedirectAccept))
	}
	if params != nil && params.RedirectCallSid != nil {
		data.Set("RedirectCallSid", *params.RedirectCallSid)
	}
	if params != nil && params.RedirectUrl != nil {
		data.Set("RedirectUrl", *params.RedirectUrl)
	}
	if params != nil && params.Region != nil {
		data.Set("Region", *params.Region)
	}
	if params != nil && params.ReservationStatus != nil {
		data.Set("ReservationStatus", *params.ReservationStatus)
	}
	if params != nil && params.SipAuthPassword != nil {
		data.Set("SipAuthPassword", *params.SipAuthPassword)
	}
	if params != nil && params.SipAuthUsername != nil {
		data.Set("SipAuthUsername", *params.SipAuthUsername)
	}
	if params != nil && params.StartConferenceOnEnter != nil {
		data.Set("StartConferenceOnEnter", fmt.Sprint(*params.StartConferenceOnEnter))
	}
	if params != nil && params.StatusCallback != nil {
		data.Set("StatusCallback", *params.StatusCallback)
	}
	if params != nil && params.StatusCallbackEvent != nil {
		data.Set("StatusCallbackEvent", strings.Join(*params.StatusCallbackEvent, ","))
	}
	if params != nil && params.StatusCallbackMethod != nil {
		data.Set("StatusCallbackMethod", *params.StatusCallbackMethod)
	}
	if params != nil && params.Supervisor != nil {
		data.Set("Supervisor", *params.Supervisor)
	}
	if params != nil && params.SupervisorMode != nil {
		data.Set("SupervisorMode", *params.SupervisorMode)
	}
	if params != nil && params.Timeout != nil {
		data.Set("Timeout", fmt.Sprint(*params.Timeout))
	}
	if params != nil && params.To != nil {
		data.Set("To", *params.To)
	}
	if params != nil && params.WaitMethod != nil {
		data.Set("WaitMethod", *params.WaitMethod)
	}
	if params != nil && params.WaitUrl != nil {
		data.Set("WaitUrl", *params.WaitUrl)
	}
	if params != nil && params.WorkerActivitySid != nil {
		data.Set("WorkerActivitySid", *params.WorkerActivitySid)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceTaskTaskReservation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateWorkerParams Optional parameters for the method 'UpdateWorker'
type UpdateWorkerParams struct {
	ActivitySid               *string `json:"ActivitySid,omitempty"`
	Attributes                *string `json:"Attributes,omitempty"`
	FriendlyName              *string `json:"FriendlyName,omitempty"`
	RejectPendingReservations *bool   `json:"RejectPendingReservations,omitempty"`
}

func (params *UpdateWorkerParams) SetActivitySid(ActivitySid string) *UpdateWorkerParams {
	params.ActivitySid = &ActivitySid
	return params
}
func (params *UpdateWorkerParams) SetAttributes(Attributes string) *UpdateWorkerParams {
	params.Attributes = &Attributes
	return params
}
func (params *UpdateWorkerParams) SetFriendlyName(FriendlyName string) *UpdateWorkerParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateWorkerParams) SetRejectPendingReservations(RejectPendingReservations bool) *UpdateWorkerParams {
	params.RejectPendingReservations = &RejectPendingReservations
	return params
}

// UpdateWorker Method for UpdateWorker
//
// param: WorkspaceSid The SID of the Workspace with the Worker to update.
//
// param: Sid The SID of the Worker resource to update.
//
// param: optional nil or *UpdateWorkerParams - Optional Parameters:
//
// param: "ActivitySid" (string) - The SID of a valid Activity that will describe the Worker's initial state. See [Activities](https://www.twilio.com/docs/taskrouter/api/activity) for more information.
//
// param: "Attributes" (string) - The JSON string that describes the Worker. For example: `{ \\\"email\\\": \\\"Bob@example.com\\\", \\\"phone\\\": \\\"+5095551234\\\" }`. This data is passed to the `assignment_callback_url` when TaskRouter assigns a Task to the Worker. Defaults to {}.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Worker. It can be up to 64 characters long.
//
// param: "RejectPendingReservations" (bool) - Whether to reject pending reservations.
//
// return: TaskrouterV1WorkspaceWorker
func (c *DefaultApiService) UpdateWorker(WorkspaceSid string, Sid string, params *UpdateWorkerParams) (*TaskrouterV1WorkspaceWorker, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.ActivitySid != nil {
		data.Set("ActivitySid", *params.ActivitySid)
	}
	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.RejectPendingReservations != nil {
		data.Set("RejectPendingReservations", fmt.Sprint(*params.RejectPendingReservations))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorker{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateWorkerChannelParams Optional parameters for the method 'UpdateWorkerChannel'
type UpdateWorkerChannelParams struct {
	Available *bool  `json:"Available,omitempty"`
	Capacity  *int32 `json:"Capacity,omitempty"`
}

func (params *UpdateWorkerChannelParams) SetAvailable(Available bool) *UpdateWorkerChannelParams {
	params.Available = &Available
	return params
}
func (params *UpdateWorkerChannelParams) SetCapacity(Capacity int32) *UpdateWorkerChannelParams {
	params.Capacity = &Capacity
	return params
}

// UpdateWorkerChannel Method for UpdateWorkerChannel
//
// param: WorkspaceSid The SID of the Workspace with the WorkerChannel to update.
//
// param: WorkerSid The SID of the Worker with the WorkerChannel to update.
//
// param: Sid The SID of the WorkerChannel to update.
//
// param: optional nil or *UpdateWorkerChannelParams - Optional Parameters:
//
// param: "Available" (bool) - Whether the WorkerChannel is available. Set to `false` to prevent the Worker from receiving any new Tasks of this TaskChannel type.
//
// param: "Capacity" (int32) - The total number of Tasks that the Worker should handle for the TaskChannel type. TaskRouter creates reservations for Tasks of this TaskChannel type up to the specified capacity. If the capacity is 0, no new reservations will be created.
//
// return: TaskrouterV1WorkspaceWorkerWorkerChannel
func (c *DefaultApiService) UpdateWorkerChannel(WorkspaceSid string, WorkerSid string, Sid string, params *UpdateWorkerChannelParams) (*TaskrouterV1WorkspaceWorkerWorkerChannel, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Available != nil {
		data.Set("Available", fmt.Sprint(*params.Available))
	}
	if params != nil && params.Capacity != nil {
		data.Set("Capacity", fmt.Sprint(*params.Capacity))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkerChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateWorkerReservationParams Optional parameters for the method 'UpdateWorkerReservation'
type UpdateWorkerReservationParams struct {
	Beep                                    *string   `json:"Beep,omitempty"`
	BeepOnCustomerEntrance                  *bool     `json:"BeepOnCustomerEntrance,omitempty"`
	CallAccept                              *bool     `json:"CallAccept,omitempty"`
	CallFrom                                *string   `json:"CallFrom,omitempty"`
	CallRecord                              *string   `json:"CallRecord,omitempty"`
	CallStatusCallbackUrl                   *string   `json:"CallStatusCallbackUrl,omitempty"`
	CallTimeout                             *int32    `json:"CallTimeout,omitempty"`
	CallTo                                  *string   `json:"CallTo,omitempty"`
	CallUrl                                 *string   `json:"CallUrl,omitempty"`
	ConferenceRecord                        *string   `json:"ConferenceRecord,omitempty"`
	ConferenceRecordingStatusCallback       *string   `json:"ConferenceRecordingStatusCallback,omitempty"`
	ConferenceRecordingStatusCallbackMethod *string   `json:"ConferenceRecordingStatusCallbackMethod,omitempty"`
	ConferenceStatusCallback                *string   `json:"ConferenceStatusCallback,omitempty"`
	ConferenceStatusCallbackEvent           *[]string `json:"ConferenceStatusCallbackEvent,omitempty"`
	ConferenceStatusCallbackMethod          *string   `json:"ConferenceStatusCallbackMethod,omitempty"`
	ConferenceTrim                          *string   `json:"ConferenceTrim,omitempty"`
	DequeueFrom                             *string   `json:"DequeueFrom,omitempty"`
	DequeuePostWorkActivitySid              *string   `json:"DequeuePostWorkActivitySid,omitempty"`
	DequeueRecord                           *string   `json:"DequeueRecord,omitempty"`
	DequeueStatusCallbackEvent              *[]string `json:"DequeueStatusCallbackEvent,omitempty"`
	DequeueStatusCallbackUrl                *string   `json:"DequeueStatusCallbackUrl,omitempty"`
	DequeueTimeout                          *int32    `json:"DequeueTimeout,omitempty"`
	DequeueTo                               *string   `json:"DequeueTo,omitempty"`
	EarlyMedia                              *bool     `json:"EarlyMedia,omitempty"`
	EndConferenceOnCustomerExit             *bool     `json:"EndConferenceOnCustomerExit,omitempty"`
	EndConferenceOnExit                     *bool     `json:"EndConferenceOnExit,omitempty"`
	From                                    *string   `json:"From,omitempty"`
	Instruction                             *string   `json:"Instruction,omitempty"`
	MaxParticipants                         *int32    `json:"MaxParticipants,omitempty"`
	Muted                                   *bool     `json:"Muted,omitempty"`
	PostWorkActivitySid                     *string   `json:"PostWorkActivitySid,omitempty"`
	Record                                  *bool     `json:"Record,omitempty"`
	RecordingChannels                       *string   `json:"RecordingChannels,omitempty"`
	RecordingStatusCallback                 *string   `json:"RecordingStatusCallback,omitempty"`
	RecordingStatusCallbackMethod           *string   `json:"RecordingStatusCallbackMethod,omitempty"`
	RedirectAccept                          *bool     `json:"RedirectAccept,omitempty"`
	RedirectCallSid                         *string   `json:"RedirectCallSid,omitempty"`
	RedirectUrl                             *string   `json:"RedirectUrl,omitempty"`
	Region                                  *string   `json:"Region,omitempty"`
	ReservationStatus                       *string   `json:"ReservationStatus,omitempty"`
	SipAuthPassword                         *string   `json:"SipAuthPassword,omitempty"`
	SipAuthUsername                         *string   `json:"SipAuthUsername,omitempty"`
	StartConferenceOnEnter                  *bool     `json:"StartConferenceOnEnter,omitempty"`
	StatusCallback                          *string   `json:"StatusCallback,omitempty"`
	StatusCallbackEvent                     *[]string `json:"StatusCallbackEvent,omitempty"`
	StatusCallbackMethod                    *string   `json:"StatusCallbackMethod,omitempty"`
	Timeout                                 *int32    `json:"Timeout,omitempty"`
	To                                      *string   `json:"To,omitempty"`
	WaitMethod                              *string   `json:"WaitMethod,omitempty"`
	WaitUrl                                 *string   `json:"WaitUrl,omitempty"`
	WorkerActivitySid                       *string   `json:"WorkerActivitySid,omitempty"`
}

func (params *UpdateWorkerReservationParams) SetBeep(Beep string) *UpdateWorkerReservationParams {
	params.Beep = &Beep
	return params
}
func (params *UpdateWorkerReservationParams) SetBeepOnCustomerEntrance(BeepOnCustomerEntrance bool) *UpdateWorkerReservationParams {
	params.BeepOnCustomerEntrance = &BeepOnCustomerEntrance
	return params
}
func (params *UpdateWorkerReservationParams) SetCallAccept(CallAccept bool) *UpdateWorkerReservationParams {
	params.CallAccept = &CallAccept
	return params
}
func (params *UpdateWorkerReservationParams) SetCallFrom(CallFrom string) *UpdateWorkerReservationParams {
	params.CallFrom = &CallFrom
	return params
}
func (params *UpdateWorkerReservationParams) SetCallRecord(CallRecord string) *UpdateWorkerReservationParams {
	params.CallRecord = &CallRecord
	return params
}
func (params *UpdateWorkerReservationParams) SetCallStatusCallbackUrl(CallStatusCallbackUrl string) *UpdateWorkerReservationParams {
	params.CallStatusCallbackUrl = &CallStatusCallbackUrl
	return params
}
func (params *UpdateWorkerReservationParams) SetCallTimeout(CallTimeout int32) *UpdateWorkerReservationParams {
	params.CallTimeout = &CallTimeout
	return params
}
func (params *UpdateWorkerReservationParams) SetCallTo(CallTo string) *UpdateWorkerReservationParams {
	params.CallTo = &CallTo
	return params
}
func (params *UpdateWorkerReservationParams) SetCallUrl(CallUrl string) *UpdateWorkerReservationParams {
	params.CallUrl = &CallUrl
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceRecord(ConferenceRecord string) *UpdateWorkerReservationParams {
	params.ConferenceRecord = &ConferenceRecord
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceRecordingStatusCallback(ConferenceRecordingStatusCallback string) *UpdateWorkerReservationParams {
	params.ConferenceRecordingStatusCallback = &ConferenceRecordingStatusCallback
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceRecordingStatusCallbackMethod(ConferenceRecordingStatusCallbackMethod string) *UpdateWorkerReservationParams {
	params.ConferenceRecordingStatusCallbackMethod = &ConferenceRecordingStatusCallbackMethod
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceStatusCallback(ConferenceStatusCallback string) *UpdateWorkerReservationParams {
	params.ConferenceStatusCallback = &ConferenceStatusCallback
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceStatusCallbackEvent(ConferenceStatusCallbackEvent []string) *UpdateWorkerReservationParams {
	params.ConferenceStatusCallbackEvent = &ConferenceStatusCallbackEvent
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceStatusCallbackMethod(ConferenceStatusCallbackMethod string) *UpdateWorkerReservationParams {
	params.ConferenceStatusCallbackMethod = &ConferenceStatusCallbackMethod
	return params
}
func (params *UpdateWorkerReservationParams) SetConferenceTrim(ConferenceTrim string) *UpdateWorkerReservationParams {
	params.ConferenceTrim = &ConferenceTrim
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeueFrom(DequeueFrom string) *UpdateWorkerReservationParams {
	params.DequeueFrom = &DequeueFrom
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeuePostWorkActivitySid(DequeuePostWorkActivitySid string) *UpdateWorkerReservationParams {
	params.DequeuePostWorkActivitySid = &DequeuePostWorkActivitySid
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeueRecord(DequeueRecord string) *UpdateWorkerReservationParams {
	params.DequeueRecord = &DequeueRecord
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeueStatusCallbackEvent(DequeueStatusCallbackEvent []string) *UpdateWorkerReservationParams {
	params.DequeueStatusCallbackEvent = &DequeueStatusCallbackEvent
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeueStatusCallbackUrl(DequeueStatusCallbackUrl string) *UpdateWorkerReservationParams {
	params.DequeueStatusCallbackUrl = &DequeueStatusCallbackUrl
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeueTimeout(DequeueTimeout int32) *UpdateWorkerReservationParams {
	params.DequeueTimeout = &DequeueTimeout
	return params
}
func (params *UpdateWorkerReservationParams) SetDequeueTo(DequeueTo string) *UpdateWorkerReservationParams {
	params.DequeueTo = &DequeueTo
	return params
}
func (params *UpdateWorkerReservationParams) SetEarlyMedia(EarlyMedia bool) *UpdateWorkerReservationParams {
	params.EarlyMedia = &EarlyMedia
	return params
}
func (params *UpdateWorkerReservationParams) SetEndConferenceOnCustomerExit(EndConferenceOnCustomerExit bool) *UpdateWorkerReservationParams {
	params.EndConferenceOnCustomerExit = &EndConferenceOnCustomerExit
	return params
}
func (params *UpdateWorkerReservationParams) SetEndConferenceOnExit(EndConferenceOnExit bool) *UpdateWorkerReservationParams {
	params.EndConferenceOnExit = &EndConferenceOnExit
	return params
}
func (params *UpdateWorkerReservationParams) SetFrom(From string) *UpdateWorkerReservationParams {
	params.From = &From
	return params
}
func (params *UpdateWorkerReservationParams) SetInstruction(Instruction string) *UpdateWorkerReservationParams {
	params.Instruction = &Instruction
	return params
}
func (params *UpdateWorkerReservationParams) SetMaxParticipants(MaxParticipants int32) *UpdateWorkerReservationParams {
	params.MaxParticipants = &MaxParticipants
	return params
}
func (params *UpdateWorkerReservationParams) SetMuted(Muted bool) *UpdateWorkerReservationParams {
	params.Muted = &Muted
	return params
}
func (params *UpdateWorkerReservationParams) SetPostWorkActivitySid(PostWorkActivitySid string) *UpdateWorkerReservationParams {
	params.PostWorkActivitySid = &PostWorkActivitySid
	return params
}
func (params *UpdateWorkerReservationParams) SetRecord(Record bool) *UpdateWorkerReservationParams {
	params.Record = &Record
	return params
}
func (params *UpdateWorkerReservationParams) SetRecordingChannels(RecordingChannels string) *UpdateWorkerReservationParams {
	params.RecordingChannels = &RecordingChannels
	return params
}
func (params *UpdateWorkerReservationParams) SetRecordingStatusCallback(RecordingStatusCallback string) *UpdateWorkerReservationParams {
	params.RecordingStatusCallback = &RecordingStatusCallback
	return params
}
func (params *UpdateWorkerReservationParams) SetRecordingStatusCallbackMethod(RecordingStatusCallbackMethod string) *UpdateWorkerReservationParams {
	params.RecordingStatusCallbackMethod = &RecordingStatusCallbackMethod
	return params
}
func (params *UpdateWorkerReservationParams) SetRedirectAccept(RedirectAccept bool) *UpdateWorkerReservationParams {
	params.RedirectAccept = &RedirectAccept
	return params
}
func (params *UpdateWorkerReservationParams) SetRedirectCallSid(RedirectCallSid string) *UpdateWorkerReservationParams {
	params.RedirectCallSid = &RedirectCallSid
	return params
}
func (params *UpdateWorkerReservationParams) SetRedirectUrl(RedirectUrl string) *UpdateWorkerReservationParams {
	params.RedirectUrl = &RedirectUrl
	return params
}
func (params *UpdateWorkerReservationParams) SetRegion(Region string) *UpdateWorkerReservationParams {
	params.Region = &Region
	return params
}
func (params *UpdateWorkerReservationParams) SetReservationStatus(ReservationStatus string) *UpdateWorkerReservationParams {
	params.ReservationStatus = &ReservationStatus
	return params
}
func (params *UpdateWorkerReservationParams) SetSipAuthPassword(SipAuthPassword string) *UpdateWorkerReservationParams {
	params.SipAuthPassword = &SipAuthPassword
	return params
}
func (params *UpdateWorkerReservationParams) SetSipAuthUsername(SipAuthUsername string) *UpdateWorkerReservationParams {
	params.SipAuthUsername = &SipAuthUsername
	return params
}
func (params *UpdateWorkerReservationParams) SetStartConferenceOnEnter(StartConferenceOnEnter bool) *UpdateWorkerReservationParams {
	params.StartConferenceOnEnter = &StartConferenceOnEnter
	return params
}
func (params *UpdateWorkerReservationParams) SetStatusCallback(StatusCallback string) *UpdateWorkerReservationParams {
	params.StatusCallback = &StatusCallback
	return params
}
func (params *UpdateWorkerReservationParams) SetStatusCallbackEvent(StatusCallbackEvent []string) *UpdateWorkerReservationParams {
	params.StatusCallbackEvent = &StatusCallbackEvent
	return params
}
func (params *UpdateWorkerReservationParams) SetStatusCallbackMethod(StatusCallbackMethod string) *UpdateWorkerReservationParams {
	params.StatusCallbackMethod = &StatusCallbackMethod
	return params
}
func (params *UpdateWorkerReservationParams) SetTimeout(Timeout int32) *UpdateWorkerReservationParams {
	params.Timeout = &Timeout
	return params
}
func (params *UpdateWorkerReservationParams) SetTo(To string) *UpdateWorkerReservationParams {
	params.To = &To
	return params
}
func (params *UpdateWorkerReservationParams) SetWaitMethod(WaitMethod string) *UpdateWorkerReservationParams {
	params.WaitMethod = &WaitMethod
	return params
}
func (params *UpdateWorkerReservationParams) SetWaitUrl(WaitUrl string) *UpdateWorkerReservationParams {
	params.WaitUrl = &WaitUrl
	return params
}
func (params *UpdateWorkerReservationParams) SetWorkerActivitySid(WorkerActivitySid string) *UpdateWorkerReservationParams {
	params.WorkerActivitySid = &WorkerActivitySid
	return params
}

// UpdateWorkerReservation Method for UpdateWorkerReservation
//
// param: WorkspaceSid The SID of the Workspace with the WorkerReservation resources to update.
//
// param: WorkerSid The SID of the reserved Worker resource with the WorkerReservation resources to update.
//
// param: Sid The SID of the WorkerReservation resource to update.
//
// param: optional nil or *UpdateWorkerReservationParams - Optional Parameters:
//
// param: "Beep" (string) - Whether to play a notification beep when the participant joins or when to play a beep. Can be: `true`, `false`, `onEnter`, or `onExit`. The default value is `true`.
//
// param: "BeepOnCustomerEntrance" (bool) - Whether to play a notification beep when the customer joins.
//
// param: "CallAccept" (bool) - Whether to accept a reservation when executing a Call instruction.
//
// param: "CallFrom" (string) - The Caller ID of the outbound call when executing a Call instruction.
//
// param: "CallRecord" (string) - Whether to record both legs of a call when executing a Call instruction.
//
// param: "CallStatusCallbackUrl" (string) - The URL to call for the completed call event when executing a Call instruction.
//
// param: "CallTimeout" (int32) - The timeout for a call when executing a Call instruction.
//
// param: "CallTo" (string) - The contact URI of the worker when executing a Call instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
//
// param: "CallUrl" (string) - TwiML URI executed on answering the worker's leg as a result of the Call instruction.
//
// param: "ConferenceRecord" (string) - Whether to record the conference the participant is joining or when to record the conference. Can be: `true`, `false`, `record-from-start`, and `do-not-record`. The default value is `false`.
//
// param: "ConferenceRecordingStatusCallback" (string) - The URL we should call using the `conference_recording_status_callback_method` when the conference recording is available.
//
// param: "ConferenceRecordingStatusCallbackMethod" (string) - The HTTP method we should use to call `conference_recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
//
// param: "ConferenceStatusCallback" (string) - The URL we should call using the `conference_status_callback_method` when the conference events in `conference_status_callback_event` occur. Only the value set by the first participant to join the conference is used. Subsequent `conference_status_callback` values are ignored.
//
// param: "ConferenceStatusCallbackEvent" ([]string) - The conference status events that we will send to `conference_status_callback`. Can be: `start`, `end`, `join`, `leave`, `mute`, `hold`, `speaker`.
//
// param: "ConferenceStatusCallbackMethod" (string) - The HTTP method we should use to call `conference_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
//
// param: "ConferenceTrim" (string) - Whether to trim leading and trailing silence from your recorded conference audio files. Can be: `trim-silence` or `do-not-trim` and defaults to `trim-silence`.
//
// param: "DequeueFrom" (string) - The caller ID of the call to the worker when executing a Dequeue instruction.
//
// param: "DequeuePostWorkActivitySid" (string) - The SID of the Activity resource to start after executing a Dequeue instruction.
//
// param: "DequeueRecord" (string) - Whether to record both legs of a call when executing a Dequeue instruction or which leg to record.
//
// param: "DequeueStatusCallbackEvent" ([]string) - The call progress events sent via webhooks as a result of a Dequeue instruction.
//
// param: "DequeueStatusCallbackUrl" (string) - The callback URL for completed call event when executing a Dequeue instruction.
//
// param: "DequeueTimeout" (int32) - The timeout for call when executing a Dequeue instruction.
//
// param: "DequeueTo" (string) - The contact URI of the worker when executing a Dequeue instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
//
// param: "EarlyMedia" (bool) - Whether to allow an agent to hear the state of the outbound call, including ringing or disconnect messages. The default is `true`.
//
// param: "EndConferenceOnCustomerExit" (bool) - Whether to end the conference when the customer leaves.
//
// param: "EndConferenceOnExit" (bool) - Whether to end the conference when the agent leaves.
//
// param: "From" (string) - The caller ID of the call to the worker when executing a Conference instruction.
//
// param: "Instruction" (string) - The assignment instruction for the reservation.
//
// param: "MaxParticipants" (int32) - The maximum number of participants allowed in the conference. Can be a positive integer from `2` to `250`. The default value is `250`.
//
// param: "Muted" (bool) - Whether the agent is muted in the conference. Defaults to `false`.
//
// param: "PostWorkActivitySid" (string) - The new worker activity SID after executing a Conference instruction.
//
// param: "Record" (bool) - Whether to record the participant and their conferences, including the time between conferences. Can be `true` or `false` and the default is `false`.
//
// param: "RecordingChannels" (string) - The recording channels for the final recording. Can be: `mono` or `dual` and the default is `mono`.
//
// param: "RecordingStatusCallback" (string) - The URL that we should call using the `recording_status_callback_method` when the recording status changes.
//
// param: "RecordingStatusCallbackMethod" (string) - The HTTP method we should use when we call `recording_status_callback`. Can be: `GET` or `POST` and defaults to `POST`.
//
// param: "RedirectAccept" (bool) - Whether the reservation should be accepted when executing a Redirect instruction.
//
// param: "RedirectCallSid" (string) - The Call SID of the call parked in the queue when executing a Redirect instruction.
//
// param: "RedirectUrl" (string) - TwiML URI to redirect the call to when executing the Redirect instruction.
//
// param: "Region" (string) - The [region](https://support.twilio.com/hc/en-us/articles/223132167-How-global-low-latency-routing-and-region-selection-work-for-conferences-and-Client-calls) where we should mix the recorded audio. Can be:`us1`, `ie1`, `de1`, `sg1`, `br1`, `au1`, or `jp1`.
//
// param: "ReservationStatus" (string) - The new status of the reservation. Can be: `pending`, `accepted`, `rejected`, `timeout`, `canceled`, or `rescinded`.
//
// param: "SipAuthPassword" (string) - The SIP password for authentication.
//
// param: "SipAuthUsername" (string) - The SIP username used for authentication.
//
// param: "StartConferenceOnEnter" (bool) - Whether to start the conference when the participant joins, if it has not already started. Can be: `true` or `false` and the default is `true`. If `false` and the conference has not started, the participant is muted and hears background music until another participant starts the conference.
//
// param: "StatusCallback" (string) - The URL we should call using the `status_callback_method` to send status information to your application.
//
// param: "StatusCallbackEvent" ([]string) - The call progress events that we will send to `status_callback`. Can be: `initiated`, `ringing`, `answered`, or `completed`.
//
// param: "StatusCallbackMethod" (string) - The HTTP method we should use to call `status_callback`. Can be: `POST` or `GET` and the default is `POST`.
//
// param: "Timeout" (int32) - The timeout for a call when executing a Conference instruction.
//
// param: "To" (string) - The Contact URI of the worker when executing a Conference instruction. Can be the URI of the Twilio Client, the SIP URI for Programmable SIP, or the [E.164](https://www.twilio.com/docs/glossary/what-e164) formatted phone number, depending on the destination.
//
// param: "WaitMethod" (string) - The HTTP method we should use to call `wait_url`. Can be `GET` or `POST` and the default is `POST`. When using a static audio file, this should be `GET` so that we can cache the file.
//
// param: "WaitUrl" (string) - The URL we should call using the `wait_method` for the music to play while participants are waiting for the conference to start. The default value is the URL of our standard hold music. [Learn more about hold music](https://www.twilio.com/labs/twimlets/holdmusic).
//
// param: "WorkerActivitySid" (string) - The new worker activity SID if rejecting a reservation.
//
// return: TaskrouterV1WorkspaceWorkerWorkerReservation
func (c *DefaultApiService) UpdateWorkerReservation(WorkspaceSid string, WorkerSid string, Sid string, params *UpdateWorkerReservationParams) (*TaskrouterV1WorkspaceWorkerWorkerReservation, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"WorkerSid"+"}", WorkerSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Beep != nil {
		data.Set("Beep", *params.Beep)
	}
	if params != nil && params.BeepOnCustomerEntrance != nil {
		data.Set("BeepOnCustomerEntrance", fmt.Sprint(*params.BeepOnCustomerEntrance))
	}
	if params != nil && params.CallAccept != nil {
		data.Set("CallAccept", fmt.Sprint(*params.CallAccept))
	}
	if params != nil && params.CallFrom != nil {
		data.Set("CallFrom", *params.CallFrom)
	}
	if params != nil && params.CallRecord != nil {
		data.Set("CallRecord", *params.CallRecord)
	}
	if params != nil && params.CallStatusCallbackUrl != nil {
		data.Set("CallStatusCallbackUrl", *params.CallStatusCallbackUrl)
	}
	if params != nil && params.CallTimeout != nil {
		data.Set("CallTimeout", fmt.Sprint(*params.CallTimeout))
	}
	if params != nil && params.CallTo != nil {
		data.Set("CallTo", *params.CallTo)
	}
	if params != nil && params.CallUrl != nil {
		data.Set("CallUrl", *params.CallUrl)
	}
	if params != nil && params.ConferenceRecord != nil {
		data.Set("ConferenceRecord", *params.ConferenceRecord)
	}
	if params != nil && params.ConferenceRecordingStatusCallback != nil {
		data.Set("ConferenceRecordingStatusCallback", *params.ConferenceRecordingStatusCallback)
	}
	if params != nil && params.ConferenceRecordingStatusCallbackMethod != nil {
		data.Set("ConferenceRecordingStatusCallbackMethod", *params.ConferenceRecordingStatusCallbackMethod)
	}
	if params != nil && params.ConferenceStatusCallback != nil {
		data.Set("ConferenceStatusCallback", *params.ConferenceStatusCallback)
	}
	if params != nil && params.ConferenceStatusCallbackEvent != nil {
		data.Set("ConferenceStatusCallbackEvent", strings.Join(*params.ConferenceStatusCallbackEvent, ","))
	}
	if params != nil && params.ConferenceStatusCallbackMethod != nil {
		data.Set("ConferenceStatusCallbackMethod", *params.ConferenceStatusCallbackMethod)
	}
	if params != nil && params.ConferenceTrim != nil {
		data.Set("ConferenceTrim", *params.ConferenceTrim)
	}
	if params != nil && params.DequeueFrom != nil {
		data.Set("DequeueFrom", *params.DequeueFrom)
	}
	if params != nil && params.DequeuePostWorkActivitySid != nil {
		data.Set("DequeuePostWorkActivitySid", *params.DequeuePostWorkActivitySid)
	}
	if params != nil && params.DequeueRecord != nil {
		data.Set("DequeueRecord", *params.DequeueRecord)
	}
	if params != nil && params.DequeueStatusCallbackEvent != nil {
		data.Set("DequeueStatusCallbackEvent", strings.Join(*params.DequeueStatusCallbackEvent, ","))
	}
	if params != nil && params.DequeueStatusCallbackUrl != nil {
		data.Set("DequeueStatusCallbackUrl", *params.DequeueStatusCallbackUrl)
	}
	if params != nil && params.DequeueTimeout != nil {
		data.Set("DequeueTimeout", fmt.Sprint(*params.DequeueTimeout))
	}
	if params != nil && params.DequeueTo != nil {
		data.Set("DequeueTo", *params.DequeueTo)
	}
	if params != nil && params.EarlyMedia != nil {
		data.Set("EarlyMedia", fmt.Sprint(*params.EarlyMedia))
	}
	if params != nil && params.EndConferenceOnCustomerExit != nil {
		data.Set("EndConferenceOnCustomerExit", fmt.Sprint(*params.EndConferenceOnCustomerExit))
	}
	if params != nil && params.EndConferenceOnExit != nil {
		data.Set("EndConferenceOnExit", fmt.Sprint(*params.EndConferenceOnExit))
	}
	if params != nil && params.From != nil {
		data.Set("From", *params.From)
	}
	if params != nil && params.Instruction != nil {
		data.Set("Instruction", *params.Instruction)
	}
	if params != nil && params.MaxParticipants != nil {
		data.Set("MaxParticipants", fmt.Sprint(*params.MaxParticipants))
	}
	if params != nil && params.Muted != nil {
		data.Set("Muted", fmt.Sprint(*params.Muted))
	}
	if params != nil && params.PostWorkActivitySid != nil {
		data.Set("PostWorkActivitySid", *params.PostWorkActivitySid)
	}
	if params != nil && params.Record != nil {
		data.Set("Record", fmt.Sprint(*params.Record))
	}
	if params != nil && params.RecordingChannels != nil {
		data.Set("RecordingChannels", *params.RecordingChannels)
	}
	if params != nil && params.RecordingStatusCallback != nil {
		data.Set("RecordingStatusCallback", *params.RecordingStatusCallback)
	}
	if params != nil && params.RecordingStatusCallbackMethod != nil {
		data.Set("RecordingStatusCallbackMethod", *params.RecordingStatusCallbackMethod)
	}
	if params != nil && params.RedirectAccept != nil {
		data.Set("RedirectAccept", fmt.Sprint(*params.RedirectAccept))
	}
	if params != nil && params.RedirectCallSid != nil {
		data.Set("RedirectCallSid", *params.RedirectCallSid)
	}
	if params != nil && params.RedirectUrl != nil {
		data.Set("RedirectUrl", *params.RedirectUrl)
	}
	if params != nil && params.Region != nil {
		data.Set("Region", *params.Region)
	}
	if params != nil && params.ReservationStatus != nil {
		data.Set("ReservationStatus", *params.ReservationStatus)
	}
	if params != nil && params.SipAuthPassword != nil {
		data.Set("SipAuthPassword", *params.SipAuthPassword)
	}
	if params != nil && params.SipAuthUsername != nil {
		data.Set("SipAuthUsername", *params.SipAuthUsername)
	}
	if params != nil && params.StartConferenceOnEnter != nil {
		data.Set("StartConferenceOnEnter", fmt.Sprint(*params.StartConferenceOnEnter))
	}
	if params != nil && params.StatusCallback != nil {
		data.Set("StatusCallback", *params.StatusCallback)
	}
	if params != nil && params.StatusCallbackEvent != nil {
		data.Set("StatusCallbackEvent", strings.Join(*params.StatusCallbackEvent, ","))
	}
	if params != nil && params.StatusCallbackMethod != nil {
		data.Set("StatusCallbackMethod", *params.StatusCallbackMethod)
	}
	if params != nil && params.Timeout != nil {
		data.Set("Timeout", fmt.Sprint(*params.Timeout))
	}
	if params != nil && params.To != nil {
		data.Set("To", *params.To)
	}
	if params != nil && params.WaitMethod != nil {
		data.Set("WaitMethod", *params.WaitMethod)
	}
	if params != nil && params.WaitUrl != nil {
		data.Set("WaitUrl", *params.WaitUrl)
	}
	if params != nil && params.WorkerActivitySid != nil {
		data.Set("WorkerActivitySid", *params.WorkerActivitySid)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkerWorkerReservation{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateWorkflowParams Optional parameters for the method 'UpdateWorkflow'
type UpdateWorkflowParams struct {
	AssignmentCallbackUrl         *string `json:"AssignmentCallbackUrl,omitempty"`
	Configuration                 *string `json:"Configuration,omitempty"`
	FallbackAssignmentCallbackUrl *string `json:"FallbackAssignmentCallbackUrl,omitempty"`
	FriendlyName                  *string `json:"FriendlyName,omitempty"`
	ReEvaluateTasks               *string `json:"ReEvaluateTasks,omitempty"`
	TaskReservationTimeout        *int32  `json:"TaskReservationTimeout,omitempty"`
}

func (params *UpdateWorkflowParams) SetAssignmentCallbackUrl(AssignmentCallbackUrl string) *UpdateWorkflowParams {
	params.AssignmentCallbackUrl = &AssignmentCallbackUrl
	return params
}
func (params *UpdateWorkflowParams) SetConfiguration(Configuration string) *UpdateWorkflowParams {
	params.Configuration = &Configuration
	return params
}
func (params *UpdateWorkflowParams) SetFallbackAssignmentCallbackUrl(FallbackAssignmentCallbackUrl string) *UpdateWorkflowParams {
	params.FallbackAssignmentCallbackUrl = &FallbackAssignmentCallbackUrl
	return params
}
func (params *UpdateWorkflowParams) SetFriendlyName(FriendlyName string) *UpdateWorkflowParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateWorkflowParams) SetReEvaluateTasks(ReEvaluateTasks string) *UpdateWorkflowParams {
	params.ReEvaluateTasks = &ReEvaluateTasks
	return params
}
func (params *UpdateWorkflowParams) SetTaskReservationTimeout(TaskReservationTimeout int32) *UpdateWorkflowParams {
	params.TaskReservationTimeout = &TaskReservationTimeout
	return params
}

// UpdateWorkflow Method for UpdateWorkflow
//
// param: WorkspaceSid The SID of the Workspace with the Workflow to update.
//
// param: Sid The SID of the Workflow resource to update.
//
// param: optional nil or *UpdateWorkflowParams - Optional Parameters:
//
// param: "AssignmentCallbackUrl" (string) - The URL from your application that will process task assignment events. See [Handling Task Assignment Callback](https://www.twilio.com/docs/taskrouter/handle-assignment-callbacks) for more details.
//
// param: "Configuration" (string) - A JSON string that contains the rules to apply to the Workflow. See [Configuring Workflows](https://www.twilio.com/docs/taskrouter/workflow-configuration) for more information.
//
// param: "FallbackAssignmentCallbackUrl" (string) - The URL that we should call when a call to the `assignment_callback_url` fails.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Workflow resource. For example, `Inbound Call Workflow` or `2014 Outbound Campaign`.
//
// param: "ReEvaluateTasks" (string) - Whether or not to re-evaluate Tasks. The default is `false`, which means Tasks in the Workflow will not be processed through the assignment loop again.
//
// param: "TaskReservationTimeout" (int32) - How long TaskRouter will wait for a confirmation response from your application after it assigns a Task to a Worker. Can be up to `86,400` (24 hours) and the default is `120`.
//
// return: TaskrouterV1WorkspaceWorkflow
func (c *DefaultApiService) UpdateWorkflow(WorkspaceSid string, Sid string, params *UpdateWorkflowParams) (*TaskrouterV1WorkspaceWorkflow, error) {
	path := "/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}"
	path = strings.Replace(path, "{"+"WorkspaceSid"+"}", WorkspaceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.AssignmentCallbackUrl != nil {
		data.Set("AssignmentCallbackUrl", *params.AssignmentCallbackUrl)
	}
	if params != nil && params.Configuration != nil {
		data.Set("Configuration", *params.Configuration)
	}
	if params != nil && params.FallbackAssignmentCallbackUrl != nil {
		data.Set("FallbackAssignmentCallbackUrl", *params.FallbackAssignmentCallbackUrl)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.ReEvaluateTasks != nil {
		data.Set("ReEvaluateTasks", *params.ReEvaluateTasks)
	}
	if params != nil && params.TaskReservationTimeout != nil {
		data.Set("TaskReservationTimeout", fmt.Sprint(*params.TaskReservationTimeout))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1WorkspaceWorkflow{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateWorkspaceParams Optional parameters for the method 'UpdateWorkspace'
type UpdateWorkspaceParams struct {
	DefaultActivitySid   *string `json:"DefaultActivitySid,omitempty"`
	EventCallbackUrl     *string `json:"EventCallbackUrl,omitempty"`
	EventsFilter         *string `json:"EventsFilter,omitempty"`
	FriendlyName         *string `json:"FriendlyName,omitempty"`
	MultiTaskEnabled     *bool   `json:"MultiTaskEnabled,omitempty"`
	PrioritizeQueueOrder *string `json:"PrioritizeQueueOrder,omitempty"`
	TimeoutActivitySid   *string `json:"TimeoutActivitySid,omitempty"`
}

func (params *UpdateWorkspaceParams) SetDefaultActivitySid(DefaultActivitySid string) *UpdateWorkspaceParams {
	params.DefaultActivitySid = &DefaultActivitySid
	return params
}
func (params *UpdateWorkspaceParams) SetEventCallbackUrl(EventCallbackUrl string) *UpdateWorkspaceParams {
	params.EventCallbackUrl = &EventCallbackUrl
	return params
}
func (params *UpdateWorkspaceParams) SetEventsFilter(EventsFilter string) *UpdateWorkspaceParams {
	params.EventsFilter = &EventsFilter
	return params
}
func (params *UpdateWorkspaceParams) SetFriendlyName(FriendlyName string) *UpdateWorkspaceParams {
	params.FriendlyName = &FriendlyName
	return params
}
func (params *UpdateWorkspaceParams) SetMultiTaskEnabled(MultiTaskEnabled bool) *UpdateWorkspaceParams {
	params.MultiTaskEnabled = &MultiTaskEnabled
	return params
}
func (params *UpdateWorkspaceParams) SetPrioritizeQueueOrder(PrioritizeQueueOrder string) *UpdateWorkspaceParams {
	params.PrioritizeQueueOrder = &PrioritizeQueueOrder
	return params
}
func (params *UpdateWorkspaceParams) SetTimeoutActivitySid(TimeoutActivitySid string) *UpdateWorkspaceParams {
	params.TimeoutActivitySid = &TimeoutActivitySid
	return params
}

// UpdateWorkspace Method for UpdateWorkspace
//
// param: Sid The SID of the Workspace resource to update.
//
// param: optional nil or *UpdateWorkspaceParams - Optional Parameters:
//
// param: "DefaultActivitySid" (string) - The SID of the Activity that will be used when new Workers are created in the Workspace.
//
// param: "EventCallbackUrl" (string) - The URL we should call when an event occurs. See [Workspace Events](https://www.twilio.com/docs/taskrouter/api/event) for more information.
//
// param: "EventsFilter" (string) - The list of Workspace events for which to call event_callback_url. For example if `EventsFilter=task.created,task.canceled,worker.activity.update`, then TaskRouter will call event_callback_url only when a task is created, canceled, or a Worker activity is updated.
//
// param: "FriendlyName" (string) - A descriptive string that you create to describe the Workspace resource. For example: `Sales Call Center` or `Customer Support Team`.
//
// param: "MultiTaskEnabled" (bool) - Whether to enable multi-tasking. Can be: `true` to enable multi-tasking, or `false` to disable it. The default is `false`. Multi-tasking allows Workers to handle multiple Tasks simultaneously. When enabled (`true`), each Worker can receive parallel reservations up to the per-channel maximums defined in the Workers section. Otherwise, each Worker will only receive a new reservation when the previous task is completed. Learn more at [Multitasking](https://www.twilio.com/docs/taskrouter/multitasking).
//
// param: "PrioritizeQueueOrder" (string) - The type of TaskQueue to prioritize when Workers are receiving Tasks from both types of TaskQueues. Can be: `LIFO` or `FIFO` and the default is `FIFO`. For more information, see [Queue Ordering](https://www.twilio.com/docs/taskrouter/queue-ordering-last-first-out-lifo).
//
// param: "TimeoutActivitySid" (string) - The SID of the Activity that will be assigned to a Worker when a Task reservation times out without a response.
//
// return: TaskrouterV1Workspace
func (c *DefaultApiService) UpdateWorkspace(Sid string, params *UpdateWorkspaceParams) (*TaskrouterV1Workspace, error) {
	path := "/v1/Workspaces/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.DefaultActivitySid != nil {
		data.Set("DefaultActivitySid", *params.DefaultActivitySid)
	}
	if params != nil && params.EventCallbackUrl != nil {
		data.Set("EventCallbackUrl", *params.EventCallbackUrl)
	}
	if params != nil && params.EventsFilter != nil {
		data.Set("EventsFilter", *params.EventsFilter)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.MultiTaskEnabled != nil {
		data.Set("MultiTaskEnabled", fmt.Sprint(*params.MultiTaskEnabled))
	}
	if params != nil && params.PrioritizeQueueOrder != nil {
		data.Set("PrioritizeQueueOrder", *params.PrioritizeQueueOrder)
	}
	if params != nil && params.TimeoutActivitySid != nil {
		data.Set("TimeoutActivitySid", *params.TimeoutActivitySid)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &TaskrouterV1Workspace{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}
