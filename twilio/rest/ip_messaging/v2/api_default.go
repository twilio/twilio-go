/*
 * Twilio - Ip_messaging
 *
 * This is the public Twilio REST API.
 *
 * API version: 1.12.0
 * Contact: support@twilio.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"time"

	twilio "github.com/twilio/twilio-go/client"
)

type DefaultApiService struct {
	baseURL string
	client  *twilio.Client
}

func NewDefaultApiService(client *twilio.Client) *DefaultApiService {
	return &DefaultApiService{
		client:  client,
		baseURL: "https://ip-messaging.twilio.com",
	}
}

// CreateChannelParams Optional parameters for the method 'CreateChannel'
type CreateChannelParams struct {
	XTwilioWebhookEnabled *string    `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes            *string    `json:"Attributes,omitempty"`
	CreatedBy             *string    `json:"CreatedBy,omitempty"`
	DateCreated           *time.Time `json:"DateCreated,omitempty"`
	DateUpdated           *time.Time `json:"DateUpdated,omitempty"`
	FriendlyName          *string    `json:"FriendlyName,omitempty"`
	Type                  *string    `json:"Type,omitempty"`
	UniqueName            *string    `json:"UniqueName,omitempty"`
}

/*
* CreateChannel Method for CreateChannel
* @param ServiceSid
* @param optional nil or *CreateChannelParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "CreatedBy" (string) -
* @param "DateCreated" (time.Time) -
* @param "DateUpdated" (time.Time) -
* @param "FriendlyName" (string) -
* @param "Type" (string) -
* @param "UniqueName" (string) -
* @return IpMessagingV2ServiceChannel
 */
func (c *DefaultApiService) CreateChannel(ServiceSid string, params *CreateChannelParams) (*IpMessagingV2ServiceChannel, error) {
	path := "/v2/Services/{ServiceSid}/Channels"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.CreatedBy != nil {
		data.Set("CreatedBy", *params.CreatedBy)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint(*params.DateCreated))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint(*params.DateUpdated))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateChannelWebhookParams Optional parameters for the method 'CreateChannelWebhook'
type CreateChannelWebhookParams struct {
	ConfigurationFilters    *[]string `json:"Configuration.Filters,omitempty"`
	ConfigurationFlowSid    *string   `json:"Configuration.FlowSid,omitempty"`
	ConfigurationMethod     *string   `json:"Configuration.Method,omitempty"`
	ConfigurationRetryCount *int32    `json:"Configuration.RetryCount,omitempty"`
	ConfigurationTriggers   *[]string `json:"Configuration.Triggers,omitempty"`
	ConfigurationUrl        *string   `json:"Configuration.Url,omitempty"`
	Type                    *string   `json:"Type,omitempty"`
}

/*
* CreateChannelWebhook Method for CreateChannelWebhook
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *CreateChannelWebhookParams - Optional Parameters:
* @param "ConfigurationFilters" ([]string) -
* @param "ConfigurationFlowSid" (string) -
* @param "ConfigurationMethod" (string) -
* @param "ConfigurationRetryCount" (int32) -
* @param "ConfigurationTriggers" ([]string) -
* @param "ConfigurationUrl" (string) -
* @param "Type" (string) -
* @return IpMessagingV2ServiceChannelChannelWebhook
 */
func (c *DefaultApiService) CreateChannelWebhook(ServiceSid string, ChannelSid string, params *CreateChannelWebhookParams) (*IpMessagingV2ServiceChannelChannelWebhook, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.ConfigurationFilters != nil {
		data.Set("ConfigurationFilters", strings.Join(*params.ConfigurationFilters, ","))
	}
	if params != nil && params.ConfigurationFlowSid != nil {
		data.Set("ConfigurationFlowSid", *params.ConfigurationFlowSid)
	}
	if params != nil && params.ConfigurationMethod != nil {
		data.Set("ConfigurationMethod", *params.ConfigurationMethod)
	}
	if params != nil && params.ConfigurationRetryCount != nil {
		data.Set("ConfigurationRetryCount", fmt.Sprint(*params.ConfigurationRetryCount))
	}
	if params != nil && params.ConfigurationTriggers != nil {
		data.Set("ConfigurationTriggers", strings.Join(*params.ConfigurationTriggers, ","))
	}
	if params != nil && params.ConfigurationUrl != nil {
		data.Set("ConfigurationUrl", *params.ConfigurationUrl)
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelChannelWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateCredentialParams Optional parameters for the method 'CreateCredential'
type CreateCredentialParams struct {
	ApiKey       *string `json:"ApiKey,omitempty"`
	Certificate  *string `json:"Certificate,omitempty"`
	FriendlyName *string `json:"FriendlyName,omitempty"`
	PrivateKey   *string `json:"PrivateKey,omitempty"`
	Sandbox      *bool   `json:"Sandbox,omitempty"`
	Secret       *string `json:"Secret,omitempty"`
	Type         *string `json:"Type,omitempty"`
}

/*
* CreateCredential Method for CreateCredential
* @param optional nil or *CreateCredentialParams - Optional Parameters:
* @param "ApiKey" (string) -
* @param "Certificate" (string) -
* @param "FriendlyName" (string) -
* @param "PrivateKey" (string) -
* @param "Sandbox" (bool) -
* @param "Secret" (string) -
* @param "Type" (string) -
* @return IpMessagingV2Credential
 */
func (c *DefaultApiService) CreateCredential(params *CreateCredentialParams) (*IpMessagingV2Credential, error) {
	path := "/v2/Credentials"

	data := url.Values{}
	headers := 0

	if params != nil && params.ApiKey != nil {
		data.Set("ApiKey", *params.ApiKey)
	}
	if params != nil && params.Certificate != nil {
		data.Set("Certificate", *params.Certificate)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PrivateKey != nil {
		data.Set("PrivateKey", *params.PrivateKey)
	}
	if params != nil && params.Sandbox != nil {
		data.Set("Sandbox", fmt.Sprint(*params.Sandbox))
	}
	if params != nil && params.Secret != nil {
		data.Set("Secret", *params.Secret)
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2Credential{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateInviteParams Optional parameters for the method 'CreateInvite'
type CreateInviteParams struct {
	Identity *string `json:"Identity,omitempty"`
	RoleSid  *string `json:"RoleSid,omitempty"`
}

/*
* CreateInvite Method for CreateInvite
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *CreateInviteParams - Optional Parameters:
* @param "Identity" (string) -
* @param "RoleSid" (string) -
* @return IpMessagingV2ServiceChannelInvite
 */
func (c *DefaultApiService) CreateInvite(ServiceSid string, ChannelSid string, params *CreateInviteParams) (*IpMessagingV2ServiceChannelInvite, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelInvite{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateMemberParams Optional parameters for the method 'CreateMember'
type CreateMemberParams struct {
	XTwilioWebhookEnabled    *string    `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes               *string    `json:"Attributes,omitempty"`
	DateCreated              *time.Time `json:"DateCreated,omitempty"`
	DateUpdated              *time.Time `json:"DateUpdated,omitempty"`
	Identity                 *string    `json:"Identity,omitempty"`
	LastConsumedMessageIndex *int32     `json:"LastConsumedMessageIndex,omitempty"`
	LastConsumptionTimestamp *time.Time `json:"LastConsumptionTimestamp,omitempty"`
	RoleSid                  *string    `json:"RoleSid,omitempty"`
}

/*
* CreateMember Method for CreateMember
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *CreateMemberParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "DateCreated" (time.Time) -
* @param "DateUpdated" (time.Time) -
* @param "Identity" (string) -
* @param "LastConsumedMessageIndex" (*int32) -
* @param "LastConsumptionTimestamp" (time.Time) -
* @param "RoleSid" (string) -
* @return IpMessagingV2ServiceChannelMember
 */
func (c *DefaultApiService) CreateMember(ServiceSid string, ChannelSid string, params *CreateMemberParams) (*IpMessagingV2ServiceChannelMember, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint(*params.DateCreated))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint(*params.DateUpdated))
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.LastConsumedMessageIndex != nil {
		data.Set("LastConsumedMessageIndex", fmt.Sprint(*params.LastConsumedMessageIndex))
	}
	if params != nil && params.LastConsumptionTimestamp != nil {
		data.Set("LastConsumptionTimestamp", fmt.Sprint(*params.LastConsumptionTimestamp))
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelMember{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateMessageParams Optional parameters for the method 'CreateMessage'
type CreateMessageParams struct {
	XTwilioWebhookEnabled *string    `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes            *string    `json:"Attributes,omitempty"`
	Body                  *string    `json:"Body,omitempty"`
	DateCreated           *time.Time `json:"DateCreated,omitempty"`
	DateUpdated           *time.Time `json:"DateUpdated,omitempty"`
	From                  *string    `json:"From,omitempty"`
	LastUpdatedBy         *string    `json:"LastUpdatedBy,omitempty"`
	MediaSid              *string    `json:"MediaSid,omitempty"`
}

/*
* CreateMessage Method for CreateMessage
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *CreateMessageParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "Body" (string) -
* @param "DateCreated" (time.Time) -
* @param "DateUpdated" (time.Time) -
* @param "From" (string) -
* @param "LastUpdatedBy" (string) -
* @param "MediaSid" (string) -
* @return IpMessagingV2ServiceChannelMessage
 */
func (c *DefaultApiService) CreateMessage(ServiceSid string, ChannelSid string, params *CreateMessageParams) (*IpMessagingV2ServiceChannelMessage, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Body != nil {
		data.Set("Body", *params.Body)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint(*params.DateCreated))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint(*params.DateUpdated))
	}
	if params != nil && params.From != nil {
		data.Set("From", *params.From)
	}
	if params != nil && params.LastUpdatedBy != nil {
		data.Set("LastUpdatedBy", *params.LastUpdatedBy)
	}
	if params != nil && params.MediaSid != nil {
		data.Set("MediaSid", *params.MediaSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateRoleParams Optional parameters for the method 'CreateRole'
type CreateRoleParams struct {
	FriendlyName *string   `json:"FriendlyName,omitempty"`
	Permission   *[]string `json:"Permission,omitempty"`
	Type         *string   `json:"Type,omitempty"`
}

/*
* CreateRole Method for CreateRole
* @param ServiceSid
* @param optional nil or *CreateRoleParams - Optional Parameters:
* @param "FriendlyName" (string) -
* @param "Permission" ([]string) -
* @param "Type" (string) -
* @return IpMessagingV2ServiceRole
 */
func (c *DefaultApiService) CreateRole(ServiceSid string, params *CreateRoleParams) (*IpMessagingV2ServiceRole, error) {
	path := "/v2/Services/{ServiceSid}/Roles"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Permission != nil {
		data.Set("Permission", strings.Join(*params.Permission, ","))
	}
	if params != nil && params.Type != nil {
		data.Set("Type", *params.Type)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceRole{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateServiceParams Optional parameters for the method 'CreateService'
type CreateServiceParams struct {
	FriendlyName *string `json:"FriendlyName,omitempty"`
}

/*
* CreateService Method for CreateService
* @param optional nil or *CreateServiceParams - Optional Parameters:
* @param "FriendlyName" (string) -
* @return IpMessagingV2Service
 */
func (c *DefaultApiService) CreateService(params *CreateServiceParams) (*IpMessagingV2Service, error) {
	path := "/v2/Services"

	data := url.Values{}
	headers := 0

	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// CreateUserParams Optional parameters for the method 'CreateUser'
type CreateUserParams struct {
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes            *string `json:"Attributes,omitempty"`
	FriendlyName          *string `json:"FriendlyName,omitempty"`
	Identity              *string `json:"Identity,omitempty"`
	RoleSid               *string `json:"RoleSid,omitempty"`
}

/*
* CreateUser Method for CreateUser
* @param ServiceSid
* @param optional nil or *CreateUserParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "FriendlyName" (string) -
* @param "Identity" (string) -
* @param "RoleSid" (string) -
* @return IpMessagingV2ServiceUser
 */
func (c *DefaultApiService) CreateUser(ServiceSid string, params *CreateUserParams) (*IpMessagingV2ServiceUser, error) {
	path := "/v2/Services/{ServiceSid}/Users"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", *params.Identity)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceUser{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* DeleteBinding Method for DeleteBinding
* @param ServiceSid
* @param Sid
 */
func (c *DefaultApiService) DeleteBinding(ServiceSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Bindings/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteChannelParams Optional parameters for the method 'DeleteChannel'
type DeleteChannelParams struct {
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

/*
* DeleteChannel Method for DeleteChannel
* @param ServiceSid
* @param Sid
* @param optional nil or *DeleteChannelParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
 */
func (c *DefaultApiService) DeleteChannel(ServiceSid string, Sid string, params *DeleteChannelParams) error {
	path := "/v2/Services/{ServiceSid}/Channels/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteChannelWebhook Method for DeleteChannelWebhook
* @param ServiceSid
* @param ChannelSid
* @param Sid
 */
func (c *DefaultApiService) DeleteChannelWebhook(ServiceSid string, ChannelSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteCredential Method for DeleteCredential
* @param Sid
 */
func (c *DefaultApiService) DeleteCredential(Sid string) error {
	path := "/v2/Credentials/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteInvite Method for DeleteInvite
* @param ServiceSid
* @param ChannelSid
* @param Sid
 */
func (c *DefaultApiService) DeleteInvite(ServiceSid string, ChannelSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteMemberParams Optional parameters for the method 'DeleteMember'
type DeleteMemberParams struct {
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

/*
* DeleteMember Method for DeleteMember
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @param optional nil or *DeleteMemberParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
 */
func (c *DefaultApiService) DeleteMember(ServiceSid string, ChannelSid string, Sid string, params *DeleteMemberParams) error {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

// DeleteMessageParams Optional parameters for the method 'DeleteMessage'
type DeleteMessageParams struct {
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
}

/*
* DeleteMessage Method for DeleteMessage
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @param optional nil or *DeleteMessageParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
 */
func (c *DefaultApiService) DeleteMessage(ServiceSid string, ChannelSid string, Sid string, params *DeleteMessageParams) error {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteRole Method for DeleteRole
* @param ServiceSid
* @param Sid
 */
func (c *DefaultApiService) DeleteRole(ServiceSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Roles/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteService Method for DeleteService
* @param Sid
 */
func (c *DefaultApiService) DeleteService(Sid string) error {
	path := "/v2/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteUser Method for DeleteUser
* @param ServiceSid
* @param Sid
 */
func (c *DefaultApiService) DeleteUser(ServiceSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Users/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteUserBinding Method for DeleteUserBinding
* @param ServiceSid
* @param UserSid
* @param Sid
 */
func (c *DefaultApiService) DeleteUserBinding(ServiceSid string, UserSid string, Sid string) error {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* DeleteUserChannel Method for DeleteUserChannel
* @param ServiceSid
* @param UserSid
* @param ChannelSid
 */
func (c *DefaultApiService) DeleteUserChannel(ServiceSid string, UserSid string, ChannelSid string) error {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Delete(c.baseURL+path, data, headers)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	return nil
}

/*
* FetchBinding Method for FetchBinding
* @param ServiceSid
* @param Sid
* @return IpMessagingV2ServiceBinding
 */
func (c *DefaultApiService) FetchBinding(ServiceSid string, Sid string) (*IpMessagingV2ServiceBinding, error) {
	path := "/v2/Services/{ServiceSid}/Bindings/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceBinding{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchChannel Method for FetchChannel
* @param ServiceSid
* @param Sid
* @return IpMessagingV2ServiceChannel
 */
func (c *DefaultApiService) FetchChannel(ServiceSid string, Sid string) (*IpMessagingV2ServiceChannel, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchChannelWebhook Method for FetchChannelWebhook
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @return IpMessagingV2ServiceChannelChannelWebhook
 */
func (c *DefaultApiService) FetchChannelWebhook(ServiceSid string, ChannelSid string, Sid string) (*IpMessagingV2ServiceChannelChannelWebhook, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelChannelWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchCredential Method for FetchCredential
* @param Sid
* @return IpMessagingV2Credential
 */
func (c *DefaultApiService) FetchCredential(Sid string) (*IpMessagingV2Credential, error) {
	path := "/v2/Credentials/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2Credential{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchInvite Method for FetchInvite
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @return IpMessagingV2ServiceChannelInvite
 */
func (c *DefaultApiService) FetchInvite(ServiceSid string, ChannelSid string, Sid string) (*IpMessagingV2ServiceChannelInvite, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelInvite{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchMember Method for FetchMember
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @return IpMessagingV2ServiceChannelMember
 */
func (c *DefaultApiService) FetchMember(ServiceSid string, ChannelSid string, Sid string) (*IpMessagingV2ServiceChannelMember, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelMember{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchMessage Method for FetchMessage
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @return IpMessagingV2ServiceChannelMessage
 */
func (c *DefaultApiService) FetchMessage(ServiceSid string, ChannelSid string, Sid string) (*IpMessagingV2ServiceChannelMessage, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchRole Method for FetchRole
* @param ServiceSid
* @param Sid
* @return IpMessagingV2ServiceRole
 */
func (c *DefaultApiService) FetchRole(ServiceSid string, Sid string) (*IpMessagingV2ServiceRole, error) {
	path := "/v2/Services/{ServiceSid}/Roles/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceRole{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchService Method for FetchService
* @param Sid
* @return IpMessagingV2Service
 */
func (c *DefaultApiService) FetchService(Sid string) (*IpMessagingV2Service, error) {
	path := "/v2/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchUser Method for FetchUser
* @param ServiceSid
* @param Sid
* @return IpMessagingV2ServiceUser
 */
func (c *DefaultApiService) FetchUser(ServiceSid string, Sid string) (*IpMessagingV2ServiceUser, error) {
	path := "/v2/Services/{ServiceSid}/Users/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceUser{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchUserBinding Method for FetchUserBinding
* @param ServiceSid
* @param UserSid
* @param Sid
* @return IpMessagingV2ServiceUserUserBinding
 */
func (c *DefaultApiService) FetchUserBinding(ServiceSid string, UserSid string, Sid string) (*IpMessagingV2ServiceUserUserBinding, error) {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceUserUserBinding{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

/*
* FetchUserChannel Method for FetchUserChannel
* @param ServiceSid
* @param UserSid
* @param ChannelSid
* @return IpMessagingV2ServiceUserUserChannel
 */
func (c *DefaultApiService) FetchUserChannel(ServiceSid string, UserSid string, ChannelSid string) (*IpMessagingV2ServiceUserUserChannel, error) {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceUserUserChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListBindingParams Optional parameters for the method 'ListBinding'
type ListBindingParams struct {
	BindingType *[]string `json:"BindingType,omitempty"`
	Identity    *[]string `json:"Identity,omitempty"`
	PageSize    *int32    `json:"PageSize,omitempty"`
}

/*
* ListBinding Method for ListBinding
* @param ServiceSid
* @param optional nil or *ListBindingParams - Optional Parameters:
* @param "BindingType" ([]string) -
* @param "Identity" ([]string) -
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListBindingResponse
 */
func (c *DefaultApiService) ListBinding(ServiceSid string, params *ListBindingParams) (*ListBindingResponse, error) {
	path := "/v2/Services/{ServiceSid}/Bindings"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.BindingType != nil {
		data.Set("BindingType", strings.Join(*params.BindingType, ","))
	}
	if params != nil && params.Identity != nil {
		data.Set("Identity", strings.Join(*params.Identity, ","))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListBindingResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListChannelParams Optional parameters for the method 'ListChannel'
type ListChannelParams struct {
	Type     *[]string `json:"Type,omitempty"`
	PageSize *int32    `json:"PageSize,omitempty"`
}

/*
* ListChannel Method for ListChannel
* @param ServiceSid
* @param optional nil or *ListChannelParams - Optional Parameters:
* @param "Type" ([]string) -
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListChannelResponse
 */
func (c *DefaultApiService) ListChannel(ServiceSid string, params *ListChannelParams) (*ListChannelResponse, error) {
	path := "/v2/Services/{ServiceSid}/Channels"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.Type != nil {
		data.Set("Type", strings.Join(*params.Type, ","))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListChannelResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListChannelWebhookParams Optional parameters for the method 'ListChannelWebhook'
type ListChannelWebhookParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

/*
* ListChannelWebhook Method for ListChannelWebhook
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *ListChannelWebhookParams - Optional Parameters:
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListChannelWebhookResponse
 */
func (c *DefaultApiService) ListChannelWebhook(ServiceSid string, ChannelSid string, params *ListChannelWebhookParams) (*ListChannelWebhookResponse, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListChannelWebhookResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListCredentialParams Optional parameters for the method 'ListCredential'
type ListCredentialParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

/*
* ListCredential Method for ListCredential
* @param optional nil or *ListCredentialParams - Optional Parameters:
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListCredentialResponse
 */
func (c *DefaultApiService) ListCredential(params *ListCredentialParams) (*ListCredentialResponse, error) {
	path := "/v2/Credentials"

	data := url.Values{}
	headers := 0

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListCredentialResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListInviteParams Optional parameters for the method 'ListInvite'
type ListInviteParams struct {
	Identity *[]string `json:"Identity,omitempty"`
	PageSize *int32    `json:"PageSize,omitempty"`
}

/*
* ListInvite Method for ListInvite
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *ListInviteParams - Optional Parameters:
* @param "Identity" ([]string) -
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListInviteResponse
 */
func (c *DefaultApiService) ListInvite(ServiceSid string, ChannelSid string, params *ListInviteParams) (*ListInviteResponse, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.Identity != nil {
		data.Set("Identity", strings.Join(*params.Identity, ","))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListInviteResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListMemberParams Optional parameters for the method 'ListMember'
type ListMemberParams struct {
	Identity *[]string `json:"Identity,omitempty"`
	PageSize *int32    `json:"PageSize,omitempty"`
}

/*
* ListMember Method for ListMember
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *ListMemberParams - Optional Parameters:
* @param "Identity" ([]string) -
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListMemberResponse
 */
func (c *DefaultApiService) ListMember(ServiceSid string, ChannelSid string, params *ListMemberParams) (*ListMemberResponse, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.Identity != nil {
		data.Set("Identity", strings.Join(*params.Identity, ","))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListMemberResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListMessageParams Optional parameters for the method 'ListMessage'
type ListMessageParams struct {
	Order    *string `json:"Order,omitempty"`
	PageSize *int32  `json:"PageSize,omitempty"`
}

/*
* ListMessage Method for ListMessage
* @param ServiceSid
* @param ChannelSid
* @param optional nil or *ListMessageParams - Optional Parameters:
* @param "Order" (string) -
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListMessageResponse
 */
func (c *DefaultApiService) ListMessage(ServiceSid string, ChannelSid string, params *ListMessageParams) (*ListMessageResponse, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.Order != nil {
		data.Set("Order", *params.Order)
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListMessageResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListRoleParams Optional parameters for the method 'ListRole'
type ListRoleParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

/*
* ListRole Method for ListRole
* @param ServiceSid
* @param optional nil or *ListRoleParams - Optional Parameters:
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListRoleResponse
 */
func (c *DefaultApiService) ListRole(ServiceSid string, params *ListRoleParams) (*ListRoleResponse, error) {
	path := "/v2/Services/{ServiceSid}/Roles"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListRoleResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListServiceParams Optional parameters for the method 'ListService'
type ListServiceParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

/*
* ListService Method for ListService
* @param optional nil or *ListServiceParams - Optional Parameters:
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListServiceResponse
 */
func (c *DefaultApiService) ListService(params *ListServiceParams) (*ListServiceResponse, error) {
	path := "/v2/Services"

	data := url.Values{}
	headers := 0

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListServiceResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListUserParams Optional parameters for the method 'ListUser'
type ListUserParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

/*
* ListUser Method for ListUser
* @param ServiceSid
* @param optional nil or *ListUserParams - Optional Parameters:
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListUserResponse
 */
func (c *DefaultApiService) ListUser(ServiceSid string, params *ListUserParams) (*ListUserResponse, error) {
	path := "/v2/Services/{ServiceSid}/Users"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListUserResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListUserBindingParams Optional parameters for the method 'ListUserBinding'
type ListUserBindingParams struct {
	BindingType *[]string `json:"BindingType,omitempty"`
	PageSize    *int32    `json:"PageSize,omitempty"`
}

/*
* ListUserBinding Method for ListUserBinding
* @param ServiceSid
* @param UserSid
* @param optional nil or *ListUserBindingParams - Optional Parameters:
* @param "BindingType" ([]string) -
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListUserBindingResponse
 */
func (c *DefaultApiService) ListUserBinding(ServiceSid string, UserSid string, params *ListUserBindingParams) (*ListUserBindingResponse, error) {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Bindings"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.BindingType != nil {
		data.Set("BindingType", strings.Join(*params.BindingType, ","))
	}
	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListUserBindingResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// ListUserChannelParams Optional parameters for the method 'ListUserChannel'
type ListUserChannelParams struct {
	PageSize *int32 `json:"PageSize,omitempty"`
}

/*
* ListUserChannel Method for ListUserChannel
* @param ServiceSid
* @param UserSid
* @param optional nil or *ListUserChannelParams - Optional Parameters:
* @param "PageSize" (int32) - How many resources to return in each list page. The default is 50, and the maximum is 1000.
* @return ListUserChannelResponse
 */
func (c *DefaultApiService) ListUserChannel(ServiceSid string, UserSid string, params *ListUserChannelParams) (*ListUserChannelResponse, error) {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Channels"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.PageSize != nil {
		data.Set("PageSize", fmt.Sprint(*params.PageSize))
	}

	resp, err := c.client.Get(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &ListUserChannelResponse{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateChannelParams Optional parameters for the method 'UpdateChannel'
type UpdateChannelParams struct {
	XTwilioWebhookEnabled *string    `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes            *string    `json:"Attributes,omitempty"`
	CreatedBy             *string    `json:"CreatedBy,omitempty"`
	DateCreated           *time.Time `json:"DateCreated,omitempty"`
	DateUpdated           *time.Time `json:"DateUpdated,omitempty"`
	FriendlyName          *string    `json:"FriendlyName,omitempty"`
	UniqueName            *string    `json:"UniqueName,omitempty"`
}

/*
* UpdateChannel Method for UpdateChannel
* @param ServiceSid
* @param Sid
* @param optional nil or *UpdateChannelParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "CreatedBy" (string) -
* @param "DateCreated" (time.Time) -
* @param "DateUpdated" (time.Time) -
* @param "FriendlyName" (string) -
* @param "UniqueName" (string) -
* @return IpMessagingV2ServiceChannel
 */
func (c *DefaultApiService) UpdateChannel(ServiceSid string, Sid string, params *UpdateChannelParams) (*IpMessagingV2ServiceChannel, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.CreatedBy != nil {
		data.Set("CreatedBy", *params.CreatedBy)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint(*params.DateCreated))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint(*params.DateUpdated))
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.UniqueName != nil {
		data.Set("UniqueName", *params.UniqueName)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateChannelWebhookParams Optional parameters for the method 'UpdateChannelWebhook'
type UpdateChannelWebhookParams struct {
	ConfigurationFilters    *[]string `json:"Configuration.Filters,omitempty"`
	ConfigurationFlowSid    *string   `json:"Configuration.FlowSid,omitempty"`
	ConfigurationMethod     *string   `json:"Configuration.Method,omitempty"`
	ConfigurationRetryCount *int32    `json:"Configuration.RetryCount,omitempty"`
	ConfigurationTriggers   *[]string `json:"Configuration.Triggers,omitempty"`
	ConfigurationUrl        *string   `json:"Configuration.Url,omitempty"`
}

/*
* UpdateChannelWebhook Method for UpdateChannelWebhook
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @param optional nil or *UpdateChannelWebhookParams - Optional Parameters:
* @param "ConfigurationFilters" ([]string) -
* @param "ConfigurationFlowSid" (string) -
* @param "ConfigurationMethod" (string) -
* @param "ConfigurationRetryCount" (int32) -
* @param "ConfigurationTriggers" ([]string) -
* @param "ConfigurationUrl" (string) -
* @return IpMessagingV2ServiceChannelChannelWebhook
 */
func (c *DefaultApiService) UpdateChannelWebhook(ServiceSid string, ChannelSid string, Sid string, params *UpdateChannelWebhookParams) (*IpMessagingV2ServiceChannelChannelWebhook, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.ConfigurationFilters != nil {
		data.Set("ConfigurationFilters", strings.Join(*params.ConfigurationFilters, ","))
	}
	if params != nil && params.ConfigurationFlowSid != nil {
		data.Set("ConfigurationFlowSid", *params.ConfigurationFlowSid)
	}
	if params != nil && params.ConfigurationMethod != nil {
		data.Set("ConfigurationMethod", *params.ConfigurationMethod)
	}
	if params != nil && params.ConfigurationRetryCount != nil {
		data.Set("ConfigurationRetryCount", fmt.Sprint(*params.ConfigurationRetryCount))
	}
	if params != nil && params.ConfigurationTriggers != nil {
		data.Set("ConfigurationTriggers", strings.Join(*params.ConfigurationTriggers, ","))
	}
	if params != nil && params.ConfigurationUrl != nil {
		data.Set("ConfigurationUrl", *params.ConfigurationUrl)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelChannelWebhook{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateCredentialParams Optional parameters for the method 'UpdateCredential'
type UpdateCredentialParams struct {
	ApiKey       *string `json:"ApiKey,omitempty"`
	Certificate  *string `json:"Certificate,omitempty"`
	FriendlyName *string `json:"FriendlyName,omitempty"`
	PrivateKey   *string `json:"PrivateKey,omitempty"`
	Sandbox      *bool   `json:"Sandbox,omitempty"`
	Secret       *string `json:"Secret,omitempty"`
}

/*
* UpdateCredential Method for UpdateCredential
* @param Sid
* @param optional nil or *UpdateCredentialParams - Optional Parameters:
* @param "ApiKey" (string) -
* @param "Certificate" (string) -
* @param "FriendlyName" (string) -
* @param "PrivateKey" (string) -
* @param "Sandbox" (bool) -
* @param "Secret" (string) -
* @return IpMessagingV2Credential
 */
func (c *DefaultApiService) UpdateCredential(Sid string, params *UpdateCredentialParams) (*IpMessagingV2Credential, error) {
	path := "/v2/Credentials/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.ApiKey != nil {
		data.Set("ApiKey", *params.ApiKey)
	}
	if params != nil && params.Certificate != nil {
		data.Set("Certificate", *params.Certificate)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.PrivateKey != nil {
		data.Set("PrivateKey", *params.PrivateKey)
	}
	if params != nil && params.Sandbox != nil {
		data.Set("Sandbox", fmt.Sprint(*params.Sandbox))
	}
	if params != nil && params.Secret != nil {
		data.Set("Secret", *params.Secret)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2Credential{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateMemberParams Optional parameters for the method 'UpdateMember'
type UpdateMemberParams struct {
	XTwilioWebhookEnabled    *string    `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes               *string    `json:"Attributes,omitempty"`
	DateCreated              *time.Time `json:"DateCreated,omitempty"`
	DateUpdated              *time.Time `json:"DateUpdated,omitempty"`
	LastConsumedMessageIndex *int32     `json:"LastConsumedMessageIndex,omitempty"`
	LastConsumptionTimestamp *time.Time `json:"LastConsumptionTimestamp,omitempty"`
	RoleSid                  *string    `json:"RoleSid,omitempty"`
}

/*
* UpdateMember Method for UpdateMember
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @param optional nil or *UpdateMemberParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "DateCreated" (time.Time) -
* @param "DateUpdated" (time.Time) -
* @param "LastConsumedMessageIndex" (*int32) -
* @param "LastConsumptionTimestamp" (time.Time) -
* @param "RoleSid" (string) -
* @return IpMessagingV2ServiceChannelMember
 */
func (c *DefaultApiService) UpdateMember(ServiceSid string, ChannelSid string, Sid string, params *UpdateMemberParams) (*IpMessagingV2ServiceChannelMember, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint(*params.DateCreated))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint(*params.DateUpdated))
	}
	if params != nil && params.LastConsumedMessageIndex != nil {
		data.Set("LastConsumedMessageIndex", fmt.Sprint(*params.LastConsumedMessageIndex))
	}
	if params != nil && params.LastConsumptionTimestamp != nil {
		data.Set("LastConsumptionTimestamp", fmt.Sprint(*params.LastConsumptionTimestamp))
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelMember{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateMessageParams Optional parameters for the method 'UpdateMessage'
type UpdateMessageParams struct {
	XTwilioWebhookEnabled *string    `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes            *string    `json:"Attributes,omitempty"`
	Body                  *string    `json:"Body,omitempty"`
	DateCreated           *time.Time `json:"DateCreated,omitempty"`
	DateUpdated           *time.Time `json:"DateUpdated,omitempty"`
	From                  *string    `json:"From,omitempty"`
	LastUpdatedBy         *string    `json:"LastUpdatedBy,omitempty"`
}

/*
* UpdateMessage Method for UpdateMessage
* @param ServiceSid
* @param ChannelSid
* @param Sid
* @param optional nil or *UpdateMessageParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "Body" (string) -
* @param "DateCreated" (time.Time) -
* @param "DateUpdated" (time.Time) -
* @param "From" (string) -
* @param "LastUpdatedBy" (string) -
* @return IpMessagingV2ServiceChannelMessage
 */
func (c *DefaultApiService) UpdateMessage(ServiceSid string, ChannelSid string, Sid string, params *UpdateMessageParams) (*IpMessagingV2ServiceChannelMessage, error) {
	path := "/v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.Body != nil {
		data.Set("Body", *params.Body)
	}
	if params != nil && params.DateCreated != nil {
		data.Set("DateCreated", fmt.Sprint(*params.DateCreated))
	}
	if params != nil && params.DateUpdated != nil {
		data.Set("DateUpdated", fmt.Sprint(*params.DateUpdated))
	}
	if params != nil && params.From != nil {
		data.Set("From", *params.From)
	}
	if params != nil && params.LastUpdatedBy != nil {
		data.Set("LastUpdatedBy", *params.LastUpdatedBy)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceChannelMessage{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateRoleParams Optional parameters for the method 'UpdateRole'
type UpdateRoleParams struct {
	Permission *[]string `json:"Permission,omitempty"`
}

/*
* UpdateRole Method for UpdateRole
* @param ServiceSid
* @param Sid
* @param optional nil or *UpdateRoleParams - Optional Parameters:
* @param "Permission" ([]string) -
* @return IpMessagingV2ServiceRole
 */
func (c *DefaultApiService) UpdateRole(ServiceSid string, Sid string, params *UpdateRoleParams) (*IpMessagingV2ServiceRole, error) {
	path := "/v2/Services/{ServiceSid}/Roles/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.Permission != nil {
		data.Set("Permission", strings.Join(*params.Permission, ","))
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceRole{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateServiceParams Optional parameters for the method 'UpdateService'
type UpdateServiceParams struct {
	ConsumptionReportInterval                *int32    `json:"ConsumptionReportInterval,omitempty"`
	DefaultChannelCreatorRoleSid             *string   `json:"DefaultChannelCreatorRoleSid,omitempty"`
	DefaultChannelRoleSid                    *string   `json:"DefaultChannelRoleSid,omitempty"`
	DefaultServiceRoleSid                    *string   `json:"DefaultServiceRoleSid,omitempty"`
	FriendlyName                             *string   `json:"FriendlyName,omitempty"`
	LimitsChannelMembers                     *int32    `json:"Limits.ChannelMembers,omitempty"`
	LimitsUserChannels                       *int32    `json:"Limits.UserChannels,omitempty"`
	MediaCompatibilityMessage                *string   `json:"Media.CompatibilityMessage,omitempty"`
	NotificationsAddedToChannelEnabled       *bool     `json:"Notifications.AddedToChannel.Enabled,omitempty"`
	NotificationsAddedToChannelSound         *string   `json:"Notifications.AddedToChannel.Sound,omitempty"`
	NotificationsAddedToChannelTemplate      *string   `json:"Notifications.AddedToChannel.Template,omitempty"`
	NotificationsInvitedToChannelEnabled     *bool     `json:"Notifications.InvitedToChannel.Enabled,omitempty"`
	NotificationsInvitedToChannelSound       *string   `json:"Notifications.InvitedToChannel.Sound,omitempty"`
	NotificationsInvitedToChannelTemplate    *string   `json:"Notifications.InvitedToChannel.Template,omitempty"`
	NotificationsLogEnabled                  *bool     `json:"Notifications.LogEnabled,omitempty"`
	NotificationsNewMessageBadgeCountEnabled *bool     `json:"Notifications.NewMessage.BadgeCountEnabled,omitempty"`
	NotificationsNewMessageEnabled           *bool     `json:"Notifications.NewMessage.Enabled,omitempty"`
	NotificationsNewMessageSound             *string   `json:"Notifications.NewMessage.Sound,omitempty"`
	NotificationsNewMessageTemplate          *string   `json:"Notifications.NewMessage.Template,omitempty"`
	NotificationsRemovedFromChannelEnabled   *bool     `json:"Notifications.RemovedFromChannel.Enabled,omitempty"`
	NotificationsRemovedFromChannelSound     *string   `json:"Notifications.RemovedFromChannel.Sound,omitempty"`
	NotificationsRemovedFromChannelTemplate  *string   `json:"Notifications.RemovedFromChannel.Template,omitempty"`
	PostWebhookRetryCount                    *int32    `json:"PostWebhookRetryCount,omitempty"`
	PostWebhookUrl                           *string   `json:"PostWebhookUrl,omitempty"`
	PreWebhookRetryCount                     *int32    `json:"PreWebhookRetryCount,omitempty"`
	PreWebhookUrl                            *string   `json:"PreWebhookUrl,omitempty"`
	ReachabilityEnabled                      *bool     `json:"ReachabilityEnabled,omitempty"`
	ReadStatusEnabled                        *bool     `json:"ReadStatusEnabled,omitempty"`
	TypingIndicatorTimeout                   *int32    `json:"TypingIndicatorTimeout,omitempty"`
	WebhookFilters                           *[]string `json:"WebhookFilters,omitempty"`
	WebhookMethod                            *string   `json:"WebhookMethod,omitempty"`
}

/*
* UpdateService Method for UpdateService
* @param Sid
* @param optional nil or *UpdateServiceParams - Optional Parameters:
* @param "ConsumptionReportInterval" (int32) -
* @param "DefaultChannelCreatorRoleSid" (string) -
* @param "DefaultChannelRoleSid" (string) -
* @param "DefaultServiceRoleSid" (string) -
* @param "FriendlyName" (string) -
* @param "LimitsChannelMembers" (int32) -
* @param "LimitsUserChannels" (int32) -
* @param "MediaCompatibilityMessage" (string) -
* @param "NotificationsAddedToChannelEnabled" (bool) -
* @param "NotificationsAddedToChannelSound" (string) -
* @param "NotificationsAddedToChannelTemplate" (string) -
* @param "NotificationsInvitedToChannelEnabled" (bool) -
* @param "NotificationsInvitedToChannelSound" (string) -
* @param "NotificationsInvitedToChannelTemplate" (string) -
* @param "NotificationsLogEnabled" (bool) -
* @param "NotificationsNewMessageBadgeCountEnabled" (bool) -
* @param "NotificationsNewMessageEnabled" (bool) -
* @param "NotificationsNewMessageSound" (string) -
* @param "NotificationsNewMessageTemplate" (string) -
* @param "NotificationsRemovedFromChannelEnabled" (bool) -
* @param "NotificationsRemovedFromChannelSound" (string) -
* @param "NotificationsRemovedFromChannelTemplate" (string) -
* @param "PostWebhookRetryCount" (int32) -
* @param "PostWebhookUrl" (string) -
* @param "PreWebhookRetryCount" (int32) -
* @param "PreWebhookUrl" (string) -
* @param "ReachabilityEnabled" (bool) -
* @param "ReadStatusEnabled" (bool) -
* @param "TypingIndicatorTimeout" (int32) -
* @param "WebhookFilters" ([]string) -
* @param "WebhookMethod" (string) -
* @return IpMessagingV2Service
 */
func (c *DefaultApiService) UpdateService(Sid string, params *UpdateServiceParams) (*IpMessagingV2Service, error) {
	path := "/v2/Services/{Sid}"
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.ConsumptionReportInterval != nil {
		data.Set("ConsumptionReportInterval", fmt.Sprint(*params.ConsumptionReportInterval))
	}
	if params != nil && params.DefaultChannelCreatorRoleSid != nil {
		data.Set("DefaultChannelCreatorRoleSid", *params.DefaultChannelCreatorRoleSid)
	}
	if params != nil && params.DefaultChannelRoleSid != nil {
		data.Set("DefaultChannelRoleSid", *params.DefaultChannelRoleSid)
	}
	if params != nil && params.DefaultServiceRoleSid != nil {
		data.Set("DefaultServiceRoleSid", *params.DefaultServiceRoleSid)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.LimitsChannelMembers != nil {
		data.Set("LimitsChannelMembers", fmt.Sprint(*params.LimitsChannelMembers))
	}
	if params != nil && params.LimitsUserChannels != nil {
		data.Set("LimitsUserChannels", fmt.Sprint(*params.LimitsUserChannels))
	}
	if params != nil && params.MediaCompatibilityMessage != nil {
		data.Set("MediaCompatibilityMessage", *params.MediaCompatibilityMessage)
	}
	if params != nil && params.NotificationsAddedToChannelEnabled != nil {
		data.Set("NotificationsAddedToChannelEnabled", fmt.Sprint(*params.NotificationsAddedToChannelEnabled))
	}
	if params != nil && params.NotificationsAddedToChannelSound != nil {
		data.Set("NotificationsAddedToChannelSound", *params.NotificationsAddedToChannelSound)
	}
	if params != nil && params.NotificationsAddedToChannelTemplate != nil {
		data.Set("NotificationsAddedToChannelTemplate", *params.NotificationsAddedToChannelTemplate)
	}
	if params != nil && params.NotificationsInvitedToChannelEnabled != nil {
		data.Set("NotificationsInvitedToChannelEnabled", fmt.Sprint(*params.NotificationsInvitedToChannelEnabled))
	}
	if params != nil && params.NotificationsInvitedToChannelSound != nil {
		data.Set("NotificationsInvitedToChannelSound", *params.NotificationsInvitedToChannelSound)
	}
	if params != nil && params.NotificationsInvitedToChannelTemplate != nil {
		data.Set("NotificationsInvitedToChannelTemplate", *params.NotificationsInvitedToChannelTemplate)
	}
	if params != nil && params.NotificationsLogEnabled != nil {
		data.Set("NotificationsLogEnabled", fmt.Sprint(*params.NotificationsLogEnabled))
	}
	if params != nil && params.NotificationsNewMessageBadgeCountEnabled != nil {
		data.Set("NotificationsNewMessageBadgeCountEnabled", fmt.Sprint(*params.NotificationsNewMessageBadgeCountEnabled))
	}
	if params != nil && params.NotificationsNewMessageEnabled != nil {
		data.Set("NotificationsNewMessageEnabled", fmt.Sprint(*params.NotificationsNewMessageEnabled))
	}
	if params != nil && params.NotificationsNewMessageSound != nil {
		data.Set("NotificationsNewMessageSound", *params.NotificationsNewMessageSound)
	}
	if params != nil && params.NotificationsNewMessageTemplate != nil {
		data.Set("NotificationsNewMessageTemplate", *params.NotificationsNewMessageTemplate)
	}
	if params != nil && params.NotificationsRemovedFromChannelEnabled != nil {
		data.Set("NotificationsRemovedFromChannelEnabled", fmt.Sprint(*params.NotificationsRemovedFromChannelEnabled))
	}
	if params != nil && params.NotificationsRemovedFromChannelSound != nil {
		data.Set("NotificationsRemovedFromChannelSound", *params.NotificationsRemovedFromChannelSound)
	}
	if params != nil && params.NotificationsRemovedFromChannelTemplate != nil {
		data.Set("NotificationsRemovedFromChannelTemplate", *params.NotificationsRemovedFromChannelTemplate)
	}
	if params != nil && params.PostWebhookRetryCount != nil {
		data.Set("PostWebhookRetryCount", fmt.Sprint(*params.PostWebhookRetryCount))
	}
	if params != nil && params.PostWebhookUrl != nil {
		data.Set("PostWebhookUrl", *params.PostWebhookUrl)
	}
	if params != nil && params.PreWebhookRetryCount != nil {
		data.Set("PreWebhookRetryCount", fmt.Sprint(*params.PreWebhookRetryCount))
	}
	if params != nil && params.PreWebhookUrl != nil {
		data.Set("PreWebhookUrl", *params.PreWebhookUrl)
	}
	if params != nil && params.ReachabilityEnabled != nil {
		data.Set("ReachabilityEnabled", fmt.Sprint(*params.ReachabilityEnabled))
	}
	if params != nil && params.ReadStatusEnabled != nil {
		data.Set("ReadStatusEnabled", fmt.Sprint(*params.ReadStatusEnabled))
	}
	if params != nil && params.TypingIndicatorTimeout != nil {
		data.Set("TypingIndicatorTimeout", fmt.Sprint(*params.TypingIndicatorTimeout))
	}
	if params != nil && params.WebhookFilters != nil {
		data.Set("WebhookFilters", strings.Join(*params.WebhookFilters, ","))
	}
	if params != nil && params.WebhookMethod != nil {
		data.Set("WebhookMethod", *params.WebhookMethod)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2Service{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateUserParams Optional parameters for the method 'UpdateUser'
type UpdateUserParams struct {
	XTwilioWebhookEnabled *string `json:"X-Twilio-Webhook-Enabled,omitempty"`
	Attributes            *string `json:"Attributes,omitempty"`
	FriendlyName          *string `json:"FriendlyName,omitempty"`
	RoleSid               *string `json:"RoleSid,omitempty"`
}

/*
* UpdateUser Method for UpdateUser
* @param ServiceSid
* @param Sid
* @param optional nil or *UpdateUserParams - Optional Parameters:
* @param "XTwilioWebhookEnabled" (string) - The X-Twilio-Webhook-Enabled HTTP request header
* @param "Attributes" (string) -
* @param "FriendlyName" (string) -
* @param "RoleSid" (string) -
* @return IpMessagingV2ServiceUser
 */
func (c *DefaultApiService) UpdateUser(ServiceSid string, Sid string, params *UpdateUserParams) (*IpMessagingV2ServiceUser, error) {
	path := "/v2/Services/{ServiceSid}/Users/{Sid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"Sid"+"}", Sid, -1)

	data := url.Values{}
	headers := make(map[string]interface{})

	if params != nil && params.Attributes != nil {
		data.Set("Attributes", *params.Attributes)
	}
	if params != nil && params.FriendlyName != nil {
		data.Set("FriendlyName", *params.FriendlyName)
	}
	if params != nil && params.RoleSid != nil {
		data.Set("RoleSid", *params.RoleSid)
	}

	if params != nil && params.XTwilioWebhookEnabled != nil {
		headers["XTwilioWebhookEnabled"] = *params.XTwilioWebhookEnabled
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceUser{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}

// UpdateUserChannelParams Optional parameters for the method 'UpdateUserChannel'
type UpdateUserChannelParams struct {
	LastConsumedMessageIndex *int32     `json:"LastConsumedMessageIndex,omitempty"`
	LastConsumptionTimestamp *time.Time `json:"LastConsumptionTimestamp,omitempty"`
	NotificationLevel        *string    `json:"NotificationLevel,omitempty"`
}

/*
* UpdateUserChannel Method for UpdateUserChannel
* @param ServiceSid
* @param UserSid
* @param ChannelSid
* @param optional nil or *UpdateUserChannelParams - Optional Parameters:
* @param "LastConsumedMessageIndex" (*int32) -
* @param "LastConsumptionTimestamp" (time.Time) -
* @param "NotificationLevel" (string) -
* @return IpMessagingV2ServiceUserUserChannel
 */
func (c *DefaultApiService) UpdateUserChannel(ServiceSid string, UserSid string, ChannelSid string, params *UpdateUserChannelParams) (*IpMessagingV2ServiceUserUserChannel, error) {
	path := "/v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}"
	path = strings.Replace(path, "{"+"ServiceSid"+"}", ServiceSid, -1)
	path = strings.Replace(path, "{"+"UserSid"+"}", UserSid, -1)
	path = strings.Replace(path, "{"+"ChannelSid"+"}", ChannelSid, -1)

	data := url.Values{}
	headers := 0

	if params != nil && params.LastConsumedMessageIndex != nil {
		data.Set("LastConsumedMessageIndex", fmt.Sprint(*params.LastConsumedMessageIndex))
	}
	if params != nil && params.LastConsumptionTimestamp != nil {
		data.Set("LastConsumptionTimestamp", fmt.Sprint(*params.LastConsumptionTimestamp))
	}
	if params != nil && params.NotificationLevel != nil {
		data.Set("NotificationLevel", *params.NotificationLevel)
	}

	resp, err := c.client.Post(c.baseURL+path, data, headers)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	ps := &IpMessagingV2ServiceUserUserChannel{}
	if err := json.NewDecoder(resp.Body).Decode(ps); err != nil {
		return nil, err
	}

	return ps, err
}
